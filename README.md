

## **üìñ Java Collection Framework - Complete Guide (Basic to Advanced)**  

### **üìå Chapter 1: Introduction to Java Collection Framework**  
- What is a Collection?  
- Need for Collections over Arrays  
- Java Collection Framework Overview  
- Benefits of Using Collections  
- Collection Framework Hierarchy  

---

### **üìå Chapter 2: Iterable and Collection Interface**  
- Understanding `Iterable<T>`  
- Methods of the `Iterable` Interface  
- Understanding `Collection<T>` Interface  
- Important Methods of `Collection` Interface  

---

### **üìå Chapter 3: List Interface (Ordered Collection)**  
- Introduction to `List<T>` Interface  
- Implementations:  
  - `ArrayList` (Dynamic Array, Fast Read)  
  - `LinkedList` (Doubly Linked List, Fast Insert/Delete)  
  - `Vector` (Thread-Safe, Legacy)  
  - `Stack` (LIFO, Legacy)  
  - `CopyOnWriteArrayList` (Thread-Safe Variant of ArrayList)  
- **Operations on List** (Add, Remove, Search, Sort)  
- **Performance Comparison of List Implementations**  

---

### **üìå Chapter 4: Set Interface (Unique Elements Collection)**  
- Introduction to `Set<T>` Interface  
- Implementations:  
  - `HashSet` (Unordered, Unique, Uses Hashing)  
  - `LinkedHashSet` (Maintains Insertion Order)  
  - `TreeSet` (Sorted, Uses Red-Black Tree)  
  - `EnumSet` (Efficient Enum Collection)  
  - `ConcurrentSkipListSet` (Thread-Safe Sorted Set)  
  - `CopyOnWriteArraySet` (Thread-Safe Set)  
- **Set Operations (Union, Intersection, Difference, Subset)**  

---

### **üìå Chapter 5: Queue Interface (FIFO Data Structure)**  
- Introduction to `Queue<T>` Interface  
- Implementations:  
  - `LinkedList` (Can Be Used as Queue)  
  - `PriorityQueue` (Min-Heap Implementation)  
  - `Deque` (Double-Ended Queue)  
  - `ArrayDeque` (Resizable Array-Based Deque)  
  - `ConcurrentLinkedQueue` (Thread-Safe Queue)  
  - **BlockingQueues (Used in Multi-threading)**:  
    - `BlockingQueue` (Interface Overview)  
    - `ArrayBlockingQueue`  
    - `LinkedBlockingQueue`  
    - `PriorityBlockingQueue`  
    - `SynchronousQueue`  
    - `DelayQueue`  

---

### **üìå Chapter 6: Map Interface (Key-Value Pair Collection)**  
- Introduction to `Map<K, V>` Interface  
- Implementations:  
  - `HashMap` (Unordered Key-Value Mapping)  
  - `LinkedHashMap` (Maintains Insertion Order)  
  - `TreeMap` (Sorted Key-Value Mapping)  
  - `Hashtable` (Thread-Safe, Legacy)  
  - `ConcurrentHashMap` (Thread-Safe HashMap)  
- **Map Operations (Put, Get, Remove, Search, Iterate)**  

---

### **üìå Chapter 7: Comparators and Sorting in Collections**  
- `Comparable<T>` Interface (Natural Sorting)  
- `Comparator<T>` Interface (Custom Sorting)  
- Sorting Lists, Sets, and Maps with Comparators  

---

### **üìå Chapter 8: Collections Utility Class (Helper Methods)**  
- Sorting Collections (`Collections.sort()`)  
- Searching in Collections (`Collections.binarySearch()`)  
- Immutable Collections (`Collections.unmodifiableList()`)  
- Thread-Safe Collections (`Collections.synchronizedList()`)  

---

### **üìå Chapter 9: Thread-Safety in Java Collections**  
- Synchronization and Concurrent Collections  
- `CopyOnWriteArrayList`, `CopyOnWriteArraySet`  
- `ConcurrentHashMap`, `ConcurrentSkipListSet`  
- Performance Comparison of Synchronized and Concurrent Collections  

---

### **üìå Chapter 10: Best Practices and Performance Optimization**  
- When to Use Which Collection?  
- Performance Considerations for Different Data Structures  
- Avoiding `NullPointerException` in Collections  
- Optimizing Memory and CPU Usage in Collections  

---


# **üìå Chapter 1: Introduction to Java Collection Framework**  

## **1Ô∏è‚É£ What is a Collection?**  
A **collection** in Java is a **group of objects** stored together. It helps in **storing, retrieving, manipulating, and processing** data efficiently.  

Think of a **collection** as a **container** (like a box) where you can store multiple objects.  

### **üìç Example:**
Imagine you have a list of student names. You can store them using **collections** instead of creating multiple variables.  

```java
List<String> students = new ArrayList<>();
students.add("John");
students.add("Emma");
students.add("David");
```
Here, `students` is a **collection** that stores multiple student names **together**.

### **üí° Key Features of Collections:**
‚úî **Dynamic Size** - Unlike arrays, collections can grow and shrink in size dynamically.  
‚úî **Efficient Operations** - Collections provide powerful methods for searching, sorting, and filtering data.  
‚úî **Flexible Data Structures** - Supports different structures like **lists, sets, and queues**.  

---

## **2Ô∏è‚É£ Need for Collections over Arrays**  
Before collections, **arrays** were the only way to store multiple elements in Java. But arrays have some **limitations**.  

### **‚ùå Limitations of Arrays:**
1Ô∏è‚É£ **Fixed Size** - Once an array is created, its size **cannot** be changed.  
2Ô∏è‚É£ **No Built-in Methods** - Arrays do not provide methods for common tasks like searching or sorting.  
3Ô∏è‚É£ **Only Works with Indexes** - Arrays can only be accessed using **index numbers**, which is not always convenient.  
4Ô∏è‚É£ **Inefficient Insertion/Deletion** - Adding or removing elements in the middle of an array is difficult.  

### **‚úÖ Why Collections are Better?**
‚úî **Dynamic Size** - Collections **automatically resize** when adding/removing elements.  
‚úî **Rich APIs** - Collections have built-in methods for sorting, searching, and filtering.  
‚úî **More Flexibility** - Collections support different data structures like **lists, sets, and queues**.  
‚úî **Easy to Use** - No need to manually manage indexes; you can directly use powerful methods.  

---

## **3Ô∏è‚É£ Java Collection Framework Overview**  
The **Java Collection Framework (JCF)** is a set of **predefined classes and interfaces** that help store and process data efficiently.  

It provides **ready-made implementations** for **Lists, Sets, Queues, and Maps**, so we don‚Äôt have to create them from scratch.  

### **üõ† Components of Java Collection Framework:**
1Ô∏è‚É£ **Interfaces** - Define the structure (e.g., `List`, `Set`, `Queue`, `Map`).  
2Ô∏è‚É£ **Classes** - Implement the interfaces (e.g., `ArrayList`, `HashSet`, `LinkedList`).  
3Ô∏è‚É£ **Methods** - Predefined operations (e.g., `add()`, `remove()`, `contains()`, `sort()`).  

---

## **4Ô∏è‚É£ Benefits of Using Collections**  

### **1Ô∏è‚É£ Dynamic Memory Allocation**
Unlike arrays, collections do not require a **fixed size** at the beginning. They **grow and shrink** dynamically as needed.  

### **2Ô∏è‚É£ Predefined Methods**
Collections provide **built-in methods** like `add()`, `remove()`, `contains()`, `size()`, making operations **easier**.  

### **3Ô∏è‚É£ Better Performance**
Collections are optimized for **fast searching, insertion, and deletion** operations compared to arrays.  

### **4Ô∏è‚É£ Easy Iteration**
Collections support **iterators** and **enhanced for-loops**, making traversal **simpler**.  

```java
for (String name : students) {
    System.out.println(name);
}
```
This is much easier compared to using **indexes in arrays**.

### **5Ô∏è‚É£ Supports Thread Safety**
Java provides **thread-safe** collections like `Vector` and `ConcurrentHashMap`, making them **safe for multi-threading**.

---

## **5Ô∏è‚É£ Collection Framework Hierarchy (Complete Structure)**  
The **Java Collection Framework** is structured as follows:

### **üìå Main Interfaces:**
1Ô∏è‚É£ **Iterable** - The root interface for all collections.  
2Ô∏è‚É£ **Collection** - Extends `Iterable` and is the base for `List`, `Set`, and `Queue`.  
3Ô∏è‚É£ **Map** - Stores data in **key-value pairs** (not part of `Collection`).  

### **üìå Collection Types:**
#### üîπ **List (Ordered, Allows Duplicates)**
- `ArrayList`
- `LinkedList`
- `Vector`
- `Stack`
- `CopyOnWriteArrayList`

#### üîπ **Set (Unique Elements, No Duplicates)**
- `HashSet`
- `LinkedHashSet`
- `TreeSet`
- `EnumSet`
- `CopyOnWriteArraySet`

#### üîπ **Queue (FIFO Data Structure)**
- `PriorityQueue`
- `ArrayDeque`
- `BlockingQueue` (for multi-threading)

#### üîπ **Map (Key-Value Pair Collection)**
- `HashMap`
- `LinkedHashMap`
- `TreeMap`
- `Hashtable`
- `ConcurrentHashMap`

---

## **üìå Summary of Chapter 1**
| Feature            | Arrays           | Collections |
|-------------------|----------------|-------------|
| **Size** | Fixed | Dynamic |
| **Built-in Methods** | No | Yes |
| **Efficiency** | Low (Slow Insert/Delete) | High (Optimized) |
| **Thread Safety** | No | Yes (Some classes) |
| **Data Structure Options** | Only One (Array) | List, Set, Queue, Map |

### **üåü Key Takeaways:**
‚úî **Collections are more powerful than arrays** because they provide **flexibility and efficiency**.  
‚úî The **Java Collection Framework (JCF)** provides **ready-made classes and methods** for handling data efficiently.  
‚úî Different **types of collections** (`List`, `Set`, `Queue`, `Map`) are available for different use cases.  

---


# **üìå Chapter 2: Iterable and Collection Interface**  

## **1Ô∏è‚É£ Understanding `Iterable<T>` Interface**  

### **üìç What is `Iterable<T>`?**  
- `Iterable<T>` is the **root interface** of the Java Collection Framework.  
- It **allows collections to be iterated (looped) using a `for-each` loop**.  
- All major collection classes like `ArrayList`, `LinkedList`, `HashSet`, etc., implement `Iterable<T>`.  

### **üìç Why is `Iterable<T>` Important?**  
1Ô∏è‚É£ It allows **for-each loop** to work on collections.  
2Ô∏è‚É£ It provides an `Iterator` to iterate through elements **one by one**.  

### **üìç Simple Example of `Iterable<T>`**
```java
import java.util.*;

public class IterableExample {
    public static void main(String[] args) {
        List<String> students = new ArrayList<>();
        students.add("Alice");
        students.add("Bob");
        students.add("Charlie");

        // Using for-each loop (Internally uses Iterable)
        for (String name : students) {
            System.out.println(name);
        }
    }
}
```
‚úÖ **Here, `ArrayList` implements `Iterable<T>`**, so we can use a **for-each loop** to iterate through elements.  

---

## **2Ô∏è‚É£ Methods of the `Iterable<T>` Interface**  

The `Iterable<T>` interface provides **only one method** that must be implemented:  

### **üîπ `Iterator<T> iterator()`**
- Returns an **Iterator** to go through elements one by one.  
- The `Iterator` provides **three important methods**:  

| Method | Description |
|--------|-------------|
| `hasNext()` | Returns `true` if more elements are present. |
| `next()` | Returns the next element. |
| `remove()` | Removes the current element. |

### **üìç Example: Using `Iterator`**
```java
import java.util.*;

public class IteratorExample {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(10, 20, 30, 40));

        Iterator<Integer> it = numbers.iterator();  // Getting the iterator

        while (it.hasNext()) {  // Checking if more elements exist
            System.out.println(it.next());  // Printing the next element
        }
    }
}
```
‚úÖ **Here, we manually iterate over `ArrayList` using an `Iterator`.**  

---

## **3Ô∏è‚É£ Understanding `Collection<T>` Interface**  

### **üìç What is `Collection<T>`?**  
- The `Collection<T>` interface **extends `Iterable<T>`**.  
- It provides **basic functionalities** for handling collections of objects.  
- **All major collection types (`List`, `Set`, `Queue`) implement `Collection<T>`.**  

### **üìç Key Features of `Collection<T>`**
‚úî Allows adding and removing elements.  
‚úî Supports operations like checking size, clearing the collection, and checking if it's empty.  
‚úî Implements `Iterable<T>`, so it can be used in a **for-each loop**.  

### **üìç Collection Interface Hierarchy**
```
Iterable<T>
   ‚îÇ
   ‚îú‚îÄ‚îÄ Collection<T> 
         ‚îú‚îÄ‚îÄ List<T>  (Ordered, Duplicates Allowed)
         ‚îú‚îÄ‚îÄ Set<T>  (Unordered, Unique Elements)
         ‚îú‚îÄ‚îÄ Queue<T>  (FIFO)
```
‚úÖ **So, every `List`, `Set`, and `Queue` class is part of `Collection<T>`.**  

### **üìç Example: Using `Collection<T>` Methods**
```java
import java.util.*;

public class CollectionExample {
    public static void main(String[] args) {
        Collection<String> names = new ArrayList<>();  // Collection interface reference
        names.add("John");
        names.add("Emma");
        names.add("David");

        System.out.println("Collection: " + names);
    }
}
```
‚úÖ **Even though `Collection` is an interface, we can use `ArrayList` as an implementation.**  

---

## **4Ô∏è‚É£ Important Methods of `Collection<T>` Interface**  

The `Collection<T>` interface provides **various useful methods**. Let‚Äôs discuss the most important ones:  

| Method | Description |
|--------|-------------|
| `add(T element)` | Adds an element to the collection. |
| `remove(Object obj)` | Removes an element from the collection. |
| `size()` | Returns the number of elements in the collection. |
| `clear()` | Removes all elements from the collection. |
| `contains(Object obj)` | Checks if a specific element exists. |
| `isEmpty()` | Returns `true` if the collection is empty. |

### **üìç Example: Using Collection Methods**
```java
import java.util.*;

public class CollectionMethodsExample {
    public static void main(String[] args) {
        Collection<String> names = new ArrayList<>();
        names.add("Alice");
        names.add("Bob");
        names.add("Charlie");

        System.out.println("Size: " + names.size());  // 3
        System.out.println("Contains Bob? " + names.contains("Bob"));  // true
        names.remove("Bob");
        System.out.println("After removal: " + names);
        names.clear();
        System.out.println("Is collection empty? " + names.isEmpty());  // true
    }
}
```
‚úÖ **Here, we added elements, checked their existence, removed an element, and cleared the collection.**  

---

## **üìå Summary of Chapter 2**
| Feature | `Iterable<T>` | `Collection<T>` |
|----------|-------------|--------------|
| **What is it?** | Root interface for iteration | Extends `Iterable`, supports basic collection operations |
| **Key Method(s)** | `iterator()` | `add()`, `remove()`, `size()`, `clear()`, `contains()` |
| **Usage** | Enables `for-each` loops | Used for storing and managing collections |
| **Implemented By** | `Collection`, `List`, `Set`, `Queue` | `ArrayList`, `HashSet`, `LinkedList`, etc. |

### **üåü Key Takeaways:**
‚úî **`Iterable<T>` is the root interface** that allows iteration through collections.  
‚úî **`Collection<T>` extends `Iterable<T>` and adds basic collection functionalities.**  
‚úî `Collection` provides important methods like `add()`, `remove()`, `size()`, `clear()`, and `contains()`.  
‚úî **All major collection types (`List`, `Set`, `Queue`) implement `Collection<T>`.**  

---



# **üìå Chapter 3: List Interface (Ordered Collection)**  

## **1Ô∏è‚É£ Understanding `List<T>` Interface**  

### **üìç What is `List<T>`?**  
- `List<T>` is an **ordered collection** in Java that allows **duplicate elements**.  
- It extends the `Collection<T>` interface.  
- **Order matters** in `List`, meaning elements are stored in the same sequence in which they are inserted.  
- Unlike `Set<T>`, it **allows duplicate values**.  

### **üìç Characteristics of `List<T>`**
‚úÖ **Maintains Insertion Order** ‚Äì Elements are stored in the order they were added.  
‚úÖ **Allows Duplicates** ‚Äì You can have multiple occurrences of the same element.  
‚úÖ **Indexed Access** ‚Äì Elements can be accessed using **index positions (0, 1, 2, ...)**.  
‚úÖ **Can Contain `null` Values** ‚Äì Unlike some `Set` implementations, `List` can store `null`.  

### **üìç List Interface Hierarchy**
```
Iterable<T>
   ‚îÇ
   ‚îú‚îÄ‚îÄ Collection<T>
         ‚îÇ
         ‚îú‚îÄ‚îÄ List<T>  (Ordered, Duplicates Allowed)
                ‚îú‚îÄ‚îÄ ArrayList<T>  (Fast Read, Dynamic Array)
                ‚îú‚îÄ‚îÄ LinkedList<T>  (Fast Insert/Delete, Doubly Linked List)
                ‚îú‚îÄ‚îÄ Vector<T>  (Thread-Safe, Legacy)
                ‚îú‚îÄ‚îÄ Stack<T>  (LIFO, Legacy)
                ‚îú‚îÄ‚îÄ CopyOnWriteArrayList<T>  (Thread-Safe Variant of ArrayList)
```
‚úÖ **So, every `ArrayList`, `LinkedList`, `Vector`, and `Stack` is a part of `List<T>`.**  

---

## **2Ô∏è‚É£ Methods of `List<T>` Interface**  

The `List<T>` interface provides various useful methods:  

| Method | Description |
|--------|-------------|
| `add(T element)` | Adds an element to the list. |
| `add(int index, T element)` | Inserts an element at a specific index. |
| `remove(int index)` | Removes the element at a given index. |
| `remove(Object obj)` | Removes the first occurrence of a specified object. |
| `get(int index)` | Retrieves the element at a specific index. |
| `set(int index, T element)` | Replaces the element at the given index. |
| `indexOf(T element)` | Returns the first index of an element (or `-1` if not found). |
| `lastIndexOf(T element)` | Returns the last index of an element. |
| `subList(int fromIndex, int toIndex)` | Extracts a portion of the list. |
| `sort(Comparator<T> c)` | Sorts the list using a comparator. |

---

## **3Ô∏è‚É£ Example: Basic Operations with `List<T>`**  

### **üìç Example: Using `ArrayList` as `List`**
```java
import java.util.*;

public class ListExample {
    public static void main(String[] args) {
        List<String> names = new ArrayList<>();  // Using List<T> reference
        names.add("Alice");
        names.add("Bob");
        names.add("Charlie");
        names.add("Alice");  // Duplicates allowed

        System.out.println("List: " + names);  // [Alice, Bob, Charlie, Alice]

        System.out.println("Element at index 1: " + names.get(1));  // Bob

        names.remove(2);  // Removing "Charlie"
        System.out.println("After removal: " + names);  // [Alice, Bob, Alice]

        names.set(1, "David");  // Replacing "Bob" with "David"
        System.out.println("After set: " + names);  // [Alice, David, Alice]
    }
}
```

---

## **4Ô∏è‚É£ Implementations of `List<T>` Interface**  

The `List<T>` interface has multiple implementations. Let‚Äôs discuss each one in detail.  

### **üìå 1. `ArrayList<T>` (Dynamic Array, Fast Read)**  
- Uses **dynamic array** to store elements.  
- **Fast retrieval (O(1))**, but **slower insertion & deletion (O(n))**.  
- **Best when searching elements frequently**.  
- **Not thread-safe** (use `CopyOnWriteArrayList` for thread safety).  

### **üìå 2. `LinkedList<T>` (Doubly Linked List, Fast Insert/Delete)**  
- Uses **doubly linked list** to store elements.  
- **Fast insertion & deletion (O(1))**, but **slower retrieval (O(n))**.  
- **Best when adding/removing elements frequently**.  
- **Not thread-safe** (explicit synchronization needed).  

### **üìå 3. `Vector<T>` (Thread-Safe, Legacy)**  
- Similar to `ArrayList`, but **synchronized (thread-safe)**.  
- **Slower than `ArrayList` due to synchronization overhead**.  
- **Rarely used** today (use `CopyOnWriteArrayList` instead).  

### **üìå 4. `Stack<T>` (LIFO, Legacy)**  
- **Follows Last-In-First-Out (LIFO) order**.  
- Used for **stack operations like undo, recursion, and function calls**.  
- Internally extends `Vector<T>`, making it **thread-safe**.  

### **üìå 5. `CopyOnWriteArrayList<T>` (Thread-Safe Variant of `ArrayList`)**  
- **Best for concurrent applications** where **read operations are more frequent**.  
- Each modification creates a **new copy of the list**, avoiding concurrent modification issues.  
- **Higher memory consumption** due to copying.  

---

## **üìå Summary of `List<T>` Implementations**  

| Implementation | Internal Structure | Performance | Thread Safety | Best Use Case |
|---------------|-------------------|-------------|--------------|--------------|
| **ArrayList** | Dynamic Array | Fast Read (O(1)), Slow Insert/Delete (O(n)) | ‚ùå No | Frequent Read Operations |
| **LinkedList** | Doubly Linked List | Slow Read (O(n)), Fast Insert/Delete (O(1)) | ‚ùå No | Frequent Insert/Delete |
| **Vector** | Dynamic Array | Similar to `ArrayList`, but slower due to synchronization | ‚úÖ Yes | Legacy Code, Multi-threading |
| **Stack** | Dynamic Array (LIFO) | LIFO operations, similar to `Vector` | ‚úÖ Yes | Stack Operations (Undo, Function Calls) |
| **CopyOnWriteArrayList** | Dynamic Array (Copy on Write) | Fast Read, Slow Write | ‚úÖ Yes | Concurrent Read Operations |

---

## **üìå Key Takeaways**
‚úî **`List<T>` is an ordered collection that allows duplicates and indexed access.**  
‚úî It has multiple implementations:  
  - **`ArrayList`** (Fast read, slow insert/delete)  
  - **`LinkedList`** (Slow read, fast insert/delete)  
  - **`Vector`** (Thread-safe, legacy)  
  - **`Stack`** (LIFO structure)  
  - **`CopyOnWriteArrayList`** (Thread-safe variant of `ArrayList`)  
‚úî Choose the right `List<T>` implementation based on **performance needs**.  

---


# **üìå ArrayList<T> (Dynamic Array, Fast Read)**  

## **1Ô∏è‚É£ What is `ArrayList<T>`?**  
- `ArrayList<T>` is a **dynamic array implementation** of the `List<T>` interface.  
- It can **grow and shrink dynamically** based on the number of elements.  
- **Fast read operations (O(1))**, but **slower insert/delete (O(n))** compared to `LinkedList`.  
- It **allows duplicate elements** and **maintains insertion order**.  

---

## **2Ô∏è‚É£ How `ArrayList<T>` Works Internally?**  
üìå **Internal Structure**  
- `ArrayList` internally uses an **array** to store elements.  
- When the **capacity is full**, it **creates a new array** with **1.5x larger size** and **copies old elements into it**.  
- This is why `ArrayList` is **fast for reading**, but **slow for insertion/deletion at the beginning or middle**.  

üõ† **Example:**  
If an `ArrayList` has **capacity 10**, and we try to add the 11th element:  
- Java **creates a new array of size 15 (1.5x of 10)**.  
- It **copies old 10 elements** into the new array.  
- It **adds the 11th element** in the newly allocated space.  

‚úÖ **This process is called "dynamic resizing".**  

---

## **3Ô∏è‚É£ How to Create an `ArrayList<T>`?**  

### **üìç Creating an `ArrayList` in Java**
```java
import java.util.*;

public class ArrayListExample {
    public static void main(String[] args) {
        ArrayList<String> names = new ArrayList<>(); // Creating an empty ArrayList
        names.add("Alice");
        names.add("Bob");
        names.add("Charlie");

        System.out.println("ArrayList: " + names);  // [Alice, Bob, Charlie]
    }
}
```
‚úÖ **Here, we created an `ArrayList<String>` and added elements.**  

---

## **4Ô∏è‚É£ ArrayList Methods (With Examples)**  

### **üìå 1. `add(E element)` ‚Üí Add element to the list**  
Adds an element at the **end of the list**.  
```java
ArrayList<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
System.out.println(list);  // Output: [Java, Python]
```

---

### **üìå 2. `add(int index, E element)` ‚Üí Insert at a specific index**  
Inserts an element at the given **index** (shifts existing elements).  
```java
ArrayList<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
list.add(1, "C++");  // Insert "C++" at index 1
System.out.println(list);  // Output: [Java, C++, Python]
```
‚è≥ **Time Complexity:** `O(n)`, because elements need to shift.

---

### **üìå 3. `get(int index)` ‚Üí Retrieve element at index**  
Gets the **element present at the given index**.  
```java
ArrayList<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
System.out.println(list.get(1));  // Output: Python
```
‚úÖ **Fast (O(1)) since `ArrayList` provides direct access using an index.**

---

### **üìå 4. `set(int index, E element)` ‚Üí Update element at index**  
Replaces the element at the given **index** with a new value.  
```java
ArrayList<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
list.set(1, "C++");  // Replace Python with C++
System.out.println(list);  // Output: [Java, C++]
```
‚úÖ **Efficient operation (O(1)).**  

---

### **üìå 5. `remove(int index)` ‚Üí Remove element by index**  
Removes the **element at the specified index**, shifting elements left.  
```java
ArrayList<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
list.add("C++");
list.remove(1);  // Remove "Python" (index 1)
System.out.println(list);  // Output: [Java, C++]
```
‚è≥ **Time Complexity:** `O(n)`, because elements shift left.

---

### **üìå 6. `remove(Object obj)` ‚Üí Remove element by value**  
Removes the **first occurrence** of the given value.  
```java
ArrayList<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
list.add("C++");
list.remove("Python");  // Remove "Python"
System.out.println(list);  // Output: [Java, C++]
```
‚úÖ **Returns `true` if element was found and removed.**  

---

### **üìå 7. `size()` ‚Üí Get the number of elements**  
Returns the **total number of elements** in the list.  
```java
ArrayList<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
System.out.println(list.size());  // Output: 2
```

---

### **üìå 8. `contains(E element)` ‚Üí Check if element exists**  
Checks if the **list contains a specific element**.  
```java
ArrayList<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
System.out.println(list.contains("Python"));  // Output: true
System.out.println(list.contains("C++"));  // Output: false
```

---

### **üìå 9. `indexOf(E element)` ‚Üí Get index of first occurrence**  
Returns the **index of the first occurrence** of an element (`-1` if not found).  
```java
ArrayList<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
list.add("Java");
System.out.println(list.indexOf("Java"));  // Output: 0
System.out.println(list.indexOf("C++"));  // Output: -1 (not found)
```

---

### **üìå 10. `lastIndexOf(E element)` ‚Üí Get index of last occurrence**  
```java
ArrayList<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
list.add("Java");
System.out.println(list.lastIndexOf("Java"));  // Output: 2
```

---

### **üìå 11. `subList(int fromIndex, int toIndex)` ‚Üí Get portion of list**  
Extracts a **portion of the list** (from `fromIndex` to `toIndex-1`).  
```java
ArrayList<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
list.add("C++");
list.add("JavaScript");
System.out.println(list.subList(1, 3));  // Output: [Python, C++]
```

---

### **üìå 12. `clear()` ‚Üí Remove all elements**  
```java
ArrayList<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
list.clear();
System.out.println(list);  // Output: []
```

---

## **üìå When to Use `ArrayList<T>`?**
‚úî **Best for fast random access (O(1)).**  
‚úî **Use when searching elements frequently.**  
‚úî **Avoid if you need frequent insertions/deletions in the middle.**  

---

## **üìå Summary**  

| Method | Description |
|--------|-------------|
| `add(E e)` | Adds an element to the end |
| `add(int index, E e)` | Inserts element at a specific index |
| `get(int index)` | Retrieves element at an index |
| `set(int index, E e)` | Replaces element at an index |
| `remove(int index)` | Removes element at index |
| `remove(Object obj)` | Removes first occurrence of element |
| `contains(E e)` | Checks if element exists |
| `size()` | Returns the number of elements |
| `clear()` | Removes all elements |
| `subList(int from, int to)` | Gets a portion of the list |

---

# **üìå Deep Dive into `LinkedList<T>` (Doubly Linked List, Fast Insert/Delete)**  

üöÄ **In this chapter, we will explore `LinkedList<T>` in depth**. We will cover **how it works internally, when to use it, and all its methods with easy explanations and examples.**  

---

## **1Ô∏è‚É£ What is `LinkedList<T>`?**  
- `LinkedList<T>` is a **doubly linked list** implementation of the `List<T>` interface.  
- Unlike `ArrayList`, it does **not use an array internally**. Instead, it uses **nodes (objects) that are linked together**.  
- Each node contains **3 parts**:
  1. **Data (Element)**  
  2. **Reference to the next node**  
  3. **Reference to the previous node**  

üîó **Structure of a LinkedList node:**  
```
[Prev | Data | Next]  <-->  [Prev | Data | Next]  <-->  [Prev | Data | Next]
```

‚úÖ **Key Features of `LinkedList<T>`:**  
‚úî **Fast insertions and deletions (`O(1)`)** at the beginning and middle.  
‚úî **Slower searching (`O(n)`)** because elements are not indexed.  
‚úî **Can be used as a `Queue` or `Stack` (since it has `addFirst()` and `removeFirst()`).**  

---

## **2Ô∏è‚É£ How `LinkedList<T>` Works Internally?**  
üìå `LinkedList<T>` maintains a reference to:  
- **First Node (`head`)** ‚Üí Points to the first element.  
- **Last Node (`tail`)** ‚Üí Points to the last element.  

### **Insertion Process:**  
- If inserting at the **beginning** (`addFirst()`), it updates the `head` to the new node.  
- If inserting at the **end** (`addLast()`), it updates the `tail` to the new node.  

### **Deletion Process:**  
- If deleting at the **beginning** (`removeFirst()`), the `head` moves to the next node.  
- If deleting at the **end** (`removeLast()`), the `tail` moves to the previous node.  

‚úÖ **This makes insertion and deletion fast (`O(1)`).**  

---

## **3Ô∏è‚É£ How to Create a `LinkedList<T>`?**  
### **üìç Creating a `LinkedList` in Java**
```java
import java.util.LinkedList;

public class LinkedListExample {
    public static void main(String[] args) {
        LinkedList<String> names = new LinkedList<>(); // Creating a LinkedList
        names.add("Alice");
        names.add("Bob");
        names.add("Charlie");

        System.out.println("LinkedList: " + names);  // Output: [Alice, Bob, Charlie]
    }
}
```

‚úÖ **Here, we created a `LinkedList<String>` and added elements.**  

---

## **4Ô∏è‚É£ `LinkedList<T>` Methods (With Examples)**  

### **üìå 1. `add(E element)` ‚Üí Add element at the end**  
Adds an element to the **end of the list**.  
```java
LinkedList<String> list = new LinkedList<>();
list.add("Java");
list.add("Python");
System.out.println(list);  // Output: [Java, Python]
```

---

### **üìå 2. `add(int index, E element)` ‚Üí Insert at a specific index**  
Inserts an element at the given **index** (shifts existing elements).  
```java
LinkedList<String> list = new LinkedList<>();
list.add("Java");
list.add("Python");
list.add(1, "C++");  // Insert "C++" at index 1
System.out.println(list);  // Output: [Java, C++, Python]
```
‚úÖ **Faster than `ArrayList` for insertions in the middle (`O(1)`).**  

---

### **üìå 3. `addFirst(E element)` ‚Üí Insert at the beginning**  
Inserts an element **at the start of the list**.  
```java
LinkedList<String> list = new LinkedList<>();
list.add("Python");
list.addFirst("Java");  // Add "Java" at the beginning
System.out.println(list);  // Output: [Java, Python]
```

---

### **üìå 4. `addLast(E element)` ‚Üí Insert at the end**  
Same as `add()`, but explicitly adds at the end.  
```java
LinkedList<String> list = new LinkedList<>();
list.add("Python");
list.addLast("JavaScript");
System.out.println(list);  // Output: [Python, JavaScript]
```

---

### **üìå 5. `get(int index)` ‚Üí Retrieve element at index**  
Gets the **element present at the given index**.  
```java
LinkedList<String> list = new LinkedList<>();
list.add("Java");
list.add("Python");
System.out.println(list.get(1));  // Output: Python
```
‚ùå **Slower (`O(n)`) than `ArrayList` because it has to traverse the list.**  

---

### **üìå 6. `getFirst()` ‚Üí Get first element**  
```java
LinkedList<String> list = new LinkedList<>();
list.add("Java");
list.add("Python");
System.out.println(list.getFirst());  // Output: Java
```

---

### **üìå 7. `getLast()` ‚Üí Get last element**  
```java
LinkedList<String> list = new LinkedList<>();
list.add("Java");
list.add("Python");
System.out.println(list.getLast());  // Output: Python
```

---

### **üìå 8. `remove(int index)` ‚Üí Remove element by index**  
Removes the **element at the specified index**.  
```java
LinkedList<String> list = new LinkedList<>();
list.add("Java");
list.add("Python");
list.add("C++");
list.remove(1);  // Remove "Python" (index 1)
System.out.println(list);  // Output: [Java, C++]
```

---

### **üìå 9. `remove(Object obj)` ‚Üí Remove element by value**  
```java
LinkedList<String> list = new LinkedList<>();
list.add("Java");
list.add("Python");
list.remove("Python");  // Remove "Python"
System.out.println(list);  // Output: [Java]
```

---

### **üìå 10. `removeFirst()` ‚Üí Remove first element**  
```java
LinkedList<String> list = new LinkedList<>();
list.add("Java");
list.add("Python");
list.removeFirst();
System.out.println(list);  // Output: [Python]
```

---

### **üìå 11. `removeLast()` ‚Üí Remove last element**  
```java
LinkedList<String> list = new LinkedList<>();
list.add("Java");
list.add("Python");
list.removeLast();
System.out.println(list);  // Output: [Java]
```

---

### **üìå 12. `size()` ‚Üí Get the number of elements**  
```java
LinkedList<String> list = new LinkedList<>();
list.add("Java");
list.add("Python");
System.out.println(list.size());  // Output: 2
```

---

### **üìå 13. `clear()` ‚Üí Remove all elements**  
```java
LinkedList<String> list = new LinkedList<>();
list.add("Java");
list.add("Python");
list.clear();
System.out.println(list);  // Output: []
```

---

## **üìå When to Use `LinkedList<T>`?**
‚úî **Best for fast insertions and deletions (`O(1)`).**  
‚úî **Use when frequently adding/removing elements from the start or middle.**  
‚ùå **Avoid if you need fast random access (`O(n)`).**  

---

## **üìå Summary**  

| Method | Description |
|--------|-------------|
| `add(E e)` | Adds an element at the end |
| `addFirst(E e)` | Adds an element at the beginning |
| `get(int index)` | Retrieves element at an index |
| `remove(int index)` | Removes element at index |
| `removeFirst()` | Removes the first element |
| `removeLast()` | Removes the last element |
| `clear()` | Removes all elements |

---

# **üìå Deep Dive: How `LinkedList<T>` Works Internally in Java**  

üöÄ In this section, we will **break down the internal working of `LinkedList<T>`** step by step.  
I will explain **how elements are stored, inserted, deleted, and accessed internally** using a **doubly linked list structure**.  

---

## **1Ô∏è‚É£ What is a Linked List?**  

A **Linked List** is a **linear data structure** that consists of a **sequence of nodes** where:  

1. **Each node stores two things:**
   - **Data** (the actual element)
   - **References (pointers) to the next and previous nodes**  

2. Unlike an **array**, which stores elements **contiguously in memory**, a **linked list stores elements in separate memory locations**, connected using pointers.  

### **üìç Structure of a `LinkedList<T>` Node:**  
Each node contains **three parts**:  
```
[Prev | Data | Next]
```
- **Prev** ‚Üí Points to the **previous** node  
- **Data** ‚Üí Stores the **actual value**  
- **Next** ‚Üí Points to the **next** node  

### **üìå Example of a `LinkedList` with three elements:**  
```
Head -> [null | A | ‚¨á]  <-->  [‚¨Ü | B | ‚¨á]  <-->  [‚¨Ü | C | null] <- Tail
```
- **Head** points to the **first node (A)**  
- **Tail** points to the **last node (C)**  
- Each node is **connected both ways** (Doubly Linked List)  

---

## **2Ô∏è‚É£ How Java's `LinkedList<T>` Works Internally?**  

üìå **Java‚Äôs `LinkedList<T>` is implemented as a Doubly Linked List (`DLL`).**  
- The `LinkedList` class has **two important instance variables**:
  - `Node first` ‚Üí **Points to the first node** (head)
  - `Node last` ‚Üí **Points to the last node** (tail)  

üìå **Internal Node Class (`LinkedList.Node<T>`)**
```java
private static class Node<T> {
    T item;       // The actual data stored
    Node<T> next; // Pointer to the next node
    Node<T> prev; // Pointer to the previous node

    Node(Node<T> prev, T item, Node<T> next) {
        this.item = item;
        this.next = next;
        this.prev = prev;
    }
}
```
‚úÖ **Each node stores:**  
- **Data (`item`)**
- **Next node reference (`next`)**
- **Previous node reference (`prev`)**  

---

## **3Ô∏è‚É£ How `add(E element)` Works Internally?**  

üìå **Adding elements to a `LinkedList` (appending to the end)**  
```java
LinkedList<String> list = new LinkedList<>();
list.add("A"); 
list.add("B");
list.add("C");
```

### **Step-by-Step Execution:**  
1. **First Element "A" is added** ‚Üí A new node is created  
   ```
   [null | A | null] 
   ```
   - **Head and Tail both point to A**  

2. **Second Element "B" is added**  
   ```
   [null | A | ‚¨á]  <-->  [‚¨Ü | B | null]  
   ```
   - **A‚Äôs `next` pointer points to B**  
   - **B‚Äôs `prev` pointer points to A**  
   - **Tail now points to B**  

3. **Third Element "C" is added**  
   ```
   [null | A | ‚¨á]  <-->  [‚¨Ü | B | ‚¨á]  <-->  [‚¨Ü | C | null]  
   ```
   - **B‚Äôs `next` pointer points to C**  
   - **C‚Äôs `prev` pointer points to B**  
   - **Tail now points to C**  

‚úÖ **Insertion is O(1) because we only update pointers.**  

---

## **4Ô∏è‚É£ How `remove(E element)` Works Internally?**  

üìå **Removing an element from `LinkedList`**  
```java
list.remove("B");  // Remove "B"
```

### **Step-by-Step Execution:**  
Before removing:  
```
[null | A | ‚¨á]  <-->  [‚¨Ü | B | ‚¨á]  <-->  [‚¨Ü | C | null]
```
1. **Find "B"** ‚Üí Traverse nodes until we reach "B"  
2. **Update Pointers**  
   - **A‚Äôs `next` now points to C**
   - **C‚Äôs `prev` now points to A**  
3. **Remove "B"**  

After removing "B":  
```
[null | A | ‚¨á]  <-->  [‚¨Ü | C | null]
```

‚úÖ **Removal is O(1) if we already have a reference, otherwise O(n) if we search first.**  

---

## **5Ô∏è‚É£ How `get(int index)` Works Internally?**  

üìå **Retrieving an element by index (`O(n)`)**  
```java
String value = list.get(2);  // Fetch element at index 2
```
1. **If `index < size/2`**, start from **head** and move forward  
2. **If `index > size/2`**, start from **tail** and move backward  

Example for `list.get(2)`:  
```
[null | A | ‚¨á]  <-->  [‚¨Ü | B | ‚¨á]  <-->  [‚¨Ü | C | null]
```
1. **Start from `head` and move `next` twice** ‚Üí Reached C  
2. **Return C**  

‚úÖ **Slower than `ArrayList` because there is no direct index access (O(n) complexity).**  

---

## **6Ô∏è‚É£ How `addFirst()` and `addLast()` Work?**  

üìå **`addFirst(E e)` ‚Üí Adds element at the start**  
```java
list.addFirst("X");
```
Before:  
```
[null | A | ‚¨á]  <-->  [‚¨Ü | B | ‚¨á]  <-->  [‚¨Ü | C | null]
```
After adding `"X"` at the start:  
```
[null | X | ‚¨á]  <-->  [‚¨Ü | A | ‚¨á]  <-->  [‚¨Ü | B | ‚¨á]  <-->  [‚¨Ü | C | null]
```
‚úÖ **O(1) complexity since only head pointer changes.**  

üìå **`addLast(E e)` ‚Üí Adds element at the end**  
```java
list.addLast("Y");
```
```
[null | X | ‚¨á]  <-->  [‚¨Ü | A | ‚¨á]  <-->  [‚¨Ü | B | ‚¨á]  <-->  [‚¨Ü | C | ‚¨á]  <-->  [‚¨Ü | Y | null]
```
‚úÖ **O(1) complexity since only tail pointer changes.**  

---

## **7Ô∏è‚É£ Time Complexity Comparison**  

| Operation | LinkedList | ArrayList |
|-----------|-----------|-----------|
| Insert at End | O(1) | O(1) |
| Insert at Beginning | O(1) | O(n) |
| Insert in Middle | O(1) (if reference is known) | O(n) |
| Delete at Beginning | O(1) | O(n) |
| Delete at End | O(1) | O(1) |
| Delete in Middle | O(1) (if reference is known) | O(n) |
| Access (get) | O(n) | O(1) |

üîπ **LinkedList is better for frequent insertions and deletions.**  
üîπ **ArrayList is better for fast access (`get(index)`).**  

---

## **üìå Conclusion**
‚úÖ **LinkedList<T> works internally as a doubly linked list.**  
‚úÖ **Each node stores data, a pointer to the next node, and a pointer to the previous node.**  
‚úÖ **Insertions and deletions are O(1) if the reference is known.**  
‚úÖ **Retrieving elements by index is O(n) (slower than `ArrayList`).**  

---


# **üìå Deep Dive into `Vector<T>` in Java**  


## **1Ô∏è‚É£ What is a `Vector<T>`?**  

üîπ `Vector<T>` is a **dynamic array** in Java, just like `ArrayList<T>`, but with **one key difference**:  
**Vector is thread-safe** (i.e., multiple threads can access it safely).  

üîπ `Vector<T>` is a part of **Java's legacy collection framework**, but it is still used when we need **a synchronized (thread-safe) list**.  

üîπ **Package:**  
```java
import java.util.Vector;
```

---

## **2Ô∏è‚É£ Why Use `Vector<T>`?**  

üí° **Why do we need Vector when we have ArrayList?**  

‚úÖ **Thread Safety**: `Vector<T>` is synchronized, so it can be used safely in multi-threaded environments.  

‚úÖ **Dynamic Resizing**: Unlike an array, `Vector` grows dynamically when more elements are added.  

‚úÖ **Fast Random Access**: Since it is an **array-based** structure, `Vector` allows fast access via an index.  

üö´ **But...**  
- **`Vector<T>` is slower than `ArrayList<T>`** because **each method in Vector is synchronized**, making it thread-safe but slower.  
- **If you don‚Äôt need thread safety, use `ArrayList<T>` instead.**  

---

## **3Ô∏è‚É£ Internal Working of `Vector<T>`**  

üìå **How `Vector<T>` stores elements internally?**  
- `Vector<T>` is implemented **internally as a resizable array**.  
- It has an **initial capacity** (default = 10), and when it is full, **it grows by doubling its size**.  

### **Internal Structure of `Vector<T>` (Before Resizing)**  
```
[ A ] [ B ] [ C ] [ D ] [ E ] [ - ] [ - ] [ - ] [ - ] [ - ]
(size = 5, capacity = 10)
```

### **After Adding More Elements (Resizing Happens)**  
```
[ A ] [ B ] [ C ] [ D ] [ E ] [ F ] [ G ] [ H ] [ I ] [ J ] 
(size = 10, capacity = 10)
```
‚úÖ **If one more element is added, Vector resizes (doubles capacity from 10 ‚Üí 20):**  
```
[ A ] [ B ] [ C ] [ D ] [ E ] [ F ] [ G ] [ H ] [ I ] [ J ] [ K ] [ - ] [ - ] [ - ] [ - ] [ - ] ...
(size = 11, capacity = 20)
```
üìå **Key Point:** Vector **doubles its capacity when it exceeds the limit**, while `ArrayList` grows by **50% of its size**.  

---

## **4Ô∏è‚É£ How to Create a `Vector<T>`?**  

### **üìç Default Constructor (Capacity = 10)**
```java
Vector<Integer> vector = new Vector<>();
```
üìå This creates a `Vector` with **default capacity = 10**.

---

### **üìç Specifying Initial Capacity**
```java
Vector<Integer> vector = new Vector<>(20);
```
üìå This creates a `Vector` with **initial capacity = 20**.

---

### **üìç Specifying Capacity Increment**
```java
Vector<Integer> vector = new Vector<>(10, 5);
```
üìå **Initial capacity = 10**  
üìå **Increases by 5 when full** (instead of doubling).  

---

## **5Ô∏è‚É£ Important Methods in `Vector<T>` (with Examples)**  

### **üìç 1. `add(E e)` - Add an element at the end**
```java
Vector<String> vector = new Vector<>();
vector.add("A");
vector.add("B");
vector.add("C");
System.out.println(vector);  // Output: [A, B, C]
```

---

### **üìç 2. `add(int index, E element)` - Insert at a specific position**
```java
vector.add(1, "X");  
System.out.println(vector);  // Output: [A, X, B, C]
```

---

### **üìç 3. `get(int index)` - Retrieve element at index**
```java
String element = vector.get(2); 
System.out.println(element);  // Output: B
```

---

### **üìç 4. `remove(int index)` - Remove element at index**
```java
vector.remove(1);  
System.out.println(vector);  // Output: [A, B, C]
```

---

### **üìç 5. `remove(Object obj)` - Remove specific object**
```java
vector.remove("B");  
System.out.println(vector);  // Output: [A, C]
```

---

### **üìç 6. `set(int index, E element)` - Replace an element**
```java
vector.set(1, "Z");  
System.out.println(vector);  // Output: [A, Z, C]
```

---

### **üìç 7. `size()` - Get the number of elements**
```java
System.out.println(vector.size());  // Output: 3
```

---

### **üìç 8. `capacity()` - Get current capacity**
```java
System.out.println(vector.capacity());  // Output: 10 (default)
```

---

### **üìç 9. `isEmpty()` - Check if Vector is empty**
```java
System.out.println(vector.isEmpty());  // Output: false
```

---

### **üìç 10. `contains(E e)` - Check if element exists**
```java
System.out.println(vector.contains("Z"));  // Output: true
```

---

### **üìç 11. `clear()` - Remove all elements**
```java
vector.clear();
System.out.println(vector);  // Output: []
```

---

### **üìç 12. `forEach()` - Iterate using forEach loop**
```java
vector.add("A");
vector.add("B");
vector.add("C");

vector.forEach(e -> System.out.println(e));  
// Output:
// A
// B
// C
```

---

## **6Ô∏è‚É£ Performance Comparison (`Vector<T>` vs `ArrayList<T>`)**  

| Operation | `Vector<T>` | `ArrayList<T>` |
|-----------|------------|---------------|
| Thread Safety | ‚úÖ Yes (Synchronized) | ‚ùå No |
| Performance | üö´ Slower | ‚úÖ Faster |
| Resizing Policy | Doubles capacity | Increases by 50% |
| Random Access (`get(int)`) | ‚úÖ O(1) | ‚úÖ O(1) |
| Insert/Delete in Middle | üö´ O(n) | üö´ O(n) |
| Insert/Delete at End | ‚úÖ O(1) | ‚úÖ O(1) |

üöÄ **Use `Vector<T>` only when thread safety is required.**  
üöÄ **For better performance in single-threaded applications, use `ArrayList<T>`.**  

---

## **üìå Conclusion**
‚úÖ `Vector<T>` is a **resizable array** that is **synchronized (thread-safe)**.  
‚úÖ It has **slower performance** than `ArrayList<T>` due to **synchronization overhead**.  
‚úÖ **Use `Vector<T>` when multiple threads modify the list simultaneously**.  
‚úÖ **Prefer `ArrayList<T>` for better performance in a single-threaded environment**.  

---

# **üìå Deep Dive into `Stack<T>` in Java**  


## **1Ô∏è‚É£ What is a `Stack<T>`?**  

üîπ `Stack<T>` is a **Last In, First Out (LIFO)** data structure in Java.  
üîπ It is a **special type of `Vector<T>`** that **allows only specific operations**.  
üîπ The **last element added is the first to be removed** (just like a stack of plates üçΩÔ∏è).  
üîπ **Stack is synchronized**, meaning it is **thread-safe**, but **slower than non-synchronized alternatives**.  

üîπ **Package:**  
```java
import java.util.Stack;
```

üìå **Key Concept: LIFO (Last In, First Out)**  
```
Push -> [ A ] [ B ] [ C ] (C is the last added)
Pop -> [ A ] [ B ] (C is removed first)
```

---

## **2Ô∏è‚É£ Why Use `Stack<T>`?**  

üí° **When should you use a Stack?**  

‚úÖ **When you need LIFO order** (Last In, First Out).  
‚úÖ **Undo/Redo operations** (e.g., in text editors).  
‚úÖ **Browser back/forward history**.  
‚úÖ **Expression evaluation** (e.g., parsing arithmetic expressions).  
‚úÖ **Recursion tracking** (call stack in programming).  

üö´ **But...**  
- **Stack<T> is slower than alternatives like `Deque<T>`** because it is synchronized.  
- **For better performance, use `ArrayDeque<T>` instead of `Stack<T>`**.  

---

## **3Ô∏è‚É£ Internal Working of `Stack<T>`**  

üìå **How `Stack<T>` stores elements internally?**  
- `Stack<T>` extends `Vector<T>` ‚Üí **It is a dynamic array** that resizes itself when full.  
- It provides **extra methods** like `push()`, `pop()`, `peek()`, etc., for stack operations.  
- Stack **inherits all properties of `Vector<T>`**, including thread safety.

### **Internal Structure of `Stack<T>`**
```
Bottom ‚Üí [ A ] [ B ] [ C ] ‚Üê Top
```
- **Push(`D`) ‚Üí** `[ A ] [ B ] [ C ] [ D ]`  
- **Pop() ‚Üí** `[ A ] [ B ] [ C ]` (removes `D`)  

---

## **4Ô∏è‚É£ How to Create a `Stack<T>`?**  

### **üìç Creating a Stack**
```java
Stack<Integer> stack = new Stack<>();
```
üìå This creates an **empty Stack**.

---

## **5Ô∏è‚É£ Important Methods in `Stack<T>` (with Examples)**  

### **üìç 1. `push(E e)` - Add an element to the top**
```java
stack.push(10);
stack.push(20);
stack.push(30);
System.out.println(stack);  // Output: [10, 20, 30]
```

---

### **üìç 2. `pop()` - Remove and return the top element**
```java
int topElement = stack.pop();
System.out.println(topElement);  // Output: 30
System.out.println(stack);  // Output: [10, 20]
```

---

### **üìç 3. `peek()` - Get the top element without removing it**
```java
int topElement = stack.peek();
System.out.println(topElement);  // Output: 20
System.out.println(stack);  // Output: [10, 20] (unchanged)
```

---

### **üìç 4. `isEmpty()` - Check if stack is empty**
```java
System.out.println(stack.isEmpty());  // Output: false
```

---

### **üìç 5. `search(E e)` - Find an element‚Äôs position from the top**
```java
int position = stack.search(10);
System.out.println(position);  // Output: 2 (position from top, 1-based index)
```
üìå **Returns -1 if element is not found.**

---

### **üìç 6. `size()` - Get number of elements in the stack**
```java
System.out.println(stack.size());  // Output: 2
```

---

### **üìç 7. `contains(E e)` - Check if an element exists**
```java
System.out.println(stack.contains(20));  // Output: true
System.out.println(stack.contains(40));  // Output: false
```

---

### **üìç 8. `clear()` - Remove all elements**
```java
stack.clear();
System.out.println(stack);  // Output: []
```

---

## **6Ô∏è‚É£ Performance of `Stack<T>`**  

| Operation | Time Complexity |
|-----------|---------------|
| `push(E e)` | O(1) |
| `pop()` | O(1) |
| `peek()` | O(1) |
| `search(E e)` | O(n) |
| `isEmpty()` | O(1) |

üìå **Stack operations are generally fast (O(1))**, but searching takes **O(n)** time.

---

## **7Ô∏è‚É£ `Stack<T>` vs `ArrayDeque<T>` (Which is better?)**  

| Feature | `Stack<T>` | `ArrayDeque<T>` |
|---------|------------|----------------|
| **Thread Safe?** | ‚úÖ Yes | ‚ùå No |
| **Performance** | üö´ Slower (synchronized) | ‚úÖ Faster (unsynchronized) |
| **LIFO Support** | ‚úÖ Yes | ‚úÖ Yes |
| **Used for?** | Legacy Code, Thread Safety | Better Performance |

üöÄ **Use `ArrayDeque<T>` instead of `Stack<T>` for better performance!**  

---

## **üìå Conclusion**
‚úÖ `Stack<T>` is a **LIFO (Last In, First Out) data structure** in Java.  
‚úÖ It is **thread-safe**, but **slower than alternatives like `ArrayDeque<T>`**.  
‚úÖ It is used in **undo/redo, recursion, expression evaluation, etc.**  
‚úÖ **Use `Stack<T>` when you need thread safety, but prefer `ArrayDeque<T>` for better performance.**  

---


# **üìå Deep Dive into `CopyOnWriteArrayList<T>` in Java**  

## **1Ô∏è‚É£ What is `CopyOnWriteArrayList<T>`?**  

üîπ `CopyOnWriteArrayList<T>` is a **thread-safe** version of `ArrayList<T>`.  
üîπ It belongs to the `java.util.concurrent` package.  
üîπ It **allows multiple threads to read the list concurrently without locking**.  
üîπ But, **modifications (add, remove, set) create a new copy of the array**, making it different from `ArrayList<T>`.  
üîπ Best suited for **scenarios where reads are more frequent than writes**.  

---

## **2Ô∏è‚É£ Why Use `CopyOnWriteArrayList<T>`?**  

üí° **When should you use `CopyOnWriteArrayList<T>`?**  

‚úÖ **If multiple threads need to read the list simultaneously**.  
‚úÖ **If reads happen more often than writes** (because writes are costly).  
‚úÖ **If you want to avoid `ConcurrentModificationException`** during iteration.  
‚úÖ **Best for caching, notifications, and event handling systems**.  

üö´ **But...**  
- **Every modification (add, remove) creates a new copy of the list**, which makes it **memory-heavy**.  
- **Slower for frequent modifications** compared to `ArrayList<T>` and `LinkedList<T>`.  

---

## **3Ô∏è‚É£ Internal Working of `CopyOnWriteArrayList<T>`**  

üìå **How does it work?**  
- `CopyOnWriteArrayList<T>` uses **an internal array (`Object[] array`) to store elements**.  
- Every time a modification occurs (add, remove, set), **a new copy of the entire array is created**.  
- This ensures that **read operations are never blocked**, but **modifications are expensive**.  

### **Internal Structure**
```
Original List: [ A ] [ B ] [ C ]
Modification (add D) ‚Üí New List: [ A ] [ B ] [ C ] [ D ]
```
- **Reads use the old array** until the modification is complete.  
- **After modification, the reference is updated to the new array.**  

---

## **4Ô∏è‚É£ How to Create a `CopyOnWriteArrayList<T>`?**  

üìå **Import the package:**  
```java
import java.util.concurrent.CopyOnWriteArrayList;
```

### **üìç Creating a CopyOnWriteArrayList**
```java
CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();
```
üìå This creates an **empty thread-safe list**.

---

## **5Ô∏è‚É£ Important Methods in `CopyOnWriteArrayList<T>` (with Examples)**  

### **üìç 1. `add(E e)` - Add an element to the list**
```java
list.add(10);
list.add(20);
list.add(30);
System.out.println(list);  // Output: [10, 20, 30]
```

---

### **üìç 2. `remove(int index)` - Remove element at a specific index**
```java
list.remove(1);
System.out.println(list);  // Output: [10, 30]
```

---

### **üìç 3. `get(int index)` - Get element at a specific index**
```java
int element = list.get(0);
System.out.println(element);  // Output: 10
```

---

### **üìç 4. `size()` - Get number of elements in the list**
```java
System.out.println(list.size());  // Output: 2
```

---

### **üìç 5. `contains(E e)` - Check if an element exists**
```java
System.out.println(list.contains(30));  // Output: true
System.out.println(list.contains(50));  // Output: false
```

---

### **üìç 6. `set(int index, E e)` - Update an element at a specific index**
```java
list.set(1, 40);
System.out.println(list);  // Output: [10, 40]
```

---

### **üìç 7. `iterator()` - Get an iterator (safe from `ConcurrentModificationException`)**
```java
for (Integer num : list) {
    System.out.println(num);
}
```
üìå Unlike `ArrayList<T>`, this **will NOT throw `ConcurrentModificationException`** even if another thread modifies the list while iterating.

---

### **üìç 8. `clear()` - Remove all elements**
```java
list.clear();
System.out.println(list);  // Output: []
```

---

## **6Ô∏è‚É£ Performance of `CopyOnWriteArrayList<T>`**  

| Operation | Time Complexity |
|-----------|---------------|
| `add(E e)` | O(n) (creates a new array) |
| `remove(int index)` | O(n) (creates a new array) |
| `get(int index)` | O(1) |
| `contains(E e)` | O(n) |
| `set(int index, E e)` | O(n) (creates a new array) |
| `iterator()` | O(n) (creates a snapshot) |

üìå **Read operations (`get()`) are fast (O(1)), but modifications (`add()`, `set()`, `remove()`) are slow (O(n)).**  

---

## **7Ô∏è‚É£ `CopyOnWriteArrayList<T>` vs `ArrayList<T>` vs `Vector<T>`**  

| Feature | `CopyOnWriteArrayList<T>` | `ArrayList<T>` | `Vector<T>` |
|---------|----------------|-------------|-------------|
| **Thread Safe?** | ‚úÖ Yes | ‚ùå No | ‚úÖ Yes |
| **Performance (Read)** | ‚úÖ Fast | ‚úÖ Fast | ‚ùå Slow |
| **Performance (Write)** | üö´ Slow | ‚úÖ Fast | üö´ Slow |
| **Best Use Case** | **Many reads, few writes** | **General purpose** | **Legacy multi-threading** |

üöÄ **Use `CopyOnWriteArrayList<T>` when multiple threads need fast reads, but few writes.**  

---

## **üìå Conclusion**
‚úÖ `CopyOnWriteArrayList<T>` is a **thread-safe alternative to `ArrayList<T>`**.  
‚úÖ It **allows multiple threads to read safely without locking**.  
‚úÖ **Every modification creates a new copy of the list, making writes expensive**.  
‚úÖ **Best suited for scenarios where reads are more frequent than writes**.  
‚úÖ **Avoid using it when frequent modifications are needed (use `ArrayList<T>` or `ConcurrentLinkedQueue<T>` instead).**  

---

# **üìå Chapter 4: Set Interface (Unique Elements Collection) in Java**  

## **1Ô∏è‚É£ What is a `Set<T>`?**  

üìå **Definition:**  
A `Set<T>` is a collection that **stores unique elements** and does **not allow duplicates**.  

üìå **Key Features of `Set<T>`:**  
‚úÖ **No duplicate elements allowed** (Each element is unique)  
‚úÖ **Can be unordered or ordered** (depends on the implementation)  
‚úÖ **Efficient for search and lookup operations**  
‚úÖ **Useful for mathematical set operations (union, intersection, etc.)**  

---

## **2Ô∏è‚É£ Why Use `Set<T>` Instead of `List<T>`?**  

| Feature | `List<T>` | `Set<T>` |
|---------|----------|----------|
| Allows Duplicates? | ‚úÖ Yes | ‚ùå No |
| Maintains Order? | ‚úÖ Yes | ‚ùå (Depends on implementation) |
| Search Performance | ‚ùå Slower (O(n) for `ArrayList`, O(log n) for `LinkedList`) | ‚úÖ Faster (O(1) in `HashSet`) |
| Best Use Case | **If duplicates are allowed & order matters** | **If you need only unique elements** |

üìå **Use `Set<T>` when you need to store unique elements and don't care about order.**  

---

## **3Ô∏è‚É£ Implementations of `Set<T>` in Java**  

üìå There are **six main implementations** of `Set<T>` in Java:  
### **1Ô∏è‚É£ `HashSet<T>`**
‚úÖ **Unordered**  
‚úÖ Uses **hashing** for fast search operations  
‚úÖ Best for **fast access and uniqueness**  

### **2Ô∏è‚É£ `LinkedHashSet<T>`**
‚úÖ **Maintains insertion order**  
‚úÖ Uses a **linked list + hash table**  
‚úÖ Best for **unique elements while maintaining order**  

### **3Ô∏è‚É£ `TreeSet<T>`**
‚úÖ **Sorted set (Natural ordering)**  
‚úÖ Uses a **Red-Black Tree (Self-balancing BST)**  
‚úÖ Best for **keeping elements sorted**  

### **4Ô∏è‚É£ `EnumSet<T>`**
‚úÖ **Specialized set for Enums**  
‚úÖ **Very fast and memory-efficient**  

### **5Ô∏è‚É£ `ConcurrentSkipListSet<T>`**
‚úÖ **Thread-safe sorted set**  
‚úÖ Uses a **Skip List for ordering**  
‚úÖ Best for **multi-threaded applications**  

### **6Ô∏è‚É£ `CopyOnWriteArraySet<T>`**
‚úÖ **Thread-safe Set**  
‚úÖ **Good for concurrent read-heavy operations**  

---

## **4Ô∏è‚É£ Internal Working of `Set<T>` Implementations**  

üìå **How does `HashSet<T>` store elements?**  
- Uses **a Hash Table (based on HashMap)**.  
- Uses **hashing** to store elements efficiently.  
- **Search, Insert, Delete ‚Üí O(1) time complexity** (best case).  

üìå **How does `LinkedHashSet<T>` work?**  
- Same as `HashSet<T>`, but **maintains insertion order** using a **doubly linked list**.  

üìå **How does `TreeSet<T>` work?**  
- Uses a **self-balancing Red-Black Tree**.  
- Always **keeps elements sorted**.  
- **Insert, Delete, Search ‚Üí O(log n) time complexity**.  

üìå **How does `ConcurrentSkipListSet<T>` work?**  
- Uses a **Skip List (multiple linked lists at different levels for fast search)**.  
- **Thread-safe and sorted**.  
- **Slower than `TreeSet` in single-threaded cases but better in multi-threading**.  

---

## **5Ô∏è‚É£ Set Operations (Mathematical Operations on Sets)**  

üìå **Java provides useful methods to perform operations like:**  

### **üìç 1. Union (A ‚à™ B) ‚Üí Combine elements from both sets**  
```java
Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3));
Set<Integer> set2 = new HashSet<>(Arrays.asList(3, 4, 5));

set1.addAll(set2);
System.out.println(set1);  // Output: [1, 2, 3, 4, 5]
```

---

### **üìç 2. Intersection (A ‚à© B) ‚Üí Common elements**  
```java
Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3));
Set<Integer> set2 = new HashSet<>(Arrays.asList(3, 4, 5));

set1.retainAll(set2);
System.out.println(set1);  // Output: [3]
```

---

### **üìç 3. Difference (A - B) ‚Üí Elements in A but not in B**  
```java
Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3));
Set<Integer> set2 = new HashSet<>(Arrays.asList(3, 4, 5));

set1.removeAll(set2);
System.out.println(set1);  // Output: [1, 2]
```

---

### **üìç 4. Subset Check (A ‚äÜ B) ‚Üí Check if A is a subset of B**  
```java
Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2));
Set<Integer> set2 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));

System.out.println(set2.containsAll(set1));  // Output: true
```

---

## **6Ô∏è‚É£ Choosing the Right `Set<T>` Implementation**  

| Feature | `HashSet<T>` | `LinkedHashSet<T>` | `TreeSet<T>` | `EnumSet<T>` | `ConcurrentSkipListSet<T>` | `CopyOnWriteArraySet<T>` |
|---------|-------------|----------------|------------|------------|---------------------|-------------------|
| **Duplicate Elements** | ‚ùå No | ‚ùå No | ‚ùå No | ‚ùå No | ‚ùå No | ‚ùå No |
| **Maintains Order?** | ‚ùå No | ‚úÖ Yes (Insertion Order) | ‚úÖ Yes (Sorted) | ‚ùå No | ‚úÖ Yes (Sorted) | ‚ùå No |
| **Thread-Safe?** | ‚ùå No | ‚ùå No | ‚ùå No | ‚ùå No | ‚úÖ Yes | ‚úÖ Yes |
| **Performance** | ‚úÖ Fast | ‚úÖ Fast (Slightly Slower than `HashSet`) | üö´ Slower | ‚úÖ Fastest for Enums | üö´ Slower | üö´ Slowest (Creates Copy on Modification) |
| **Best Use Case** | **General Purpose (Fast)** | **Fast with Order** | **Sorted Data** | **Efficient Enum Handling** | **Thread-Safe Sorted Set** | **Thread-Safe Reads** |

---

## **üìå Conclusion**  
‚úÖ **Use `HashSet<T>` if order doesn‚Äôt matter & you want the fastest performance.**  
‚úÖ **Use `LinkedHashSet<T>` if you need insertion order.**  
‚úÖ **Use `TreeSet<T>` if you need sorting.**  
‚úÖ **Use `EnumSet<T>` if you work with Enums.**  
‚úÖ **Use `ConcurrentSkipListSet<T>` if you need thread-safe sorting.**  
‚úÖ **Use `CopyOnWriteArraySet<T>` for thread-safe read-heavy scenarios.**  

---
## **üìå All Methods of Set Interface in Java (Deep Dive)**  

### **1Ô∏è‚É£ Overview of Set<T> Methods**
The `Set<T>` interface in Java is part of the Java Collection Framework and extends the `Collection<T>` interface. Since it represents a unique collection of elements, it provides various methods to **add, remove, check, and manipulate elements efficiently**.  

These methods are **inherited from the Collection Interface** and implemented in classes like `HashSet<T>`, `LinkedHashSet<T>`, `TreeSet<T>`, etc.  

---

## **2Ô∏è‚É£ Methods of the Set Interface**
Here‚Äôs a deep dive into **all the important methods** of `Set<T>`, with examples:

### **üìç 1. `add(E e)` ‚Üí Adds an element**
‚úÖ **Adds an element to the set if it is not already present.**  
‚ùå **If the element already exists, it is ignored.**  
```java
Set<String> set = new HashSet<>();
set.add("Apple");
set.add("Banana");
set.add("Apple"); // Duplicate, won't be added

System.out.println(set); // Output: [Apple, Banana]
```

---

### **üìç 2. `addAll(Collection<? extends E> c)` ‚Üí Adds all elements from another collection**  
‚úÖ **Adds all elements from another collection to the current set.**  
‚ùå **Duplicate elements are ignored.**
```java
Set<Integer> set1 = new HashSet<>();
set1.add(1);
set1.add(2);

Set<Integer> set2 = new HashSet<>();
set2.add(2);
set2.add(3);

set1.addAll(set2); 
System.out.println(set1); // Output: [1, 2, 3]
```

---

### **üìç 3. `remove(Object o)` ‚Üí Removes an element**
‚úÖ **Removes a specific element from the set.**  
‚ùå **If the element is not found, nothing happens.**
```java
Set<String> set = new HashSet<>();
set.add("Car");
set.add("Bike");

set.remove("Bike"); 
System.out.println(set); // Output: [Car]
```

---

### **üìç 4. `removeAll(Collection<?> c)` ‚Üí Removes all elements in a given collection**
‚úÖ **Removes all elements from the set that exist in another collection.**
```java
Set<Integer> set = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
Set<Integer> removeSet = new HashSet<>(Arrays.asList(2, 4));

set.removeAll(removeSet);
System.out.println(set); // Output: [1, 3, 5]
```

---

### **üìç 5. `clear()` ‚Üí Removes all elements from the set**  
‚úÖ **Empties the set completely.**  
```java
Set<String> set = new HashSet<>(Arrays.asList("A", "B", "C"));
set.clear();

System.out.println(set); // Output: []
```

---

### **üìç 6. `contains(Object o)` ‚Üí Checks if an element exists**
‚úÖ **Returns `true` if the element is in the set, otherwise `false`.**  
```java
Set<String> set = new HashSet<>(Arrays.asList("Apple", "Orange"));
System.out.println(set.contains("Apple"));  // Output: true
System.out.println(set.contains("Banana")); // Output: false
```

---

### **üìç 7. `containsAll(Collection<?> c)` ‚Üí Checks if all elements in a collection exist**
‚úÖ **Returns `true` if the set contains all elements in the given collection.**
```java
Set<Integer> set = new HashSet<>(Arrays.asList(1, 2, 3, 4));
Set<Integer> subSet = new HashSet<>(Arrays.asList(2, 3));

System.out.println(set.containsAll(subSet));  // Output: true
```

---

### **üìç 8. `size()` ‚Üí Returns the number of elements in the set**
‚úÖ **Returns the total number of elements.**
```java
Set<String> set = new HashSet<>(Arrays.asList("A", "B", "C"));
System.out.println(set.size());  // Output: 3
```

---

### **üìç 9. `isEmpty()` ‚Üí Checks if the set is empty**
‚úÖ **Returns `true` if the set contains no elements.**
```java
Set<Integer> set = new HashSet<>();
System.out.println(set.isEmpty());  // Output: true
```

---

### **üìç 10. `retainAll(Collection<?> c)` ‚Üí Keeps only common elements (Intersection)**
‚úÖ **Removes elements that are NOT in the given collection (performs intersection).**
```java
Set<Integer> set = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
Set<Integer> commonSet = new HashSet<>(Arrays.asList(2, 4));

set.retainAll(commonSet);
System.out.println(set); // Output: [2, 4]
```

---

### **üìç 11. `iterator()` ‚Üí Returns an iterator to traverse the set**
‚úÖ **Useful for looping through the set elements.**
```java
Set<String> set = new HashSet<>(Arrays.asList("Red", "Blue", "Green"));
Iterator<String> itr = set.iterator();

while (itr.hasNext()) {
    System.out.println(itr.next());
}
```

---

### **üìç 12. `toArray()` ‚Üí Converts the set into an array**
‚úÖ **Returns an array containing all elements in the set.**
```java
Set<String> set = new HashSet<>(Arrays.asList("X", "Y", "Z"));
Object[] arr = set.toArray();

System.out.println(Arrays.toString(arr)); // Output: [X, Y, Z]
```

---

### **üìç 13. `toArray(T[] a)` ‚Üí Converts the set into a typed array**
‚úÖ **Returns an array of type `T` containing all elements.**
```java
Set<String> set = new HashSet<>(Arrays.asList("Java", "Python"));
String[] arr = set.toArray(new String[0]);

System.out.println(Arrays.toString(arr)); // Output: [Java, Python]
```

---

### **üìç 14. `equals(Object o)` ‚Üí Checks if two sets are equal**
‚úÖ **Returns `true` if the sets contain the same elements (order doesn't matter).**
```java
Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3));
Set<Integer> set2 = new HashSet<>(Arrays.asList(3, 2, 1));

System.out.println(set1.equals(set2)); // Output: true
```

---

### **üìç 15. `hashCode()` ‚Üí Returns the hash code of the set**
‚úÖ **Used for hashing-based storage.**
```java
Set<Integer> set = new HashSet<>(Arrays.asList(10, 20, 30));
System.out.println(set.hashCode()); // Example Output: 32015
```

---

## **3Ô∏è‚É£ Summary of All Methods**
| Method | Description |
|--------|------------|
| `add(E e)` | Adds an element if it's not already present. |
| `addAll(Collection<?> c)` | Adds all elements from another collection. |
| `remove(Object o)` | Removes the specified element. |
| `removeAll(Collection<?> c)` | Removes all elements present in another collection. |
| `clear()` | Removes all elements from the set. |
| `contains(Object o)` | Checks if an element exists in the set. |
| `containsAll(Collection<?> c)` | Checks if all elements of a collection exist. |
| `size()` | Returns the number of elements. |
| `isEmpty()` | Checks if the set is empty. |
| `retainAll(Collection<?> c)` | Keeps only common elements (Intersection). |
| `iterator()` | Returns an iterator to traverse elements. |
| `toArray()` | Converts the set into an object array. |
| `toArray(T[] a)` | Converts the set into a typed array. |
| `equals(Object o)` | Checks if two sets are equal. |
| `hashCode()` | Returns the hash code of the set. |

---

# **üìå Deep Dive into `HashSet<T>` in Java (Easy Explanation)**  

## **1Ô∏è‚É£ What is `HashSet<T>`?**
A `HashSet<T>` in Java is a class that implements the `Set<T>` interface and **stores unique elements in an unordered way** using **hashing** for fast retrieval.

‚úîÔ∏è **Stores only unique elements (No duplicates allowed).**  
‚úîÔ∏è **Uses `HashMap` internally for storage.**  
‚úîÔ∏è **Allows `null` values (only one).**  
‚úîÔ∏è **Unordered (No guarantee of insertion order).**  
‚úîÔ∏è **Fast operations (O(1) time complexity for add, remove, contains).**  

---

## **2Ô∏è‚É£ How `HashSet` Works Internally?**
### **üîπ Step 1: Uses `HashMap` for storage**
Internally, `HashSet<T>` uses a `HashMap<T, Object>` where:  
- Each element is stored as **a key** in the `HashMap`.  
- A dummy value (like `PRESENT`) is used as a value.  

```java
private static final Object PRESENT = new Object();
private transient HashMap<E,Object> map;
```

### **üîπ Step 2: Hashing Process**
1. When you **add** an element, it calculates the **hash code** of the element.
2. Finds a suitable **bucket (index)** in the Hash Table.
3. Stores the element **only if it does not already exist.**

### **üîπ Step 3: No Duplicate Elements**
Since `HashMap` does not allow duplicate keys, `HashSet` ensures **no duplicate elements**.

---

## **3Ô∏è‚É£ Creating a `HashSet` (Basic Example)**
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        HashSet<String> set = new HashSet<>();

        set.add("Apple");
        set.add("Banana");
        set.add("Mango");
        set.add("Apple"); // Duplicate, will not be added

        System.out.println(set); // Output: [Banana, Apple, Mango] (Unordered)
    }
}
```
- **Duplicates are ignored** (Only one "Apple" is stored).
- **Order is not maintained**.

---

## **4Ô∏è‚É£ Important Methods of `HashSet<T>`**
| Method | Description |
|--------|------------|
| `add(E e)` | Adds an element if it is not already present. |
| `remove(Object o)` | Removes the specified element from the set. |
| `contains(Object o)` | Returns `true` if the element exists. |
| `size()` | Returns the number of elements in the set. |
| `isEmpty()` | Checks if the set is empty. |
| `clear()` | Removes all elements from the set. |
| `iterator()` | Returns an iterator to traverse the set. |

---

## **5Ô∏è‚É£ Detailed Examples of `HashSet<T>` Methods**
### **üìç 1. `add(E e)` ‚Üí Adds an element**
```java
HashSet<Integer> numbers = new HashSet<>();
numbers.add(10);
numbers.add(20);
numbers.add(10); // Duplicate, ignored

System.out.println(numbers); // Output: [20, 10] (Unordered)
```

---

### **üìç 2. `remove(Object o)` ‚Üí Removes an element**
```java
HashSet<String> set = new HashSet<>(Arrays.asList("Java", "Python", "C++"));
set.remove("Python");

System.out.println(set); // Output: [Java, C++]
```

---

### **üìç 3. `contains(Object o)` ‚Üí Checks if an element exists**
```java
HashSet<Integer> numbers = new HashSet<>(Arrays.asList(1, 2, 3));
System.out.println(numbers.contains(2)); // Output: true
System.out.println(numbers.contains(5)); // Output: false
```

---

### **üìç 4. `size()` ‚Üí Returns the total number of elements**
```java
HashSet<String> set = new HashSet<>(Arrays.asList("Apple", "Banana"));
System.out.println(set.size()); // Output: 2
```

---

### **üìç 5. `isEmpty()` ‚Üí Checks if the set is empty**
```java
HashSet<Integer> set = new HashSet<>();
System.out.println(set.isEmpty()); // Output: true
```

---

### **üìç 6. `clear()` ‚Üí Removes all elements**
```java
HashSet<String> set = new HashSet<>(Arrays.asList("A", "B", "C"));
set.clear();

System.out.println(set); // Output: []
```

---

### **üìç 7. `iterator()` ‚Üí Traversing the set**
```java
HashSet<String> set = new HashSet<>(Arrays.asList("Red", "Blue", "Green"));
Iterator<String> itr = set.iterator();

while (itr.hasNext()) {
    System.out.println(itr.next());
}
```
---

## **6Ô∏è‚É£ Performance Analysis**
| Operation | Time Complexity |
|-----------|---------------|
| `add(E e)` | O(1) |
| `remove(Object o)` | O(1) |
| `contains(Object o)` | O(1) |
| `size()` | O(1) |
| `iterator()` | O(n) |

---

## **7Ô∏è‚É£ When to Use `HashSet<T>`?**
| Use `HashSet` When... | Avoid `HashSet` When... |
|------------------|------------------|
| You need **fast lookups**. | You need **ordered elements** (Use `LinkedHashSet`). |
| You don‚Äôt care about insertion order. | You need **sorted elements** (Use `TreeSet`). |
| You want to store unique elements. | You need **index-based access** (Use `ArrayList`). |

---

## **8Ô∏è‚É£ Summary**
‚úîÔ∏è **HashSet is a Set implementation that uses hashing to store unique elements.**  
‚úîÔ∏è **Elements are stored in an unordered manner.**  
‚úîÔ∏è **Uses `HashMap` internally for storage.**  
‚úîÔ∏è **Fast operations: O(1) for adding, removing, and searching elements.**  
‚úîÔ∏è **Best choice when you need unique elements and fast access.**

---

# **üìå Deep Dive into `LinkedHashSet<T>` in Java (Easy Explanation)**  

## **1Ô∏è‚É£ What is `LinkedHashSet<T>`?**
A `LinkedHashSet<T>` is a class in Java that implements the `Set<T>` interface and **maintains the insertion order** while ensuring **unique elements**.  

‚úîÔ∏è **Stores only unique elements (No duplicates allowed).**  
‚úîÔ∏è **Maintains insertion order (Unlike `HashSet`).**  
‚úîÔ∏è **Uses a combination of `HashSet` and `LinkedList`.**  
‚úîÔ∏è **Allows `null` values (only one).**  
‚úîÔ∏è **Faster than `TreeSet`, but slightly slower than `HashSet`.**  

---

## **2Ô∏è‚É£ How `LinkedHashSet<T>` Works Internally?**
### **üîπ Step 1: Uses `LinkedHashMap` for storage**
Internally, `LinkedHashSet<T>` uses a **`LinkedHashMap<T, Object>`** where:  
- Each element is stored as **a key** in the `LinkedHashMap`.  
- A dummy value (like `PRESENT`) is used as a value.  

```java
private static final Object PRESENT = new Object();
private transient LinkedHashMap<E,Object> map;
```

### **üîπ Step 2: Maintains Insertion Order**
- Unlike `HashSet`, `LinkedHashSet` **preserves the order in which elements are added**.  
- This happens because `LinkedHashMap` maintains a **doubly linked list** of its entries.  

---

## **3Ô∏è‚É£ Creating a `LinkedHashSet` (Basic Example)**
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        LinkedHashSet<String> set = new LinkedHashSet<>();

        set.add("Apple");
        set.add("Banana");
        set.add("Mango");
        set.add("Apple"); // Duplicate, will not be added

        System.out.println(set); // Output: [Apple, Banana, Mango] (Maintains order)
    }
}
```
‚úîÔ∏è **Order is maintained as elements were inserted (`Apple ‚Üí Banana ‚Üí Mango`).**  
‚úîÔ∏è **Duplicates are ignored.**  

---

## **4Ô∏è‚É£ Important Methods of `LinkedHashSet<T>`**
| Method | Description |
|--------|------------|
| `add(E e)` | Adds an element if it is not already present. |
| `remove(Object o)` | Removes the specified element from the set. |
| `contains(Object o)` | Returns `true` if the element exists. |
| `size()` | Returns the number of elements in the set. |
| `isEmpty()` | Checks if the set is empty. |
| `clear()` | Removes all elements from the set. |
| `iterator()` | Returns an iterator to traverse the set. |

---

## **5Ô∏è‚É£ Detailed Examples of `LinkedHashSet<T>` Methods**
### **üìç 1. `add(E e)` ‚Üí Adds an element**
```java
LinkedHashSet<Integer> numbers = new LinkedHashSet<>();
numbers.add(10);
numbers.add(20);
numbers.add(10); // Duplicate, ignored

System.out.println(numbers); // Output: [10, 20] (Maintains order)
```

---

### **üìç 2. `remove(Object o)` ‚Üí Removes an element**
```java
LinkedHashSet<String> set = new LinkedHashSet<>(Arrays.asList("Java", "Python", "C++"));
set.remove("Python");

System.out.println(set); // Output: [Java, C++]
```

---

### **üìç 3. `contains(Object o)` ‚Üí Checks if an element exists**
```java
LinkedHashSet<Integer> numbers = new LinkedHashSet<>(Arrays.asList(1, 2, 3));
System.out.println(numbers.contains(2)); // Output: true
System.out.println(numbers.contains(5)); // Output: false
```

---

### **üìç 4. `size()` ‚Üí Returns the total number of elements**
```java
LinkedHashSet<String> set = new LinkedHashSet<>(Arrays.asList("Apple", "Banana"));
System.out.println(set.size()); // Output: 2
```

---

### **üìç 5. `isEmpty()` ‚Üí Checks if the set is empty**
```java
LinkedHashSet<Integer> set = new LinkedHashSet<>();
System.out.println(set.isEmpty()); // Output: true
```

---

### **üìç 6. `clear()` ‚Üí Removes all elements**
```java
LinkedHashSet<String> set = new LinkedHashSet<>(Arrays.asList("A", "B", "C"));
set.clear();

System.out.println(set); // Output: []
```

---

### **üìç 7. `iterator()` ‚Üí Traversing the set**
```java
LinkedHashSet<String> set = new LinkedHashSet<>(Arrays.asList("Red", "Blue", "Green"));
Iterator<String> itr = set.iterator();

while (itr.hasNext()) {
    System.out.println(itr.next());
}
```
---

## **6Ô∏è‚É£ Performance Analysis**
| Operation | Time Complexity |
|-----------|---------------|
| `add(E e)` | O(1) |
| `remove(Object o)` | O(1) |
| `contains(Object o)` | O(1) |
| `size()` | O(1) |
| `iterator()` | O(n) |

---

## **7Ô∏è‚É£ When to Use `LinkedHashSet<T>`?**
| Use `LinkedHashSet` When... | Avoid `LinkedHashSet` When... |
|------------------|------------------|
| You need **fast lookups** with **insertion order maintained**. | You need **sorted elements** (Use `TreeSet`). |
| You want a **unique collection that preserves order**. | You need **index-based access** (Use `ArrayList`). |
| You need moderate performance with predictable order. | You need **higher performance** (Use `HashSet`). |

---

## **8Ô∏è‚É£ Summary**
‚úîÔ∏è **LinkedHashSet is a Set implementation that maintains insertion order.**  
‚úîÔ∏è **Uses `LinkedHashMap` internally to store unique elements.**  
‚úîÔ∏è **Allows fast lookups, insertions, and deletions (O(1) time complexity).**  
‚úîÔ∏è **Best choice when you need unique elements with predictable order.**

---

# **üìå Deep Dive into `TreeSet<T>` in Java (Easy Explanation)**  

## **1Ô∏è‚É£ What is `TreeSet<T>`?**
A `TreeSet<T>` in Java is a class that implements the `NavigableSet<T>` interface and maintains **sorted unique elements**.  

‚úîÔ∏è **Stores only unique elements (No duplicates allowed).**  
‚úîÔ∏è **Maintains elements in sorted (ascending) order.**  
‚úîÔ∏è **Implements `NavigableSet<T>`, which extends `SortedSet<T>`.**  
‚úîÔ∏è **Uses a self-balancing Red-Black Tree for storage.**  
‚úîÔ∏è **Faster than `LinkedList`, but slower than `HashSet`.**  

---

## **2Ô∏è‚É£ How `TreeSet<T>` Works Internally?**
### **üîπ Step 1: Uses a Red-Black Tree**
A **Red-Black Tree** is a type of **self-balancing binary search tree (BST)**.  
Whenever a new element is added:  
- It is first inserted in BST order.  
- If the tree becomes unbalanced, rotations and color changes occur to maintain balance.  
- The height of the tree is maintained as **O(log n)**, ensuring efficient operations.  

### **üîπ Step 2: Maintains Sorted Order**
`TreeSet<T>` sorts elements **automatically in natural order** (`Comparable`) or based on a custom comparator (`Comparator`).  

### **üîπ Step 3: No Duplicates Allowed**
Duplicate elements are ignored while maintaining order.  

---

## **3Ô∏è‚É£ Creating a `TreeSet` (Basic Example)**
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        TreeSet<Integer> numbers = new TreeSet<>();

        numbers.add(50);
        numbers.add(20);
        numbers.add(10);
        numbers.add(40);
        numbers.add(30);
        numbers.add(10); // Duplicate, ignored

        System.out.println(numbers); // Output: [10, 20, 30, 40, 50] (Sorted)
    }
}
```
‚úîÔ∏è **Sorted Order (`10 ‚Üí 20 ‚Üí 30 ‚Üí 40 ‚Üí 50`)**  
‚úîÔ∏è **Duplicates are ignored.**  

---

## **4Ô∏è‚É£ Important Methods of `TreeSet<T>`**
| Method | Description |
|--------|------------|
| `add(E e)` | Adds an element if it is not already present (sorted). |
| `remove(Object o)` | Removes the specified element from the set. |
| `contains(Object o)` | Returns `true` if the element exists. |
| `size()` | Returns the number of elements in the set. |
| `isEmpty()` | Checks if the set is empty. |
| `clear()` | Removes all elements from the set. |
| `iterator()` | Returns an iterator to traverse the set. |
| `first()` | Returns the smallest (first) element. |
| `last()` | Returns the largest (last) element. |
| `higher(E e)` | Returns the smallest element greater than `e`. |
| `lower(E e)` | Returns the largest element smaller than `e`. |
| `ceiling(E e)` | Returns the smallest element greater than or equal to `e`. |
| `floor(E e)` | Returns the largest element smaller than or equal to `e`. |
| `pollFirst()` | Removes and returns the first element. |
| `pollLast()` | Removes and returns the last element. |

---

## **5Ô∏è‚É£ Detailed Examples of `TreeSet<T>` Methods**
### **üìç 1. `add(E e)` ‚Üí Adds an element**
```java
TreeSet<String> set = new TreeSet<>();
set.add("Banana");
set.add("Apple");
set.add("Mango");

System.out.println(set); // Output: [Apple, Banana, Mango] (Sorted order)
```

---

### **üìç 2. `remove(Object o)` ‚Üí Removes an element**
```java
TreeSet<Integer> numbers = new TreeSet<>(Arrays.asList(10, 20, 30, 40));
numbers.remove(20);

System.out.println(numbers); // Output: [10, 30, 40]
```

---

### **üìç 3. `contains(Object o)` ‚Üí Checks if an element exists**
```java
TreeSet<Integer> numbers = new TreeSet<>(Arrays.asList(5, 10, 15));
System.out.println(numbers.contains(10)); // Output: true
System.out.println(numbers.contains(25)); // Output: false
```

---

### **üìç 4. `first()` and `last()` ‚Üí Get first and last elements**
```java
TreeSet<Integer> numbers = new TreeSet<>(Arrays.asList(100, 50, 75, 25));
System.out.println(numbers.first()); // Output: 25 (Smallest)
System.out.println(numbers.last());  // Output: 100 (Largest)
```

---

### **üìç 5. `higher(E e)` and `lower(E e)` ‚Üí Get next and previous elements**
```java
TreeSet<Integer> numbers = new TreeSet<>(Arrays.asList(10, 20, 30, 40));
System.out.println(numbers.higher(20)); // Output: 30 (Next higher)
System.out.println(numbers.lower(20));  // Output: 10 (Previous lower)
```

---

### **üìç 6. `ceiling(E e)` and `floor(E e)` ‚Üí Get equal or closest values**
```java
TreeSet<Integer> numbers = new TreeSet<>(Arrays.asList(10, 20, 30, 40));
System.out.println(numbers.ceiling(25)); // Output: 30 (Next greater or equal)
System.out.println(numbers.floor(25));   // Output: 20 (Next smaller or equal)
```

---

### **üìç 7. `pollFirst()` and `pollLast()` ‚Üí Remove first and last elements**
```java
TreeSet<Integer> numbers = new TreeSet<>(Arrays.asList(5, 10, 15, 20));
System.out.println(numbers.pollFirst()); // Output: 5 (Removes first)
System.out.println(numbers.pollLast());  // Output: 20 (Removes last)
```

---

### **üìç 8. Custom Sorting with `Comparator`**
```java
TreeSet<String> set = new TreeSet<>(Comparator.reverseOrder());
set.add("Banana");
set.add("Apple");
set.add("Mango");

System.out.println(set); // Output: [Mango, Banana, Apple] (Reverse Order)
```

---

## **6Ô∏è‚É£ Performance Analysis**
| Operation | Time Complexity |
|-----------|---------------|
| `add(E e)` | O(log n) |
| `remove(Object o)` | O(log n) |
| `contains(Object o)` | O(log n) |
| `size()` | O(1) |
| `iterator()` | O(n) |

---

## **7Ô∏è‚É£ When to Use `TreeSet<T>`?**
| Use `TreeSet` When... | Avoid `TreeSet` When... |
|------------------|------------------|
| You need elements to be **sorted automatically**. | You need **unordered but fast access** (Use `HashSet`). |
| You want **logarithmic time complexity** (`O(log n)`). | You need **constant time lookups** (`O(1)`, Use `HashSet`). |
| You need efficient **range queries** (`higher(), lower()`). | You need **insertion order to be maintained** (Use `LinkedHashSet`). |

---

## **8Ô∏è‚É£ Summary**
‚úîÔ∏è **TreeSet is a Set implementation that maintains sorted order.**  
‚úîÔ∏è **Uses a self-balancing Red-Black Tree for internal storage.**  
‚úîÔ∏è **Offers `O(log n)` time complexity for insert, delete, and search.**  
‚úîÔ∏è **Best for scenarios where sorted order is required.**

---

# **üìå Deep Dive into `EnumSet<T>` in Java (Easy Explanation)**  

## **1Ô∏è‚É£ What is `EnumSet<T>`?**  
`EnumSet<T>` is a specialized **Set implementation for Enums** in Java. It is designed to work **only with Enums** and is much **faster and memory-efficient** than other Set implementations like `HashSet` or `TreeSet`.  

‚úîÔ∏è **Stores only `enum` values.**  
‚úîÔ∏è **Extremely fast (Better than `HashSet` and `TreeSet`).**  
‚úîÔ∏è **Compact memory usage (Uses bitwise operations).**  
‚úîÔ∏è **Maintains natural order of Enums.**  

---

## **2Ô∏è‚É£ How `EnumSet<T>` Works Internally?**
- Unlike `HashSet`, which uses a **HashMap**, `EnumSet` uses a **bitwise representation** to store elements.  
- Each `enum` constant is assigned a **bit position**, making operations **very fast (`O(1)`)**.  
- Since `EnumSet` is backed by a **bit vector**, it **does not allow null values**.  
- It maintains **insertion order** based on how `enum` constants are declared.  

---

## **3Ô∏è‚É£ Creating an `EnumSet` (Basic Example)**
Let's define an `enum` first:  
```java
enum Days {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
}
```
Now, let's create an `EnumSet` and add elements:  
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        EnumSet<Days> weekend = EnumSet.of(Days.SATURDAY, Days.SUNDAY);
        System.out.println(weekend); // Output: [SATURDAY, SUNDAY]
    }
}
```
‚úîÔ∏è **Stores only `enum` values**  
‚úîÔ∏è **Maintains insertion order**  

---

## **4Ô∏è‚É£ Ways to Create an `EnumSet<T>`**
### **üìç 1. `EnumSet.of(E... elements)` ‚Üí Create from specific values**
```java
EnumSet<Days> set = EnumSet.of(Days.MONDAY, Days.WEDNESDAY);
System.out.println(set); // Output: [MONDAY, WEDNESDAY]
```

### **üìç 2. `EnumSet.allOf(EnumType.class)` ‚Üí Create a set of all Enum values**
```java
EnumSet<Days> allDays = EnumSet.allOf(Days.class);
System.out.println(allDays); // Output: [MONDAY, TUESDAY, WEDNESDAY, ...]
```

### **üìç 3. `EnumSet.noneOf(EnumType.class)` ‚Üí Create an empty set**
```java
EnumSet<Days> emptySet = EnumSet.noneOf(Days.class);
System.out.println(emptySet); // Output: []
```

### **üìç 4. `EnumSet.range(E from, E to)` ‚Üí Create a range of Enum values**
```java
EnumSet<Days> midWeek = EnumSet.range(Days.TUESDAY, Days.THURSDAY);
System.out.println(midWeek); // Output: [TUESDAY, WEDNESDAY, THURSDAY]
```

### **üìç 5. `EnumSet.copyOf(Collection<E> c)` ‚Üí Create from another collection**
```java
List<Days> list = Arrays.asList(Days.MONDAY, Days.FRIDAY);
EnumSet<Days> copiedSet = EnumSet.copyOf(list);
System.out.println(copiedSet); // Output: [MONDAY, FRIDAY]
```

---

## **5Ô∏è‚É£ Important Methods of `EnumSet<T>`**
| Method | Description |
|--------|------------|
| `add(E e)` | Adds an element to the set. |
| `remove(E e)` | Removes an element from the set. |
| `contains(E e)` | Checks if the set contains an element. |
| `size()` | Returns the number of elements in the set. |
| `isEmpty()` | Checks if the set is empty. |
| `clear()` | Removes all elements from the set. |
| `iterator()` | Returns an iterator to traverse the set. |
| `complementOf(EnumSet<E> s)` | Returns a set containing all elements **except** those in `s`. |

---

## **6Ô∏è‚É£ Examples of `EnumSet<T>` Methods**
### **üìç 1. `add(E e)` and `remove(E e)` ‚Üí Add & Remove Elements**
```java
EnumSet<Days> set = EnumSet.noneOf(Days.class);
set.add(Days.MONDAY);
set.add(Days.FRIDAY);
set.remove(Days.MONDAY);

System.out.println(set); // Output: [FRIDAY]
```

---

### **üìç 2. `contains(E e)` ‚Üí Check if an element exists**
```java
EnumSet<Days> set = EnumSet.of(Days.WEDNESDAY, Days.FRIDAY);
System.out.println(set.contains(Days.FRIDAY)); // Output: true
System.out.println(set.contains(Days.SUNDAY)); // Output: false
```

---

### **üìç 3. `complementOf(EnumSet<E> s)` ‚Üí Get the complement set**
```java
EnumSet<Days> workingDays = EnumSet.range(Days.MONDAY, Days.FRIDAY);
EnumSet<Days> nonWorkingDays = EnumSet.complementOf(workingDays);

System.out.println(workingDays);  // Output: [MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY]
System.out.println(nonWorkingDays); // Output: [SATURDAY, SUNDAY]
```

---

## **7Ô∏è‚É£ Performance Analysis**
| Operation | Time Complexity |
|-----------|---------------|
| `add(E e)` | O(1) |
| `remove(E e)` | O(1) |
| `contains(E e)` | O(1) |
| `size()` | O(1) |
| `iterator()` | O(n) |

‚úîÔ∏è **Extremely fast because it uses bitwise operations.**  

---

## **8Ô∏è‚É£ When to Use `EnumSet<T>`?**
| Use `EnumSet` When... | Avoid `EnumSet` When... |
|------------------|------------------|
| You have **enum values** to store. | You need to store **non-enum values**. |
| You need a **faster and memory-efficient** Set. | You need to store **null values** (`EnumSet` does not allow `null`). |
| You want **ordered enum storage**. | You need a **hashed or sorted collection** (Use `HashSet` or `TreeSet`). |

---

## **9Ô∏è‚É£ Summary**
‚úîÔ∏è **EnumSet is the best choice for storing Enums in a Set.**  
‚úîÔ∏è **Much faster and memory-efficient than `HashSet` and `TreeSet`.**  
‚úîÔ∏è **Uses bitwise operations for fast access.**  
‚úîÔ∏è **Maintains natural order of Enum constants.**  
‚úîÔ∏è **Does not allow `null` values.**  

---

# **üìå Deep Dive into `ConcurrentSkipListSet<T>` in Java (Easy Explanation)**  

## **1Ô∏è‚É£ What is `ConcurrentSkipListSet<T>`?**  
`ConcurrentSkipListSet<T>` is a **thread-safe, sorted Set implementation** in Java.  
It is part of the **java.util.concurrent** package and is designed for **concurrent (multi-threaded) environments**.  

‚úîÔ∏è **Thread-Safe** (Multiple threads can modify it safely).  
‚úîÔ∏è **Sorted Set** (Maintains natural order of elements).  
‚úîÔ∏è **Non-Synchronized Alternative to `TreeSet`**.  
‚úîÔ∏è **Uses a Skip List (Efficient for concurrent reads/writes).**  
‚úîÔ∏è **Does not allow `null` elements.**  

---

## **2Ô∏è‚É£ How `ConcurrentSkipListSet<T>` Works Internally?**  
- It uses a **Skip List** instead of a Tree or Hash structure.  
- A Skip List is like a **linked list with multiple levels** to speed up searches.  
- It provides **logarithmic time complexity (`O(log n)`) for add, remove, and search** operations.  
- Unlike `TreeSet`, which uses **synchronized locks**, `ConcurrentSkipListSet` allows **lock-free concurrent access**, making it much faster in multi-threaded scenarios.  

üîπ **Comparison with Other Sets**  

| Feature | `ConcurrentSkipListSet` | `TreeSet` | `HashSet` |
|---------|-----------------|---------|---------|
| Thread-Safe? | ‚úÖ Yes | ‚ùå No | ‚ùå No |
| Sorted? | ‚úÖ Yes (Natural Order) | ‚úÖ Yes (Natural Order) | ‚ùå No |
| Performance (Insert/Search) | ‚ö° `O(log n)` | ‚ö° `O(log n)` | üî• `O(1)` |
| Allows `null`? | ‚ùå No | ‚ùå No | ‚úÖ Yes |

---

## **3Ô∏è‚É£ Creating a `ConcurrentSkipListSet<T>` (Basic Example)**  
Let's create a `ConcurrentSkipListSet` and add elements to it:  
```java
import java.util.concurrent.*;

public class Main {
    public static void main(String[] args) {
        ConcurrentSkipListSet<Integer> set = new ConcurrentSkipListSet<>();

        set.add(10);
        set.add(5);
        set.add(20);
        set.add(15);

        System.out.println(set); // Output: [5, 10, 15, 20] (Sorted Order)
    }
}
```
‚úîÔ∏è **Elements are always sorted in natural order**.  
‚úîÔ∏è **Thread-Safe operations without explicit locking**.  

---

## **4Ô∏è‚É£ Important Methods of `ConcurrentSkipListSet<T>`**
| Method | Description |
|--------|------------|
| `add(E e)` | Adds an element to the set. |
| `remove(E e)` | Removes an element from the set. |
| `contains(E e)` | Checks if the set contains an element. |
| `size()` | Returns the number of elements in the set. |
| `isEmpty()` | Checks if the set is empty. |
| `pollFirst()` | Retrieves and removes the **smallest** element. |
| `pollLast()` | Retrieves and removes the **largest** element. |
| `headSet(E toElement)` | Returns elements **less than** `toElement`. |
| `tailSet(E fromElement)` | Returns elements **greater than or equal to** `fromElement`. |
| `subSet(E fromElement, E toElement)` | Returns a range of elements. |

---

## **5Ô∏è‚É£ Examples of `ConcurrentSkipListSet<T>` Methods**
### **üìç 1. `add(E e)`, `remove(E e)`, and `contains(E e)`**
```java
ConcurrentSkipListSet<Integer> set = new ConcurrentSkipListSet<>();
set.add(10);
set.add(5);
set.add(20);
set.remove(10);

System.out.println(set.contains(10)); // Output: false
System.out.println(set); // Output: [5, 20]
```
‚úîÔ∏è **`add()` inserts elements in sorted order.**  
‚úîÔ∏è **`remove()` deletes elements safely in multi-threaded environments.**  
‚úîÔ∏è **`contains()` checks if an element exists.**  

---

### **üìç 2. `pollFirst()` and `pollLast()` ‚Üí Retrieve & Remove First/Last Element**
```java
ConcurrentSkipListSet<Integer> set = new ConcurrentSkipListSet<>();
set.add(10);
set.add(5);
set.add(20);

System.out.println(set.pollFirst()); // Output: 5 (Removes Smallest Element)
System.out.println(set.pollLast());  // Output: 20 (Removes Largest Element)
System.out.println(set); // Output: [10]
```

---

### **üìç 3. `headSet(E toElement)` ‚Üí Get elements less than a value**
```java
ConcurrentSkipListSet<Integer> set = new ConcurrentSkipListSet<>();
set.add(10);
set.add(5);
set.add(20);
set.add(15);

System.out.println(set.headSet(15)); // Output: [5, 10]
```
‚úîÔ∏è **Returns all elements smaller than `15`**  

---

### **üìç 4. `tailSet(E fromElement)` ‚Üí Get elements greater than or equal to a value**
```java
ConcurrentSkipListSet<Integer> set = new ConcurrentSkipListSet<>();
set.add(10);
set.add(5);
set.add(20);
set.add(15);

System.out.println(set.tailSet(15)); // Output: [15, 20]
```
‚úîÔ∏è **Returns all elements `>= 15`**  

---

### **üìç 5. `subSet(E fromElement, E toElement)` ‚Üí Get a range of elements**
```java
ConcurrentSkipListSet<Integer> set = new ConcurrentSkipListSet<>();
set.add(10);
set.add(5);
set.add(20);
set.add(15);

System.out.println(set.subSet(10, 20)); // Output: [10, 15]
```
‚úîÔ∏è **Returns elements in the range `[10, 20)` (exclusive of 20)**  

---

## **6Ô∏è‚É£ Performance Analysis**
| Operation | Time Complexity |
|-----------|---------------|
| `add(E e)` | `O(log n)` |
| `remove(E e)` | `O(log n)` |
| `contains(E e)` | `O(log n)` |
| `pollFirst() / pollLast()` | `O(log n)` |
| `headSet(E e) / tailSet(E e) / subSet(E e, E e)` | `O(log n)` |

‚úîÔ∏è **Faster than `TreeSet` in concurrent scenarios.**  
‚úîÔ∏è **Performs better in multi-threaded applications.**  

---

## **7Ô∏è‚É£ When to Use `ConcurrentSkipListSet<T>`?**
| Use `ConcurrentSkipListSet` When... | Avoid `ConcurrentSkipListSet` When... |
|--------------------------|--------------------------|
| You need a **thread-safe sorted Set**. | You don't need sorting (Use `ConcurrentHashMap`). |
| You need **fast concurrent reads & writes**. | You need **faster writes** (`HashSet` is faster for single-threaded use). |
| You need **logarithmic time complexity (`O(log n)`)**. | You need constant-time lookups (`HashSet` provides `O(1)`). |

---

## **8Ô∏è‚É£ Summary**
‚úîÔ∏è **Thread-Safe alternative to `TreeSet`**.  
‚úîÔ∏è **Faster concurrent operations than `TreeSet`**.  
‚úîÔ∏è **Uses Skip List for `O(log n)` operations**.  
‚úîÔ∏è **Maintains elements in sorted order**.  
‚úîÔ∏è **Does not allow `null` values**.  

---

Yes! Before moving to `CopyOnWriteArraySet<T>`, let's first understand **SortedSet<T>** in deep detail.  

---

# **üìå Deep Dive into `SortedSet<T>` in Java (Easy Explanation)**  

## **1Ô∏è‚É£ What is `SortedSet<T>`?**  
A **`SortedSet<T>`** is a specialized version of the `Set<T>` interface that **maintains elements in a sorted order**.  
It is part of the **`java.util` package** and is implemented by `TreeSet<T>`.  

‚úîÔ∏è **No Duplicate Elements** (Like `Set<T>`)  
‚úîÔ∏è **Maintains Sorted Order** (Ascending order by default)  
‚úîÔ∏è **Supports Range Queries** (`headSet()`, `tailSet()`, `subSet()`)  
‚úîÔ∏è **Implements `NavigableSet<T>`** (which extends `SortedSet<T>` for more flexibility)  

---

## **2Ô∏è‚É£ How `SortedSet<T>` Works Internally?**  
- It **extends `Set<T>`** and enforces a **sorting order**.  
- It can use **natural ordering (Comparable)** or **custom ordering (Comparator)**.  
- The most common implementation is **`TreeSet<T>`**, which is based on a **Red-Black Tree**.  
- The **sorting mechanism is automatic**, meaning elements are always stored in sorted order.  

---

## **3Ô∏è‚É£ Declaring a `SortedSet<T>` in Java**  
Since `SortedSet<T>` is an interface, we use `TreeSet<T>` as an implementation.  

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        SortedSet<Integer> sortedSet = new TreeSet<>();

        sortedSet.add(30);
        sortedSet.add(10);
        sortedSet.add(20);
        sortedSet.add(50);
        sortedSet.add(40);

        System.out.println(sortedSet); // Output: [10, 20, 30, 40, 50] (Sorted Order)
    }
}
```
‚úîÔ∏è **Automatically maintains sorted order**.  
‚úîÔ∏è **Duplicates are not allowed**.  

---

## **4Ô∏è‚É£ Important Methods of `SortedSet<T>`**
| Method | Description |
|--------|------------|
| `first()` | Returns the first (smallest) element. |
| `last()` | Returns the last (largest) element. |
| `headSet(E toElement)` | Returns elements **less than** `toElement`. |
| `tailSet(E fromElement)` | Returns elements **greater than or equal to** `fromElement`. |
| `subSet(E fromElement, E toElement)` | Returns elements within the range `[fromElement, toElement)`. |
| `comparator()` | Returns the comparator used for ordering (or `null` for natural ordering). |

---

## **5Ô∏è‚É£ Examples of `SortedSet<T>` Methods**
### **üìç 1. `first()` and `last()` ‚Üí Get First and Last Element**
```java
SortedSet<Integer> set = new TreeSet<>();
set.add(10);
set.add(30);
set.add(20);
set.add(50);
set.add(40);

System.out.println(set.first()); // Output: 10
System.out.println(set.last());  // Output: 50
```
‚úîÔ∏è **Retrieves the smallest and largest elements.**  

---

### **üìç 2. `headSet(E toElement)` ‚Üí Get Elements Less Than a Value**
```java
SortedSet<Integer> set = new TreeSet<>();
set.add(10);
set.add(20);
set.add(30);
set.add(40);
set.add(50);

System.out.println(set.headSet(30)); // Output: [10, 20]
```
‚úîÔ∏è **Returns elements smaller than `30`**.  

---

### **üìç 3. `tailSet(E fromElement)` ‚Üí Get Elements Greater Than or Equal to a Value**
```java
SortedSet<Integer> set = new TreeSet<>();
set.add(10);
set.add(20);
set.add(30);
set.add(40);
set.add(50);

System.out.println(set.tailSet(30)); // Output: [30, 40, 50]
```
‚úîÔ∏è **Returns elements `>= 30`**.  

---

### **üìç 4. `subSet(E fromElement, E toElement)` ‚Üí Get a Range of Elements**
```java
SortedSet<Integer> set = new TreeSet<>();
set.add(10);
set.add(20);
set.add(30);
set.add(40);
set.add(50);

System.out.println(set.subSet(20, 40)); // Output: [20, 30]
```
‚úîÔ∏è **Returns elements in the range `[20, 40)` (exclusive of 40)**.  

---

### **üìç 5. `comparator()` ‚Üí Get the Sorting Comparator**
```java
SortedSet<Integer> set = new TreeSet<>();
System.out.println(set.comparator()); // Output: null (Natural Ordering)
```
‚úîÔ∏è **Returns `null` if elements are sorted naturally**.  

---

## **6Ô∏è‚É£ Performance Analysis**
| Operation | Time Complexity |
|-----------|---------------|
| `add(E e)` | `O(log n)` |
| `remove(E e)` | `O(log n)` |
| `contains(E e)` | `O(log n)` |
| `first() / last()` | `O(1)` |
| `headSet(E e) / tailSet(E e) / subSet(E e, E e)` | `O(log n)` |

‚úîÔ∏è **Uses a Red-Black Tree for efficient sorting**.  
‚úîÔ∏è **Faster than `LinkedList` but slower than `HashSet` for insertions/removals**.  

---

## **7Ô∏è‚É£ When to Use `SortedSet<T>`?**
| Use `SortedSet` When... | Avoid `SortedSet` When... |
|------------------------|--------------------------|
| You need **automatically sorted elements**. | You don't care about ordering (Use `HashSet`). |
| You need **range queries** (`headSet()`, `tailSet()`, etc.). | You need **fast lookups (`O(1)`)** (Use `HashSet`). |
| You need **logarithmic time complexity (`O(log n)`)**. | You need **constant-time inserts/deletes (`O(1)`)**. |

---

## **8Ô∏è‚É£ Summary**
‚úîÔ∏è **`SortedSet<T>` maintains sorted order**.  
‚úîÔ∏è **Implemented using `TreeSet<T>` (Red-Black Tree)**.  
‚úîÔ∏è **Supports range queries like `headSet()`, `tailSet()`, `subSet()`**.  
‚úîÔ∏è **Does not allow duplicate elements**.  
‚úîÔ∏è **Faster than `LinkedList`, but slower than `HashSet`**.  

---

# **üìå Deep Dive into `CopyOnWriteArraySet<T>` in Java (Easy Explanation)**  

## **1Ô∏è‚É£ What is `CopyOnWriteArraySet<T>`?**  
A **`CopyOnWriteArraySet<T>`** is a thread-safe implementation of the `Set<T>` interface. It is part of the **`java.util.concurrent`** package and is designed for **concurrent environments** where reads are frequent but writes (modifications) are rare.

‚úîÔ∏è **Thread-Safe** (No need for manual synchronization)  
‚úîÔ∏è **No Duplicate Elements** (Like `Set<T>`)  
‚úîÔ∏è **Based on `CopyOnWriteArrayList<T>`** (Internally uses an array)  
‚úîÔ∏è **Best for Scenarios with Frequent Reads and Rare Writes**  

---

## **2Ô∏è‚É£ How `CopyOnWriteArraySet<T>` Works Internally?**  
- It is backed by a **`CopyOnWriteArrayList<T>`**.  
- Every time a **modification (add/remove) occurs**, it creates a **new copy of the underlying array**.  
- **Iterators are fail-safe**, meaning they do not throw `ConcurrentModificationException`.  
- **Best suited for scenarios where reading happens more frequently than writing**.  

---

## **3Ô∏è‚É£ Declaring a `CopyOnWriteArraySet<T>` in Java**  
Since `CopyOnWriteArraySet<T>` is a concrete class, we can instantiate it directly.

```java
import java.util.concurrent.CopyOnWriteArraySet;

public class Main {
    public static void main(String[] args) {
        CopyOnWriteArraySet<Integer> set = new CopyOnWriteArraySet<>();

        set.add(10);
        set.add(20);
        set.add(30);
        set.add(10); // Duplicate, will not be added

        System.out.println(set); // Output: [10, 20, 30]
    }
}
```
‚úîÔ∏è **Automatically avoids duplicates**.  
‚úîÔ∏è **Thread-safe without explicit locks**.  

---

## **4Ô∏è‚É£ Important Methods of `CopyOnWriteArraySet<T>`**
| Method | Description |
|--------|------------|
| `add(E e)` | Adds an element to the set (if not already present). |
| `remove(E e)` | Removes the element from the set. |
| `contains(E e)` | Checks if an element is present in the set. |
| `size()` | Returns the number of elements in the set. |
| `iterator()` | Returns a fail-safe iterator. |
| `toArray()` | Converts the set into an array. |

---

## **5Ô∏è‚É£ Examples of `CopyOnWriteArraySet<T>` Methods**
### **üìç 1. `add()` and `remove()` ‚Üí Add and Remove Elements**
```java
import java.util.concurrent.CopyOnWriteArraySet;

public class Main {
    public static void main(String[] args) {
        CopyOnWriteArraySet<String> set = new CopyOnWriteArraySet<>();

        set.add("Apple");
        set.add("Banana");
        set.add("Cherry");

        System.out.println(set); // Output: [Apple, Banana, Cherry]

        set.remove("Banana");
        System.out.println(set); // Output: [Apple, Cherry]
    }
}
```
‚úîÔ∏è **Handles duplicates and thread safety automatically**.  

---

### **üìç 2. `contains()` ‚Üí Check If an Element Exists**
```java
CopyOnWriteArraySet<Integer> set = new CopyOnWriteArraySet<>();
set.add(100);
set.add(200);
set.add(300);

System.out.println(set.contains(200)); // Output: true
System.out.println(set.contains(400)); // Output: false
```
‚úîÔ∏è **Efficiently checks for element presence**.  

---

### **üìç 3. `iterator()` ‚Üí Fail-Safe Iterator**
```java
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.Iterator;

public class Main {
    public static void main(String[] args) {
        CopyOnWriteArraySet<String> set = new CopyOnWriteArraySet<>();
        set.add("A");
        set.add("B");
        set.add("C");

        Iterator<String> iterator = set.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
            set.add("D"); // No ConcurrentModificationException!
        }

        System.out.println(set); // Output: [A, B, C, D]
    }
}
```
‚úîÔ∏è **Iterator does not throw `ConcurrentModificationException`**.  
‚úîÔ∏è **Changes made while iterating will not affect the current iterator**.  

---

## **6Ô∏è‚É£ Performance Analysis**
| Operation | Time Complexity |
|-----------|---------------|
| `add(E e)` | `O(n)` (Creates a new copy of the array) |
| `remove(E e)` | `O(n)` |
| `contains(E e)` | `O(n)` |
| `iteration` | `O(n)` |

‚úîÔ∏è **Best for multi-threaded environments with frequent reads and rare writes**.  
‚úîÔ∏è **Not suitable for scenarios with frequent insertions/removals (`O(n)`)**.  

---

## **7Ô∏è‚É£ When to Use `CopyOnWriteArraySet<T>`?**
| Use `CopyOnWriteArraySet<T>` When... | Avoid `CopyOnWriteArraySet<T>` When... |
|--------------------------------------|--------------------------------------|
| **Frequent reads, rare writes**. | **Frequent additions/removals** (`O(n)`). |
| **Multiple threads accessing the set**. | **Performance is critical** (Use `HashSet` for faster operations). |
| **You need fail-safe iterators**. | **You have large datasets** (Memory overhead is high). |

---

## **8Ô∏è‚É£ Summary**
‚úîÔ∏è **Thread-safe `Set<T>` implementation** (No need for manual synchronization).  
‚úîÔ∏è **Uses `CopyOnWriteArrayList<T>` internally** (Every modification creates a new copy).  
‚úîÔ∏è **Best for read-heavy operations in multi-threaded environments**.  
‚úîÔ∏è **Fail-safe iterators (No `ConcurrentModificationException`)**.  
‚úîÔ∏è **Not suitable for frequent writes (`O(n)` complexity)**.  

---

# **üìå Chapter 5: Queue Interface (FIFO Data Structure) in Java (Deep and Easy Explanation)**  

---

## **1Ô∏è‚É£ What is a Queue?**
A **Queue** is a **FIFO (First-In-First-Out)** data structure, meaning the **first element added** will be the **first element removed**.

‚úîÔ∏è **Imagine a queue at a movie ticket counter:**  
- The first person who arrives will be the first one to get the ticket.  
- The next person waits in line until it's their turn.  

‚úîÔ∏è **Real-Life Examples of Queues:**  
- **Print Queue:** The first document sent to the printer gets printed first.  
- **Call Center Support:** The first customer in line gets connected to an agent first.  

‚úîÔ∏è **Java Provides `Queue<T>` Interface**  
- It is part of **`java.util` package** and extends the `Collection<T>` interface.  
- **Different Implementations** are available based on requirements.  

---

## **2Ô∏è‚É£ Why Do We Need a Queue in Java?**
üîπ **Problem with Arrays & Lists:**  
- `ArrayList` and `LinkedList` allow insertion and removal, but they do **not follow FIFO automatically**.  
- Using **`remove(0)`** in an `ArrayList` is slow (`O(n)`) because all elements shift left.  

üîπ **Queue is the Solution:**  
- Efficiently **adds elements at the rear** and **removes from the front** (`O(1)`).  
- Provides **built-in methods** for managing elements.  

---

## **3Ô∏è‚É£ Queue Interface and Its Methods**
| Method | Description |
|--------|------------|
| `add(E e)` | Adds an element at the end (throws exception if full). |
| `offer(E e)` | Adds an element at the end (returns false if full). |
| `remove()` | Removes and returns the front element (throws exception if empty). |
| `poll()` | Removes and returns the front element (returns null if empty). |
| `element()` | Retrieves the front element without removing (throws exception if empty). |
| `peek()` | Retrieves the front element without removing (returns null if empty). |

‚úîÔ∏è **Use `offer()` and `poll()` instead of `add()` and `remove()` to avoid exceptions.**  

---

## **4Ô∏è‚É£ Queue Hierarchy in Java**
```
Queue<T>  (Interface)
‚îÇ
‚îú‚îÄ‚îÄ LinkedList<T>  (Doubly Linked List Implementation)
‚îÇ
‚îú‚îÄ‚îÄ PriorityQueue<T>  (Min-Heap Implementation)
‚îÇ
‚îú‚îÄ‚îÄ Deque<T>  (Double-Ended Queue Interface)
‚îÇ   ‚îú‚îÄ‚îÄ ArrayDeque<T>  (Array-Based Deque)
‚îÇ   ‚îú‚îÄ‚îÄ LinkedList<T>  (Also Implements Deque)
‚îÇ
‚îú‚îÄ‚îÄ ConcurrentLinkedQueue<T>  (Thread-Safe, Non-Blocking Queue)
‚îÇ
‚îú‚îÄ‚îÄ BlockingQueue<T>  (Used in Multi-Threading)
‚îÇ   ‚îú‚îÄ‚îÄ ArrayBlockingQueue<T>
‚îÇ   ‚îú‚îÄ‚îÄ LinkedBlockingQueue<T>
‚îÇ   ‚îú‚îÄ‚îÄ PriorityBlockingQueue<T>
‚îÇ   ‚îú‚îÄ‚îÄ SynchronousQueue<T>
‚îÇ   ‚îú‚îÄ‚îÄ DelayQueue<T>
```

---

## **5Ô∏è‚É£ Types of Queue Implementations in Java**
Let's go through the different types of `Queue<T>` implementations.

### **1Ô∏è‚É£ LinkedList<T> as a Queue**
- Implements `Queue<T>`, `Deque<T>`, and `List<T>`.
- Can be used as **FIFO Queue** or **Deque**.
- Not thread-safe.

### **2Ô∏è‚É£ PriorityQueue<T>**
- Uses **Min-Heap** internally.
- Orders elements based on **natural ordering or custom comparator**.
- Does **not** guarantee FIFO.

### **3Ô∏è‚É£ Deque<T> (Double-Ended Queue)**
- Allows insertion and deletion from **both ends**.
- `ArrayDeque<T>` and `LinkedList<T>` implement `Deque<T>`.

### **4Ô∏è‚É£ ArrayDeque<T> (Resizable Array-Based Deque)**
- Faster than `Stack<T>` for LIFO.
- Faster than `LinkedList<T>` for FIFO.

### **5Ô∏è‚É£ ConcurrentLinkedQueue<T>**
- **Thread-safe implementation** of `Queue<T>`.
- **Non-blocking** (uses **CAS** instead of locks).

### **6Ô∏è‚É£ BlockingQueue<T> (Used in Multi-Threading)**
- Designed for **multi-threading scenarios**.
- Blocks producer/consumer threads if the queue is full/empty.
- Common implementations:
  - `ArrayBlockingQueue<T>` ‚Üí **Fixed-size array-based blocking queue**.
  - `LinkedBlockingQueue<T>` ‚Üí **Linked list-based blocking queue**.
  - `PriorityBlockingQueue<T>` ‚Üí **Priority-based blocking queue**.
  - `SynchronousQueue<T>` ‚Üí **Transfers elements between threads directly**.
  - `DelayQueue<T>` ‚Üí **Stores elements with delayed processing**.

---

## **6Ô∏è‚É£ Performance Comparison of Queue Implementations**
| Queue Type | Insertion (`O`) | Deletion (`O`) | Thread-Safe? |
|------------|--------------|-------------|--------------|
| `LinkedList<T>` | `O(1)` | `O(1)` | ‚ùå No |
| `PriorityQueue<T>` | `O(log n)` | `O(log n)` | ‚ùå No |
| `ArrayDeque<T>` | `O(1)` | `O(1)` | ‚ùå No |
| `ConcurrentLinkedQueue<T>` | `O(1)` | `O(1)` | ‚úÖ Yes (Non-Blocking) |
| `BlockingQueue<T>` | `O(1)` | `O(1)` | ‚úÖ Yes (Blocking) |

---

## **7Ô∏è‚É£ When to Use Which Queue?**
| **Use Case** | **Best Queue Implementation** |
|-------------|-----------------------------|
| Simple FIFO operations | `LinkedList<T>` |
| Priority-based processing | `PriorityQueue<T>` |
| Double-ended queue operations | `ArrayDeque<T>` |
| Multi-threaded queue (non-blocking) | `ConcurrentLinkedQueue<T>` |
| Multi-threaded queue (blocking) | `BlockingQueue<T>` |

---

## **üìå Summary**
‚úîÔ∏è **Queue<T> follows FIFO (First-In-First-Out).**  
‚úîÔ∏è **Different implementations available:** `LinkedList<T>`, `PriorityQueue<T>`, `ArrayDeque<T>`, `ConcurrentLinkedQueue<T>`, `BlockingQueue<T>`.  
‚úîÔ∏è **Use `offer()` and `poll()` instead of `add()` and `remove()` to avoid exceptions.**  
‚úîÔ∏è **Choose the right queue based on performance needs (thread-safety, ordering, blocking, etc.).**  

---

# **üöÄ LinkedList<T> as a Queue (Deep & Easy Explanation)**  

---

## **1Ô∏è‚É£ What is LinkedList<T> as a Queue?**
`LinkedList<T>` is a **doubly linked list** that implements the `Queue<T>` interface.  
It allows **FIFO (First-In-First-Out) operations**, making it a **good choice** for a queue.  

‚úîÔ∏è **Key Features of LinkedList as a Queue:**  
- **Uses Nodes** (Each element points to the next and previous element).  
- **Fast Insertions & Deletions (`O(1)`)** at both ends.  
- **Maintains Order** (Insertion order is preserved).  
- **Allows Null Values.**  
- **Not Thread-Safe** (Needs external synchronization for multi-threading).  

‚úîÔ∏è **Real-Life Example:**  
- **Train Coaches:** The first coach attached is the first to leave the station.  

---

## **2Ô∏è‚É£ How LinkedList<T> Works as a Queue?**
‚úîÔ∏è **Queue Operations:**  
1Ô∏è‚É£ **Enqueue (Add element at the rear)** ‚Üí `offer(E e)` / `add(E e)`  
2Ô∏è‚É£ **Dequeue (Remove element from the front)** ‚Üí `poll()` / `remove()`  
3Ô∏è‚É£ **Peek (Retrieve front element without removing)** ‚Üí `peek()` / `element()`  

üìå **Internal Working:**  
- **Each element is stored in a Node (`Node<E>`)**  
- **Two pointers (`head` and `tail`) keep track of the front & rear.**  
- **Adding is done at `tail`**, removing is done from `head`.**  

```
HEAD ‚Üí [10] ‚Üí [20] ‚Üí [30] ‚Üí TAIL
```

‚úîÔ∏è **Adding 40 to Queue (`offer(40)`)**  
```
HEAD ‚Üí [10] ‚Üí [20] ‚Üí [30] ‚Üí [40] ‚Üí TAIL
```

‚úîÔ∏è **Removing (`poll()`)**  
```
HEAD ‚Üí [20] ‚Üí [30] ‚Üí [40] ‚Üí TAIL  (10 is removed)
```

---

## **3Ô∏è‚É£ LinkedList<T> Methods for Queue**
| Method | Description |
|--------|------------|
| `add(E e)` | Adds an element to the queue (throws exception if full). |
| `offer(E e)` | Adds an element to the queue (returns `false` if full). |
| `remove()` | Removes the front element (throws exception if empty). |
| `poll()` | Removes the front element (returns `null` if empty). |
| `element()` | Retrieves the front element without removing (throws exception if empty). |
| `peek()` | Retrieves the front element without removing (returns `null` if empty). |

---

## **4Ô∏è‚É£ Implementation of LinkedList<T> as a Queue**
```java
import java.util.LinkedList;
import java.util.Queue;

public class LinkedListQueueExample {
    public static void main(String[] args) {
        // Create a Queue using LinkedList
        Queue<Integer> queue = new LinkedList<>();

        // Adding elements to the queue
        queue.offer(10);
        queue.offer(20);
        queue.offer(30);

        System.out.println("Queue: " + queue); // [10, 20, 30]

        // Peek (front element without removing)
        System.out.println("Front Element: " + queue.peek()); // 10

        // Removing elements
        System.out.println("Removed: " + queue.poll()); // 10
        System.out.println("Queue after removal: " + queue); // [20, 30]

        // Checking if queue is empty
        System.out.println("Is queue empty? " + queue.isEmpty()); // false
    }
}
```

‚úîÔ∏è **Output:**
```
Queue: [10, 20, 30]
Front Element: 10
Removed: 10
Queue after removal: [20, 30]
Is queue empty? false
```

---

## **5Ô∏è‚É£ How LinkedList<T> Works Internally as a Queue**
‚úîÔ∏è **Structure:**  
- **Each element is stored in a `Node<E>`.**  
- **Each Node contains:**  
  - `E data` (Element Value)  
  - `Node<E> next` (Pointer to next node)  
  - `Node<E> prev` (Pointer to previous node)  

‚úîÔ∏è **Internal Representation:**
```
head ‚Üí [10] ‚Üî [20] ‚Üî [30] ‚Üí tail
```
‚úîÔ∏è **Adding an Element (`offer(40)`)**
```
head ‚Üí [10] ‚Üî [20] ‚Üî [30] ‚Üî [40] ‚Üí tail
```
‚úîÔ∏è **Removing an Element (`poll()`)**
```
head ‚Üí [20] ‚Üî [30] ‚Üî [40] ‚Üí tail
```

---

## **6Ô∏è‚É£ Performance Analysis of LinkedList as a Queue**
| Operation | Complexity (`O`) |
|-----------|----------------|
| `offer(E e)` (Add to rear) | `O(1)` |
| `poll()` (Remove from front) | `O(1)` |
| `peek()` (Retrieve front) | `O(1)` |
| Search | `O(n)` |

‚úîÔ∏è **Why is LinkedList Fast for Queue?**  
- **`O(1)` insertion and deletion at both ends** (No shifting needed).  
- **`O(n)` search** (Not efficient for finding elements).  

---

## **7Ô∏è‚É£ When to Use LinkedList as a Queue?**
‚úîÔ∏è **Use `LinkedList<T>` when:**  
‚úÖ **Fast Insertion & Deletion (`O(1)`) are needed.**  
‚úÖ **You don‚Äôt need random access (`O(n)`).**  
‚úÖ **Maintaining insertion order is important.**  
‚úÖ **You need a flexible data structure (Can act as a Queue & Deque).**  

‚ùå **Don‚Äôt use LinkedList<T> when:**  
üö´ **You need frequent searching (`O(n)`).**  
üö´ **Memory consumption is a concern (Each node requires extra pointers).**  

---

## **üìå Summary**
‚úîÔ∏è **`LinkedList<T>` implements `Queue<T>`.**  
‚úîÔ∏è **FIFO operations:** Insert at the tail, remove from the head.  
‚úîÔ∏è **Efficient `O(1)` insertion & deletion, but `O(n)` search.**  
‚úîÔ∏è **Uses `Node<E>` (doubly linked list structure).**  
‚úîÔ∏è **Best for scenarios needing fast insert/remove, but not for random access.**  

---

# **üöÄ PriorityQueue<T> (Deep & Easy Explanation)**  

---

## **1Ô∏è‚É£ What is a PriorityQueue<T>?**
A **PriorityQueue<T>** is a special type of queue where **elements are ordered based on priority** rather than insertion order.  
It is based on **Heap Data Structure** (Min-Heap or Max-Heap).  

‚úîÔ∏è **Key Features of PriorityQueue:**  
- **Elements are sorted based on priority (Natural or Custom Comparator).**  
- **By default, it is a Min-Heap (Smallest element at the top).**  
- **Does NOT allow `null` values.**  
- **Not thread-safe** (Use `PriorityBlockingQueue` for multi-threading).  

‚úîÔ∏è **Real-Life Example:**  
- **Hospital Emergency Room:** Patients with serious conditions are treated first.  
- **Dijkstra‚Äôs Algorithm:** Used in shortest path finding.  

---

## **2Ô∏è‚É£ How PriorityQueue<T> Works?**
‚úîÔ∏è **Queue Operations:**  
1Ô∏è‚É£ **Enqueue (Add element in the correct position based on priority)** ‚Üí `offer(E e)` / `add(E e)`  
2Ô∏è‚É£ **Dequeue (Remove element with highest priority)** ‚Üí `poll()` / `remove()`  
3Ô∏è‚É£ **Peek (Retrieve highest-priority element without removing)** ‚Üí `peek()` / `element()`  

üìå **Default Behavior:**  
- **Min-Heap (Smallest element first).**  
- **Max-Heap (Largest element first) needs a custom comparator.**  

```
Min-Heap:
PriorityQueue<Integer> pq = new PriorityQueue<>();
pq.offer(30);
pq.offer(10);
pq.offer(20);

Internally Stored:  
[10, 30, 20]   ‚Üí 10 is the highest priority (Min-Heap)
```

‚úîÔ∏è **Adding 5 to Queue (`offer(5)`)**  
```
[5, 10, 20, 30]   ‚Üí 5 moves to the top
```

‚úîÔ∏è **Removing (`poll()`)**  
```
[10, 30, 20]   ‚Üí 5 is removed
```

---

## **3Ô∏è‚É£ PriorityQueue<T> Methods**
| Method | Description |
|--------|------------|
| `add(E e)` | Adds an element to the queue (throws exception if full). |
| `offer(E e)` | Adds an element to the queue (returns `false` if full). |
| `remove()` | Removes the highest-priority element (throws exception if empty). |
| `poll()` | Removes the highest-priority element (returns `null` if empty). |
| `element()` | Retrieves the highest-priority element without removing (throws exception if empty). |
| `peek()` | Retrieves the highest-priority element without removing (returns `null` if empty). |

---

## **4Ô∏è‚É£ Implementation of PriorityQueue<T>**
```java
import java.util.PriorityQueue;

public class PriorityQueueExample {
    public static void main(String[] args) {
        // Create a Min-Heap (default)
        PriorityQueue<Integer> pq = new PriorityQueue<>();

        // Adding elements
        pq.offer(30);
        pq.offer(10);
        pq.offer(20);

        System.out.println("PriorityQueue: " + pq); // Output: [10, 30, 20]

        // Peek (Retrieve highest priority element)
        System.out.println("Top Element: " + pq.peek()); // Output: 10

        // Removing elements
        System.out.println("Removed: " + pq.poll()); // Output: 10
        System.out.println("PriorityQueue after removal: " + pq); // Output: [20, 30]
    }
}
```

‚úîÔ∏è **Output:**
```
PriorityQueue: [10, 30, 20]
Top Element: 10
Removed: 10
PriorityQueue after removal: [20, 30]
```

---

## **5Ô∏è‚É£ How PriorityQueue Works Internally?**
‚úîÔ∏è **Structure:**  
- **Uses a Min-Heap (Binary Heap) internally.**  
- **Heap is stored in an array for efficient retrieval.**  
- **Insertion follows heap properties (smallest at root).**  
- **Removal maintains heap properties (restructure after deletion).**  

‚úîÔ∏è **Internal Representation (Heap Structure)**
```
        10
       /  \
     30    20
```
‚úîÔ∏è **Adding 5 (`offer(5)`)**
```
        5
       /  \
     10    20
    /
  30
```
‚úîÔ∏è **Removing (`poll()`)**
```
        10
       /  \
     30    20
```

---

## **6Ô∏è‚É£ Custom Comparator for Max-Heap (Highest First)**
By default, `PriorityQueue` is a **Min-Heap**. To make it a **Max-Heap**, use a custom comparator.

```java
import java.util.PriorityQueue;
import java.util.Collections;

public class MaxHeapExample {
    public static void main(String[] args) {
        // Max-Heap using Comparator
        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());

        maxHeap.offer(30);
        maxHeap.offer(10);
        maxHeap.offer(20);

        System.out.println("Max-Heap PriorityQueue: " + maxHeap); // Output: [30, 10, 20]

        System.out.println("Top Element: " + maxHeap.peek()); // Output: 30
        System.out.println("Removed: " + maxHeap.poll()); // Output: 30
    }
}
```
‚úîÔ∏è **Output:**
```
Max-Heap PriorityQueue: [30, 10, 20]
Top Element: 30
Removed: 30
```

---

## **7Ô∏è‚É£ Performance Analysis of PriorityQueue<T>**
| Operation | Complexity (`O`) |
|-----------|----------------|
| `offer(E e)` (Insertion) | `O(log n)` |
| `poll()` (Remove highest priority) | `O(log n)` |
| `peek()` (Retrieve highest priority) | `O(1)` |

‚úîÔ∏è **Why is PriorityQueue Fast?**  
- **Uses Heap structure (Efficient insertion/removal).**  
- **Heap properties ensure quick access to the highest priority.**  

---

## **8Ô∏è‚É£ When to Use PriorityQueue?**
‚úîÔ∏è **Use `PriorityQueue<T>` when:**  
‚úÖ **You need efficient priority-based retrieval.**  
‚úÖ **You need a Min-Heap (`O(log n)` operations).**  
‚úÖ **You need a Max-Heap (With custom comparator).**  

‚ùå **Don‚Äôt use PriorityQueue when:**  
üö´ **You need FIFO ordering (Use `LinkedList` for Queue).**  
üö´ **You need thread-safety (Use `PriorityBlockingQueue`).**  
üö´ **You need fast random access (`O(n)`).**  

---

## **üìå Summary**
‚úîÔ∏è **`PriorityQueue<T>` orders elements based on priority.**  
‚úîÔ∏è **Min-Heap by default (Smallest element first).**  
‚úîÔ∏è **Supports custom comparator for Max-Heap.**  
‚úîÔ∏è **Operations are `O(log n)`, making it efficient.**  
‚úîÔ∏è **Best for priority-based tasks like scheduling, pathfinding, etc.**  

---

# **üöÄ Deque<T> (Double-Ended Queue) - Deep & Easy Explanation**  

---

## **1Ô∏è‚É£ What is a Deque<T>?**  
A **Deque (Double-Ended Queue)** is a special type of queue where **elements can be added or removed from both ends (front & rear).**  

‚úîÔ∏è **Key Features of Deque:**  
- **Supports FIFO & LIFO operations.**  
- **Efficient insertions/removals from both ends.**  
- **Allows `null` values (except in concurrent implementations).**  
- **Faster than `LinkedList` for queue operations.**  
- **Thread-safe versions exist (`ConcurrentLinkedDeque`).**  

‚úîÔ∏è **Real-Life Example:**  
- **Deque in Browsers:** Back & Forward navigation history.  
- **Job Scheduling:** Tasks can be added at the beginning or end.  

---

## **2Ô∏è‚É£ How Deque<T> Works?**
‚úîÔ∏è **Operations on Both Ends:**  
1Ô∏è‚É£ **Add to Front** ‚Üí `addFirst(E e)` / `offerFirst(E e)`  
2Ô∏è‚É£ **Remove from Front** ‚Üí `removeFirst()` / `pollFirst()`  
3Ô∏è‚É£ **Add to Rear** ‚Üí `addLast(E e)` / `offerLast(E e)`  
4Ô∏è‚É£ **Remove from Rear** ‚Üí `removeLast()` / `pollLast()`  
5Ô∏è‚É£ **Peek (Retrieve without removing)** ‚Üí `peekFirst()` / `peekLast()`  

‚úîÔ∏è **Deque as a Queue (FIFO)**
```
Front ‚ûù [1, 2, 3, 4, 5] ‚ûù Rear
```
‚úîÔ∏è **Deque as a Stack (LIFO)**
```
Top ‚ûù [1, 2, 3, 4, 5] (Last In First Out)
```

---

## **3Ô∏è‚É£ Deque<T> Methods**
| Method | Description |
|--------|------------|
| `addFirst(E e)` | Adds element at the front (throws exception if full). |
| `offerFirst(E e)` | Adds element at the front (returns `false` if full). |
| `addLast(E e)` | Adds element at the rear (throws exception if full). |
| `offerLast(E e)` | Adds element at the rear (returns `false` if full). |
| `removeFirst()` | Removes the first element (throws exception if empty). |
| `pollFirst()` | Removes the first element (returns `null` if empty). |
| `removeLast()` | Removes the last element (throws exception if empty). |
| `pollLast()` | Removes the last element (returns `null` if empty). |
| `peekFirst()` | Retrieves the first element without removing. |
| `peekLast()` | Retrieves the last element without removing. |

---

## **4Ô∏è‚É£ Implementation of Deque<T>**
```java
import java.util.Deque;
import java.util.LinkedList;

public class DequeExample {
    public static void main(String[] args) {
        // Creating a Deque
        Deque<Integer> deque = new LinkedList<>();

        // Adding elements at both ends
        deque.addFirst(10);
        deque.addLast(20);
        deque.offerFirst(5);
        deque.offerLast(25);

        System.out.println("Deque: " + deque); // Output: [5, 10, 20, 25]

        // Retrieving elements
        System.out.println("First Element: " + deque.peekFirst()); // Output: 5
        System.out.println("Last Element: " + deque.peekLast()); // Output: 25

        // Removing elements from both ends
        System.out.println("Removed First: " + deque.pollFirst()); // Output: 5
        System.out.println("Removed Last: " + deque.pollLast()); // Output: 25

        System.out.println("Deque after removal: " + deque); // Output: [10, 20]
    }
}
```

‚úîÔ∏è **Output:**
```
Deque: [5, 10, 20, 25]
First Element: 5
Last Element: 25
Removed First: 5
Removed Last: 25
Deque after removal: [10, 20]
```

---

## **5Ô∏è‚É£ How Deque Works Internally?**
‚úîÔ∏è **Structure:**  
- **Uses a Doubly Linked List or Resizable Array (ArrayDeque).**  
- **Efficient insertions/removals at both ends (`O(1)`).**  

‚úîÔ∏è **Internal Representation (Doubly Linked List)**
```
 NULL ‚Üê [5] ‚áÑ [10] ‚áÑ [20] ‚áÑ [25] ‚Üí NULL
```
‚úîÔ∏è **Adding 30 at front (`addFirst(30)`)**
```
 NULL ‚Üê [30] ‚áÑ [5] ‚áÑ [10] ‚áÑ [20] ‚áÑ [25] ‚Üí NULL
```
‚úîÔ∏è **Removing last (`pollLast()`)**
```
 NULL ‚Üê [30] ‚áÑ [5] ‚áÑ [10] ‚áÑ [20] ‚Üí NULL
```

---

## **6Ô∏è‚É£ ArrayDeque<T> (Faster Alternative to LinkedList)**
**ArrayDeque** is an array-based **double-ended queue**, faster than `LinkedList`.  

‚úîÔ∏è **Why Use `ArrayDeque` Instead of `LinkedList`?**  
- **No overhead of node pointers (faster).**  
- **Resizable array grows automatically.**  
- **Faster insertion/removal (`O(1)`).**  

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class ArrayDequeExample {
    public static void main(String[] args) {
        Deque<Integer> arrayDeque = new ArrayDeque<>();

        arrayDeque.addFirst(10);
        arrayDeque.addLast(20);
        arrayDeque.offerFirst(5);
        arrayDeque.offerLast(25);

        System.out.println("ArrayDeque: " + arrayDeque); // Output: [5, 10, 20, 25]
    }
}
```

---

## **7Ô∏è‚É£ Performance Analysis of Deque<T>**
| Operation | LinkedList `O(n)` | ArrayDeque `O(1)` |
|-----------|----------------|----------------|
| `addFirst(E e)` | `O(1)` | `O(1)` |
| `addLast(E e)` | `O(1)` | `O(1)` |
| `removeFirst()` | `O(1)` | `O(1)` |
| `removeLast()` | `O(1)` | `O(1)` |
| `getFirst()` | `O(1)` | `O(1)` |
| `getLast()` | `O(1)` | `O(1)` |

‚úîÔ∏è **`ArrayDeque` is the best choice for Deque operations.**  

---

## **8Ô∏è‚É£ When to Use Deque?**
‚úîÔ∏è **Use `Deque<T>` when:**  
‚úÖ **You need insertion/removal from both ends.**  
‚úÖ **You need a fast, resizable queue.**  
‚úÖ **You need LIFO & FIFO behavior.**  

‚ùå **Don‚Äôt use Deque when:**  
üö´ **You need indexed access (Use `ArrayList`).**  
üö´ **You need thread-safety (Use `ConcurrentLinkedDeque`).**  

---

## **üìå Summary**
‚úîÔ∏è **Deque supports adding/removing from both ends.**  
‚úîÔ∏è **Uses `LinkedList` (Doubly Linked List) or `ArrayDeque` (Resizable Array).**  
‚úîÔ∏è **Faster than `LinkedList` for queue operations.**  
‚úîÔ∏è **Best choice: `ArrayDeque` (Faster than `LinkedList`).**  
‚úîÔ∏è **Operations are `O(1)`, making it efficient.**  

---

# üöÄ **ArrayDeque<T> ‚Äì Deep Dive & Easy Explanation**  

---

## **1Ô∏è‚É£ What is ArrayDeque<T>?**
An **ArrayDeque (Array Double-Ended Queue)** is a **resizable array-based implementation of Deque**, which allows **efficient insertion and removal of elements from both ends**.  

‚úîÔ∏è **Key Features:**  
- **Faster than `LinkedList<T>` for Deque operations.**  
- **Dynamic resizing (no fixed capacity like an array).**  
- **Does NOT allow `null` elements (unlike `LinkedList`).**  
- **Not thread-safe (use `ConcurrentLinkedDeque` for multi-threading).**  

üìå **Real-Life Example:**  
- **Task Scheduling** ‚Äì Jobs added at the front or end of the queue.  
- **Undo-Redo Feature** ‚Äì Last action undone (LIFO), or first action redone (FIFO).  

---

## **2Ô∏è‚É£ How Does ArrayDeque<T> Work?**
üìå **Operations on Both Ends**  
1Ô∏è‚É£ **Add at Front** ‚Üí `addFirst(E e)` / `offerFirst(E e)`  
2Ô∏è‚É£ **Remove from Front** ‚Üí `removeFirst()` / `pollFirst()`  
3Ô∏è‚É£ **Add at Rear** ‚Üí `addLast(E e)` / `offerLast(E e)`  
4Ô∏è‚É£ **Remove from Rear** ‚Üí `removeLast()` / `pollLast()`  
5Ô∏è‚É£ **Peek (Retrieve without removing)** ‚Üí `peekFirst()` / `peekLast()`  

‚úîÔ∏è **ArrayDeque as a Queue (FIFO)**
```
Front ‚ûù [1, 2, 3, 4, 5] ‚ûù Rear
```
‚úîÔ∏è **ArrayDeque as a Stack (LIFO)**
```
Top ‚ûù [1, 2, 3, 4, 5] (Last In First Out)
```

---

## **3Ô∏è‚É£ Methods of ArrayDeque<T>**
| Method | Description |
|--------|------------|
| `addFirst(E e)` | Adds an element at the front (throws exception if full). |
| `offerFirst(E e)` | Adds an element at the front (returns `false` if full). |
| `addLast(E e)` | Adds an element at the rear (throws exception if full). |
| `offerLast(E e)` | Adds an element at the rear (returns `false` if full). |
| `removeFirst()` | Removes the first element (throws exception if empty). |
| `pollFirst()` | Removes the first element (returns `null` if empty). |
| `removeLast()` | Removes the last element (throws exception if empty). |
| `pollLast()` | Removes the last element (returns `null` if empty). |
| `peekFirst()` | Retrieves the first element without removing. |
| `peekLast()` | Retrieves the last element without removing. |

---

## **4Ô∏è‚É£ Implementation of ArrayDeque<T>**
```java
import java.util.ArrayDeque;
import java.util.Deque;

public class ArrayDequeExample {
    public static void main(String[] args) {
        // Creating an ArrayDeque
        Deque<Integer> deque = new ArrayDeque<>();

        // Adding elements at both ends
        deque.addFirst(10);
        deque.addLast(20);
        deque.offerFirst(5);
        deque.offerLast(25);

        System.out.println("ArrayDeque: " + deque); // Output: [5, 10, 20, 25]

        // Retrieving elements
        System.out.println("First Element: " + deque.peekFirst()); // Output: 5
        System.out.println("Last Element: " + deque.peekLast()); // Output: 25

        // Removing elements from both ends
        System.out.println("Removed First: " + deque.pollFirst()); // Output: 5
        System.out.println("Removed Last: " + deque.pollLast()); // Output: 25

        System.out.println("ArrayDeque after removal: " + deque); // Output: [10, 20]
    }
}
```

‚úîÔ∏è **Output:**
```
ArrayDeque: [5, 10, 20, 25]
First Element: 5
Last Element: 25
Removed First: 5
Removed Last: 25
ArrayDeque after removal: [10, 20]
```

---

## **5Ô∏è‚É£ How ArrayDeque Works Internally?**
üìå **Structure:**  
- Uses **a dynamically resizable circular array**.  
- **Elements wrap around when reaching array capacity.**  
- **Insertion/removal from both ends is O(1)** because it doesn‚Äôt require shifting like `ArrayList`.  

‚úîÔ∏è **Internal Representation (Circular Array)**
```
[ _, _, 10, 20, 30, _, _, _ ]
     ‚Üë   ‚Üë    ‚Üë  
    Front  Elements  Rear
```
‚úîÔ∏è **Adding `40` at front (`addFirst(40)`)**
```
[ _, _, 40, 10, 20, 30, _, _ ]
     ‚Üë   ‚Üë    ‚Üë  
    Front  Elements  Rear
```
‚úîÔ∏è **Removing last (`pollLast()`)**
```
[ _, _, 40, 10, 20, _, _, _ ]
     ‚Üë   ‚Üë    ‚Üë  
    Front  Elements  Rear
```

---

## **6Ô∏è‚É£ Performance Analysis of ArrayDeque<T>**
| Operation | ArrayDeque `O(1)` | LinkedList `O(n)` |
|-----------|----------------|----------------|
| `addFirst(E e)` | `O(1)` | `O(1)` |
| `addLast(E e)` | `O(1)` | `O(1)` |
| `removeFirst()` | `O(1)` | `O(1)` |
| `removeLast()` | `O(1)` | `O(1)` |
| `getFirst()` | `O(1)` | `O(1)` |
| `getLast()` | `O(1)` | `O(1)` |

‚úîÔ∏è **ArrayDeque is the best choice for Deque operations.**  

---

## **7Ô∏è‚É£ When to Use ArrayDeque?**
‚úîÔ∏è **Use `ArrayDeque<T>` when:**  
‚úÖ **You need fast insertion/removal from both ends.**  
‚úÖ **You need a resizable array-backed deque.**  
‚úÖ **You don‚Äôt need thread-safety.**  

‚ùå **Don‚Äôt use ArrayDeque when:**  
üö´ **You need indexed access (Use `ArrayList`).**  
üö´ **You need thread-safety (Use `ConcurrentLinkedDeque`).**  

---

## **üìå Summary**
‚úîÔ∏è **ArrayDeque supports adding/removing from both ends.**  
‚úîÔ∏è **Uses a dynamic resizable array (circular buffer).**  
‚úîÔ∏è **Faster than `LinkedList` for queue operations.**  
‚úîÔ∏è **Best choice: `ArrayDeque` (Faster than `LinkedList`).**  
‚úîÔ∏è **Operations are `O(1)`, making it efficient.**  

---

# üöÄ **ConcurrentLinkedQueue<T> ‚Äì Deep Dive & Easy Explanation**  

---

## **1Ô∏è‚É£ What is ConcurrentLinkedQueue<T>?**
A **ConcurrentLinkedQueue** is a **thread-safe, non-blocking, FIFO (First-In-First-Out) queue** that allows multiple threads to access and modify it **without explicit locking**.  

‚úîÔ∏è **Key Features:**  
- ‚úÖ **Thread-safe** (Multiple threads can modify it safely).  
- ‚úÖ **Non-blocking** (Uses **CAS (Compare-And-Swap) operations** instead of locks).  
- ‚úÖ **FIFO Order** (Elements are processed in order of insertion).  
- ‚úÖ **Does NOT allow `null` elements**.  
- ‚úÖ **Uses a **linked-list** internally (Each element points to the next).  

üìå **Real-Life Example:**  
- **Producer-Consumer Pattern** ‚Äì Multiple producer threads add tasks, while consumer threads process them.  
- **Multi-threaded Job Queue** ‚Äì A system where multiple users submit jobs for processing.  

---

## **2Ô∏è‚É£ How Does ConcurrentLinkedQueue<T> Work Internally?**
üìå **Non-blocking Mechanism**  
- Instead of locks (`synchronized` keyword), it uses **atomic operations (CAS - Compare-And-Swap)**.  
- This makes it **faster than blocking queues (`BlockingQueue`) in high-concurrency situations**.  

‚úîÔ∏è **Internal Structure (Linked List Implementation)**  
```
Head ‚ûù [1] ‚ûù [2] ‚ûù [3] ‚ûù Tail
```
- **New elements are added at the tail.**  
- **Elements are removed from the head.**  
- **Each node contains a reference to the next node.**  

---

## **3Ô∏è‚É£ Methods of ConcurrentLinkedQueue<T>**
| Method | Description |
|--------|------------|
| `add(E e)` | Adds an element at the tail (throws exception if `null`). |
| `offer(E e)` | Adds an element at the tail (returns `false` if `null`). |
| `poll()` | Retrieves and removes the head of the queue (returns `null` if empty). |
| `peek()` | Retrieves but does not remove the head (returns `null` if empty). |
| `size()` | Returns the number of elements (not always accurate in multi-threading). |
| `isEmpty()` | Checks if the queue is empty. |
| `iterator()` | Returns an iterator over the elements (weakly consistent). |

‚úîÔ∏è **Important Notes:**  
- üöÄ `size()` may not be accurate in multi-threading because other threads might modify the queue simultaneously.  
- üöÄ **`poll()` is better than `remove()`** since it doesn‚Äôt throw an exception if the queue is empty.  

---

## **4Ô∏è‚É£ Implementation of ConcurrentLinkedQueue<T>**
```java
import java.util.concurrent.ConcurrentLinkedQueue;

public class ConcurrentLinkedQueueExample {
    public static void main(String[] args) {
        // Creating a ConcurrentLinkedQueue
        ConcurrentLinkedQueue<Integer> queue = new ConcurrentLinkedQueue<>();

        // Adding elements
        queue.add(10);
        queue.offer(20);
        queue.offer(30);

        System.out.println("Queue: " + queue); // Output: [10, 20, 30]

        // Retrieving elements
        System.out.println("Head Element (peek): " + queue.peek()); // Output: 10

        // Removing elements
        System.out.println("Removed Element (poll): " + queue.poll()); // Output: 10

        System.out.println("Queue after removal: " + queue); // Output: [20, 30]
    }
}
```

‚úîÔ∏è **Output:**
```
Queue: [10, 20, 30]
Head Element (peek): 10
Removed Element (poll): 10
Queue after removal: [20, 30]
```

---

## **5Ô∏è‚É£ How ConcurrentLinkedQueue Works Internally?**
üìå **Uses Atomic References for Thread-Safety**  
- **Each node contains:**  
  - **Value**
  - **Reference to next node**
- **CAS (Compare-And-Swap) is used to modify nodes without locks.**  

‚úîÔ∏è **Example: Adding Elements**  
```
Head ‚ûù [10] ‚ûù [20] ‚ûù [30] ‚ûù Tail
```
‚úîÔ∏è **Example: Polling (Removing Head)**  
```
Before poll(): Head ‚ûù [10] ‚ûù [20] ‚ûù [30] ‚ûù Tail
After poll():  Head ‚ûù [20] ‚ûù [30] ‚ûù Tail
```

üìå **Why CAS (Compare-And-Swap)?**  
Instead of **synchronized locks**, CAS ensures that:  
- **If the reference is still the same (no change by another thread), it updates the value.**  
- **If another thread modified it, retry until successful.**  
- **This makes operations faster and scalable in multi-threading.**  

---

## **6Ô∏è‚É£ Performance Analysis of ConcurrentLinkedQueue<T>**
| Operation | Complexity `O(n)` | Notes |
|-----------|----------------|-------|
| `add(E e)` | `O(1)` | Fast insert at the tail |
| `offer(E e)` | `O(1)` | Fast insert at the tail |
| `poll()` | `O(1)` | Fast removal from head |
| `peek()` | `O(1)` | Constant time retrieval |
| `size()` | `O(n)` | Not always accurate |

‚úîÔ∏è **Why use `ConcurrentLinkedQueue`?**  
- **No locking overhead (`synchronized`).**  
- **Scales better in high-concurrency environments.**  
- **Best for multi-threaded queue processing.**  

---

## **7Ô∏è‚É£ When to Use ConcurrentLinkedQueue?**
‚úîÔ∏è **Use `ConcurrentLinkedQueue<T>` when:**  
‚úÖ **Multiple threads need to access a queue concurrently.**  
‚úÖ **You want a non-blocking, lock-free queue.**  
‚úÖ **Elements should be processed in FIFO order.**  
‚úÖ **Performance is critical in a multi-threaded environment.**  

‚ùå **Don‚Äôt use `ConcurrentLinkedQueue<T>` when:**  
üö´ **You need blocking operations (use `BlockingQueue<T>` instead).**  
üö´ **You require precise `size()` calculation.**  

---

## **üìå Summary**
‚úîÔ∏è **ConcurrentLinkedQueue is a non-blocking, thread-safe queue.**  
‚úîÔ∏è **FIFO order is maintained.**  
‚úîÔ∏è **Uses CAS (Compare-And-Swap) for efficient updates.**  
‚úîÔ∏è **Faster than `BlockingQueue` in high-concurrency situations.**  
‚úîÔ∏è **Best for producer-consumer scenarios in multi-threading.**  

---

# üìå **Chapter 6: Map Interface (Key-Value Pair Collection) ‚Äì Deep Dive & Easy Explanation**  

---

## **1Ô∏è‚É£ What is `Map<K, V>` Interface?**
A **Map** is a data structure that **stores elements in key-value pairs**. Unlike `List` or `Set`, a `Map` does not store individual elements but rather a **mapping of keys to values**.

‚úîÔ∏è **Key Features of Map<K, V>:**  
- ‚úÖ **Stores data in the form of key-value pairs (`K ‚Üí V`).**  
- ‚úÖ **Each key is unique (no duplicates).**  
- ‚úÖ **Values can be duplicated.**  
- ‚úÖ **Efficient retrieval based on keys (`O(1)` for HashMap, `O(log n)` for TreeMap).**  
- ‚úÖ **Provides various implementations with different characteristics.**  

üìå **Real-Life Example of a Map:**  
A **dictionary** is a great example of a Map.  
- **Key** ‚Üí Word  
- **Value** ‚Üí Meaning  
Example:  
```
{"apple" ‚Üí "A fruit", "car" ‚Üí "A vehicle", "java" ‚Üí "A programming language"}
```
---

## **2Ô∏è‚É£ Why Use Map Over List/Set?**
| Feature | List | Set | Map |
|---------|------|-----|-----|
| Stores Elements | ‚úÖ Yes | ‚úÖ Yes | üö´ No (Stores Key-Value pairs) |
| Allows Duplicates | ‚úÖ Yes | üö´ No | üö´ No (Keys must be unique) |
| Ordered | ‚úÖ Yes (List is ordered) | ‚ùå No (HashSet is unordered) | ‚úÖ Depends on implementation |
| Fast Lookup | ‚ùå No (O(n) for search) | ‚ùå No (O(n) for search) | ‚úÖ Yes (O(1) for HashMap) |
| Key-Value Mapping | ‚ùå No | ‚ùå No | ‚úÖ Yes |

üìå **Use Map when:**  
‚úîÔ∏è You need **fast retrieval of values using keys**.  
‚úîÔ∏è You want **unique keys with associated values**.  
‚úîÔ∏è You require **efficient search and updates**.  

---

## **3Ô∏è‚É£ Map Interface ‚Äì Important Methods**
| Method | Description |
|--------|------------|
| `put(K key, V value)` | Adds a key-value pair to the map. |
| `get(K key)` | Retrieves the value associated with the key. |
| `remove(K key)` | Removes the key-value pair from the map. |
| `containsKey(K key)` | Checks if the key exists in the map. |
| `containsValue(V value)` | Checks if the value exists in the map. |
| `keySet()` | Returns a set of all keys. |
| `values()` | Returns a collection of all values. |
| `entrySet()` | Returns a set of all key-value pairs. |
| `size()` | Returns the number of key-value pairs in the map. |
| `isEmpty()` | Checks if the map is empty. |

---

## **4Ô∏è‚É£ Implementations of Map<K, V>**
| Implementation | Order | Thread-Safe | Null Keys Allowed? | Performance |
|---------------|------|-------------|----------------|-------------|
| `HashMap` | ‚ùå No Order | ‚ùå No | ‚úÖ Yes (Only one null key) | üöÄ Fast (O(1) for put/get) |
| `LinkedHashMap` | ‚úÖ Insertion Order | ‚ùå No | ‚úÖ Yes | üöÄ Fast (O(1) for put/get) |
| `TreeMap` | ‚úÖ Sorted Order | ‚ùå No | ‚ùå No | üê¢ Slower (O(log n) for put/get) |
| `Hashtable` | ‚ùå No Order | ‚úÖ Yes | ‚ùå No | üê¢ Slower (Thread-safe) |
| `ConcurrentHashMap` | ‚ùå No Order | ‚úÖ Yes | ‚ùå No | üöÄ Fast (Thread-safe, better than Hashtable) |

üìå **Choosing the Right Map:**  
- **If you need fast access:** ‚úÖ `HashMap`  
- **If you need insertion order:** ‚úÖ `LinkedHashMap`  
- **If you need sorted keys:** ‚úÖ `TreeMap`  
- **If you need thread safety:** ‚úÖ `ConcurrentHashMap`  

---

## **5Ô∏è‚É£ Basic Implementation of Map**
```java
import java.util.*;

public class MapExample {
    public static void main(String[] args) {
        // Creating a Map
        Map<String, Integer> map = new HashMap<>();

        // Adding key-value pairs
        map.put("Apple", 10);
        map.put("Banana", 20);
        map.put("Mango", 30);

        // Retrieving a value
        System.out.println("Value for 'Apple': " + map.get("Apple")); // 10

        // Checking key existence
        System.out.println("Contains 'Banana'? " + map.containsKey("Banana")); // true

        // Removing a key-value pair
        map.remove("Banana");

        // Iterating over the Map
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(entry.getKey() + " ‚Üí " + entry.getValue());
        }
    }
}
```

‚úîÔ∏è **Output:**
```
Value for 'Apple': 10
Contains 'Banana'? true
Apple ‚Üí 10
Mango ‚Üí 30
```

---

## **6Ô∏è‚É£ How Map Works Internally?**
### **üîπ Internal Working of `HashMap`**
- Uses a **hashing algorithm** to store key-value pairs.  
- **Keys are converted into hash codes**, which determine their storage location in an array.  
- **Collisions are handled using linked lists (before Java 8) or balanced trees (after Java 8 for large collisions).**  

üìå **Example Storage Mechanism (Hash Buckets)**
```
HashMap<K, V> Internal Structure:
Index | Key | Value
------|-----|------
0     | null | null
1     | "Apple" | 10
2     | "Banana" | 20
3     | "Mango" | 30
```

- When `map.put("Apple", 10);` is called:
  - `"Apple"` is **hashed**.
  - It is placed in the corresponding **bucket index**.
  - If another key hashes to the same index (collision), it is stored in a **linked list/tree at that index**.

---

## **7Ô∏è‚É£ Performance Analysis**
| Operation | HashMap | LinkedHashMap | TreeMap |
|-----------|--------|--------------|---------|
| `put(K, V)` | **O(1)** | **O(1)** | **O(log n)** |
| `get(K)` | **O(1)** | **O(1)** | **O(log n)** |
| `remove(K)` | **O(1)** | **O(1)** | **O(log n)** |
| `containsKey(K)` | **O(1)** | **O(1)** | **O(log n)** |

üìå **Why is `HashMap` faster than `TreeMap`?**  
- **`HashMap` uses direct indexing via hashing (`O(1)`)**.  
- **`TreeMap` uses a Red-Black tree for sorting (`O(log n)`)**, which is slower.  

---

## **8Ô∏è‚É£ When to Use Map<K, V>?**
‚úîÔ∏è **Use `HashMap` when:**  
‚úÖ Fast access (`O(1)`).  
‚úÖ No need to maintain order.  
‚úÖ Allows one `null` key.  

‚úîÔ∏è **Use `LinkedHashMap` when:**  
‚úÖ You need to maintain insertion order.  
‚úÖ Performance similar to `HashMap`.  

‚úîÔ∏è **Use `TreeMap` when:**  
‚úÖ You need sorted keys.  
‚úÖ `O(log n)` operations are acceptable.  

‚úîÔ∏è **Use `ConcurrentHashMap` when:**  
‚úÖ You need a thread-safe alternative.  
‚úÖ Better performance than `Hashtable`.  

---

## **üìå Summary**
‚úîÔ∏è **Map stores key-value pairs where keys are unique.**  
‚úîÔ∏è **Different implementations serve different use cases (`HashMap`, `TreeMap`, etc.).**  
‚úîÔ∏è **Performance varies based on use case (`O(1)` vs `O(log n)`).**  
‚úîÔ∏è **Choosing the right `Map` depends on order, thread safety, and lookup speed.**  

---

# üìå **Deep Dive into `HashMap<K, V>` (Easy & Detailed Explanation)**  

---

## **1Ô∏è‚É£ What is `HashMap<K, V>`?**
A `HashMap<K, V>` is a **key-value-based** data structure in Java that stores unique keys and their associated values. It is **unordered** and allows for **fast retrieval** of values using keys.

‚úîÔ∏è **Key Features of `HashMap<K, V>`**  
- ‚úÖ **Stores elements in key-value pairs (`K ‚Üí V`).**  
- ‚úÖ **Keys must be unique, but values can be duplicate.**  
- ‚úÖ **Allows one `null` key and multiple `null` values.**  
- ‚úÖ **Unordered (does not maintain insertion order).**  
- ‚úÖ **Uses hashing to store data for fast access (`O(1)` time complexity).**  
- ‚úÖ **Not thread-safe (use `ConcurrentHashMap` for multi-threading).**  

üìå **Example:**  
Imagine a **phonebook** where names (keys) are mapped to phone numbers (values).  
```
{ "Alice" ‚Üí 9876543210, "Bob" ‚Üí 8765432109, "Charlie" ‚Üí 7654321098 }
```
Here, names are **keys** (unique) and phone numbers are **values**.

---

## **2Ô∏è‚É£ Why Use `HashMap` Instead of List or Array?**
| Feature | Array | List | HashMap |
|---------|-------|------|---------|
| Stores Elements | ‚úÖ Yes | ‚úÖ Yes | üö´ No (Stores Key-Value) |
| Allows Duplicates | ‚úÖ Yes | ‚úÖ Yes | üö´ No (Keys are unique) |
| Ordered | ‚úÖ Yes (Array order) | ‚úÖ Yes (List order) | ‚ùå No (Unordered) |
| Fast Lookup | ‚ùå No (`O(n)`) | ‚ùå No (`O(n)`) | ‚úÖ Yes (`O(1)`) |
| Key-Value Mapping | ‚ùå No | ‚ùå No | ‚úÖ Yes |

üìå **Use `HashMap` when:**  
‚úîÔ∏è **You need fast lookups, insertions, and deletions (`O(1)`).**  
‚úîÔ∏è **You want a unique key for each value.**  
‚úîÔ∏è **You don‚Äôt care about ordering.**  

---

## **3Ô∏è‚É£ How `HashMap` Works Internally?**
`HashMap` uses **hashing** to store key-value pairs. It converts a key into a **hashcode** and determines its storage location (bucket) in an **array of nodes**.

### **üîπ Steps of `put(K, V)` Method:**
1. **Compute the Hash Code**  
   - Converts the key into a **hashcode** (unique number).  
   - Example: `"Apple".hashCode()` ‚Üí `2536478`

2. **Find the Bucket (Index Calculation)**  
   - Uses `hash % capacity` formula to find a storage index.  
   - Example: `2536478 % 16 = 6` ‚Üí Stored in bucket 6.

3. **Insert the Key-Value Pair**  
   - If the bucket is empty, store the pair.  
   - If a **collision** occurs (same bucket), use **Linked List** or **Balanced Tree** (from Java 8) to store multiple entries.

### **üîπ Steps of `get(K)` Method:**
1. **Compute the Hash Code of the Key.**  
2. **Find the Bucket Using Hashing Formula.**  
3. **Search for the Key in That Bucket.**  
4. **If Found, Return the Value; Otherwise, Return `null`.**  

üìå **Visual Representation of `HashMap` Storage:**
```
Bucket | Key    | Value  
-------------------------  
  0    | null  | null  
  1    | "Bob" | 8765432109  
  2    | null  | null  
  3    | "Alice" | 9876543210  
  4    | null  | null  
  5    | "Charlie" | 7654321098  
```

üîπ **Collision Handling:**  
If two keys produce the **same hash**, `HashMap` uses **Linked List or Balanced Tree** at that bucket index.

---

## **4Ô∏è‚É£ `HashMap` Constructors**
| Constructor | Description |
|------------|------------|
| `HashMap()` | Creates an empty HashMap with default size (16). |
| `HashMap(int capacity)` | Creates HashMap with given capacity. |
| `HashMap(int capacity, float loadFactor)` | Creates HashMap with capacity and load factor (default = 0.75). |
| `HashMap(Map<K, V> m)` | Creates HashMap with elements from another map. |

---

## **5Ô∏è‚É£ Important Methods of `HashMap`**
| Method | Description |
|--------|------------|
| `put(K key, V value)` | Adds a key-value pair to the map. |
| `get(K key)` | Retrieves the value for a key. |
| `remove(K key)` | Removes a key-value pair. |
| `containsKey(K key)` | Checks if a key exists. |
| `containsValue(V value)` | Checks if a value exists. |
| `keySet()` | Returns all keys as a `Set`. |
| `values()` | Returns all values as a `Collection`. |
| `entrySet()` | Returns all key-value pairs as a `Set`. |
| `size()` | Returns the number of key-value pairs. |
| `isEmpty()` | Checks if the map is empty. |

---

## **6Ô∏è‚É£ `HashMap` Example Code**
```java
import java.util.*;

public class HashMapExample {
    public static void main(String[] args) {
        // Creating a HashMap
        HashMap<String, Integer> map = new HashMap<>();

        // Adding elements (put method)
        map.put("Alice", 25);
        map.put("Bob", 30);
        map.put("Charlie", 28);

        // Retrieving values (get method)
        System.out.println("Age of Alice: " + map.get("Alice")); // 25

        // Checking if a key exists
        System.out.println("Contains 'Bob'? " + map.containsKey("Bob")); // true

        // Removing a key-value pair
        map.remove("Charlie");

        // Iterating through the HashMap
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(entry.getKey() + " ‚Üí " + entry.getValue());
        }
    }
}
```
‚úîÔ∏è **Output:**
```
Age of Alice: 25
Contains 'Bob'? true
Alice ‚Üí 25
Bob ‚Üí 30
```

---

## **7Ô∏è‚É£ Performance Analysis**
| Operation | Time Complexity |
|-----------|---------------|
| `put(K, V)` | **O(1)** (Best case) / **O(n)** (Worst case, collisions) |
| `get(K)` | **O(1)** (Best case) / **O(n)** (Worst case) |
| `remove(K)` | **O(1)** (Best case) / **O(n)** (Worst case) |
| `containsKey(K)` | **O(1)** |
| `containsValue(V)` | **O(n)** |

üìå **Why is `O(1)` lookup possible?**  
Because `HashMap` directly accesses the **bucket index** using **hashing**.

üìå **When does `O(n)` happen?**  
When **many keys have the same hashcode** (collisions), forcing a **linked list traversal**.

---

## **8Ô∏è‚É£ When to Use `HashMap<K, V>`?**
‚úîÔ∏è **When you need fast lookup (`O(1)`).**  
‚úîÔ∏è **When key order doesn‚Äôt matter.**  
‚úîÔ∏è **When you want one `null` key and multiple `null` values.**  

‚ùå **Avoid `HashMap` if:**  
- You need **ordered keys** (`Use LinkedHashMap`).  
- You need **sorted keys** (`Use TreeMap`).  
- You need **thread safety** (`Use ConcurrentHashMap`).  

---

## **üìå Summary**
‚úîÔ∏è **`HashMap<K, V>` stores key-value pairs using hashing.**  
‚úîÔ∏è **Keys must be unique, but values can be duplicated.**  
‚úîÔ∏è **Offers `O(1)` lookup time but may degrade to `O(n)` in case of collisions.**  
‚úîÔ∏è **Unordered (does not maintain insertion order).**  
‚úîÔ∏è **Used when fast retrieval of data is needed.**  

---

# üìå **Deep Dive into `LinkedHashMap<K, V>` (Easy & Detailed Explanation)**  

---

## **1Ô∏è‚É£ What is `LinkedHashMap<K, V>`?**
A `LinkedHashMap<K, V>` is a **key-value-based** data structure in Java that extends `HashMap<K, V>`, but **maintains insertion order**.

‚úîÔ∏è **Key Features of `LinkedHashMap<K, V>`**  
- ‚úÖ **Stores elements in key-value pairs (`K ‚Üí V`).**  
- ‚úÖ **Maintains insertion order (unlike `HashMap`).**  
- ‚úÖ **Uses a doubly linked list along with a hash table.**  
- ‚úÖ **Fast lookup and retrieval (`O(1)`).**  
- ‚úÖ **Allows one `null` key and multiple `null` values.**  
- ‚úÖ **Not thread-safe (use `Collections.synchronizedMap()` for thread safety).**  

üìå **Example:**  
Imagine an **attendance register** where names (keys) are mapped to attendance status (values).  
```
{ "Alice" ‚Üí Present, "Bob" ‚Üí Absent, "Charlie" ‚Üí Present }
```
Here, **insertion order is preserved**.

---

## **2Ô∏è‚É£ Difference Between `HashMap` and `LinkedHashMap`**
| Feature | HashMap | LinkedHashMap |
|---------|--------|---------------|
| Ordering | ‚ùå No (Unordered) | ‚úÖ Yes (Insertion Order) |
| Performance | ‚úÖ Fast (`O(1)`) | ‚úÖ Slightly Slower (`O(1)`) |
| Memory Usage | ‚úÖ Less | ‚ùå More (Extra Linked List) |
| Allows `null` Key | ‚úÖ Yes | ‚úÖ Yes |
| Thread-Safe | ‚ùå No | ‚ùå No |
| Use Case | Fast access, no order needed | Fast access, order matters |

üìå **Use `LinkedHashMap` when:**  
‚úîÔ∏è **You need fast lookups but also maintain order.**  
‚úîÔ∏è **You need predictable iteration order.**  
‚úîÔ∏è **You want a cache with access-ordering (LRU Cache).**  

---

## **3Ô∏è‚É£ How `LinkedHashMap` Works Internally?**
`LinkedHashMap` is built on top of `HashMap`, but it **maintains insertion order** using a **doubly linked list**.

### **üîπ How Entries Are Stored?**
- It maintains a **hash table** (like `HashMap`) for fast access.
- It also has a **doubly linked list** that keeps track of order.

üìå **Example:** Adding `"Alice" ‚Üí 25`, `"Bob" ‚Üí 30`, `"Charlie" ‚Üí 28`
```
Hash Table (Buckets) ‚Üí Fast Lookup
Bucket | Key     | Value  | Next (Linked List)
-------------------------------------------
  0    | null   | null   | null
  1    | "Alice" | 25     | Bob ‚Üí Charlie ‚Üí null (Doubly Linked List)
  2    | "Bob"   | 30     | Charlie ‚Üí null
  3    | "Charlie" | 28  | null
```
‚úîÔ∏è **Doubly Linked List ensures order is maintained!**  

---

## **4Ô∏è‚É£ `LinkedHashMap` Constructors**
| Constructor | Description |
|------------|-------------|
| `LinkedHashMap()` | Creates an empty LinkedHashMap with default size (16). |
| `LinkedHashMap(int capacity)` | Creates LinkedHashMap with given capacity. |
| `LinkedHashMap(int capacity, float loadFactor)` | Creates LinkedHashMap with capacity and load factor (default = 0.75). |
| `LinkedHashMap(int capacity, float loadFactor, boolean accessOrder)` | Creates LinkedHashMap with access-order (LRU cache). |

---

## **5Ô∏è‚É£ Important Methods of `LinkedHashMap`**
| Method | Description |
|--------|-------------|
| `put(K key, V value)` | Adds a key-value pair to the map. |
| `get(K key)` | Retrieves the value for a key. |
| `remove(K key)` | Removes a key-value pair. |
| `containsKey(K key)` | Checks if a key exists. |
| `containsValue(V value)` | Checks if a value exists. |
| `keySet()` | Returns all keys as a `Set`. |
| `values()` | Returns all values as a `Collection`. |
| `entrySet()` | Returns all key-value pairs as a `Set`. |
| `size()` | Returns the number of key-value pairs. |
| `isEmpty()` | Checks if the map is empty. |

---

## **6Ô∏è‚É£ `LinkedHashMap` Example Code**
```java
import java.util.*;

public class LinkedHashMapExample {
    public static void main(String[] args) {
        // Creating a LinkedHashMap
        LinkedHashMap<String, Integer> map = new LinkedHashMap<>();

        // Adding elements (put method)
        map.put("Alice", 25);
        map.put("Bob", 30);
        map.put("Charlie", 28);

        // Retrieving values (get method)
        System.out.println("Age of Alice: " + map.get("Alice")); // 25

        // Checking if a key exists
        System.out.println("Contains 'Bob'? " + map.containsKey("Bob")); // true

        // Removing a key-value pair
        map.remove("Charlie");

        // Iterating through the LinkedHashMap
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(entry.getKey() + " ‚Üí " + entry.getValue());
        }
    }
}
```
‚úîÔ∏è **Output:**
```
Age of Alice: 25
Contains 'Bob'? true
Alice ‚Üí 25
Bob ‚Üí 30
```
‚úîÔ∏è **Insertion order is maintained!**

---

## **7Ô∏è‚É£ Special Feature: Access Order (LRU Cache)**
By default, `LinkedHashMap` maintains **insertion order**, but we can use **access order** for caching (Least Recently Used - LRU Cache).

üìå **LRU Cache Example:**
```java
import java.util.*;

class LRUCache<K, V> extends LinkedHashMap<K, V> {
    private final int capacity;

    public LRUCache(int capacity) {
        super(capacity, 0.75f, true); // Access Order = true
        this.capacity = capacity;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
        return size() > capacity; // Remove oldest entry when full
    }
}

public class LRUExample {
    public static void main(String[] args) {
        LRUCache<Integer, String> cache = new LRUCache<>(3);

        cache.put(1, "A");
        cache.put(2, "B");
        cache.put(3, "C");

        // Access key 1, making it most recently used
        cache.get(1);

        // Adding new key, 2 should be removed (LRU policy)
        cache.put(4, "D");

        System.out.println(cache.keySet()); // Output: [3, 1, 4]
    }
}
```
‚úîÔ∏è **LRU Cache removes least used items!**

---

## **8Ô∏è‚É£ Performance Analysis**
| Operation | Time Complexity |
|-----------|---------------|
| `put(K, V)` | **O(1)** |
| `get(K)` | **O(1)** |
| `remove(K)` | **O(1)** |
| `containsKey(K)` | **O(1)** |
| `containsValue(V)` | **O(n)** |

üìå **Why does `O(1)` lookup happen?**  
Because `LinkedHashMap` uses **hashing** like `HashMap`.

üìå **When does `O(n)` happen?**  
When searching for a **specific value**, as all values must be checked.

---

## **9Ô∏è‚É£ When to Use `LinkedHashMap<K, V>`?**
‚úîÔ∏è **When you need insertion order.**  
‚úîÔ∏è **When you need fast lookup like `HashMap`.**  
‚úîÔ∏è **When you need an LRU cache.**  

‚ùå **Avoid `LinkedHashMap` if:**  
- You don‚Äôt care about ordering (`Use HashMap`).  
- You need sorted keys (`Use TreeMap`).  
- You need thread safety (`Use ConcurrentHashMap`).  

---

## **üìå Summary**
‚úîÔ∏è **`LinkedHashMap<K, V>` maintains insertion order.**  
‚úîÔ∏è **Fast lookup with `O(1)` complexity.**  
‚úîÔ∏è **Can be used as an LRU cache with access order.**  
‚úîÔ∏è **Uses extra memory for maintaining order.**  

---

# üìå **Deep Dive into `TreeMap<K, V>` (Easy & Detailed Explanation)**  

---

## **1Ô∏è‚É£ What is `TreeMap<K, V>`?**
A **`TreeMap<K, V>`** is a key-value collection in Java that **stores keys in sorted order** (ascending by default).  

‚úîÔ∏è **Key Features of `TreeMap<K, V>`**  
- ‚úÖ **Stores key-value pairs (`K ‚Üí V`).**  
- ‚úÖ **Maintains keys in sorted order (Natural or Custom Comparator).**  
- ‚úÖ **Implements `NavigableMap<K, V>` and `SortedMap<K, V>`.**  
- ‚úÖ **Uses a **Red-Black Tree** for self-balancing.**  
- ‚úÖ **Search, Insert, Delete in `O(log n)`.**  
- ‚úÖ **Does **NOT** allow `null` keys (unlike `HashMap`).**  
- ‚úÖ **Thread-Unsafe (Use `Collections.synchronizedMap()` for thread safety).**  

üìå **Example Use Case:**  
Imagine a **student ranking system** where we store students' scores and want to retrieve them in **sorted order** automatically.

---
## **2Ô∏è‚É£ Difference Between `HashMap`, `LinkedHashMap`, and `TreeMap`**
| Feature | HashMap | LinkedHashMap | TreeMap |
|---------|---------|--------------|---------|
| **Ordering** | ‚ùå No order | ‚úÖ Insertion Order | ‚úÖ Sorted Order (Ascending by default) |
| **Performance (Put, Get, Remove)** | ‚úÖ `O(1)` | ‚úÖ `O(1)` | ‚ùå `O(log n)` |
| **Implementation** | **Hash Table** | **Hash Table + Linked List** | **Red-Black Tree** |
| **Allows `null` Key** | ‚úÖ Yes | ‚úÖ Yes | ‚ùå No |
| **Memory Usage** | ‚úÖ Low | ‚ùå High (Linked List) | ‚ùå High (Tree Structure) |
| **Use Case** | Fast lookup | Order-preserving | Sorted Data |

üìå **Use `TreeMap<K, V>` when:**  
‚úîÔ∏è **You need keys to be sorted automatically.**  
‚úîÔ∏è **You need efficient range queries (`subMap`, `headMap`, `tailMap`).**  
‚úîÔ∏è **You need to maintain a priority-based ordering.**  

---
## **3Ô∏è‚É£ How `TreeMap` Works Internally?**
`TreeMap<K, V>` **uses a Red-Black Tree** for self-balancing.

### **üîπ How Data is Stored?**
- Unlike `HashMap`, `TreeMap` **stores elements in a sorted tree structure**.
- Each node contains:  
  - **Key (`K`)**  
  - **Value (`V`)**  
  - **Left Child (Smaller Keys)**  
  - **Right Child (Larger Keys)**  
- The tree is **balanced** using **Red-Black Tree** properties.

üìå **Example:**  
```java
TreeMap<Integer, String> map = new TreeMap<>();
map.put(50, "Alice");
map.put(30, "Bob");
map.put(70, "Charlie");
map.put(20, "David");
map.put(40, "Eve");
```
‚úîÔ∏è **Internally, the Red-Black Tree will arrange them as:**  
```
        50
       /   \
     30    70
    /  \
  20   40
```
‚úÖ **Keys are always sorted in ascending order!**  

---
## **4Ô∏è‚É£ `TreeMap` Constructors**
| Constructor | Description |
|------------|-------------|
| `TreeMap()` | Creates an empty `TreeMap` with natural ordering. |
| `TreeMap(Comparator<? super K> comparator)` | Creates `TreeMap` with a custom sorting order. |
| `TreeMap(Map<? extends K, ? extends V> map)` | Creates a `TreeMap` with the same elements as an existing map. |
| `TreeMap(SortedMap<K, ? extends V> sortedMap)` | Creates a `TreeMap` from another sorted map. |

---
## **5Ô∏è‚É£ Important Methods of `TreeMap<K, V>`**
| Method | Description |
|--------|-------------|
| `put(K key, V value)` | Adds a key-value pair to the map. |
| `get(K key)` | Retrieves the value for a key. |
| `remove(K key)` | Removes a key-value pair. |
| `containsKey(K key)` | Checks if a key exists. |
| `containsValue(V value)` | Checks if a value exists. |
| `size()` | Returns the number of key-value pairs. |
| `isEmpty()` | Checks if the map is empty. |
| `keySet()` | Returns all keys as a `Set`. |
| `values()` | Returns all values as a `Collection`. |
| `entrySet()` | Returns all key-value pairs as a `Set`. |
| `firstKey()` | Returns the smallest key. |
| `lastKey()` | Returns the largest key. |
| `higherKey(K key)` | Returns the smallest key greater than `key`. |
| `lowerKey(K key)` | Returns the largest key less than `key`. |
| `subMap(K fromKey, K toKey)` | Returns a portion of the map between `fromKey` and `toKey`. |

---
## **6Ô∏è‚É£ `TreeMap` Example Code**
```java
import java.util.*;

public class TreeMapExample {
    public static void main(String[] args) {
        // Creating a TreeMap
        TreeMap<Integer, String> map = new TreeMap<>();

        // Adding elements (put method)
        map.put(50, "Alice");
        map.put(30, "Bob");
        map.put(70, "Charlie");
        map.put(20, "David");
        map.put(40, "Eve");

        // Retrieving values (get method)
        System.out.println("Value of 50: " + map.get(50)); // Alice

        // Getting first and last key
        System.out.println("Smallest key: " + map.firstKey()); // 20
        System.out.println("Largest key: " + map.lastKey()); // 70

        // Iterating through TreeMap (Sorted Order)
        for (Map.Entry<Integer, String> entry : map.entrySet()) {
            System.out.println(entry.getKey() + " ‚Üí " + entry.getValue());
        }
    }
}
```
‚úîÔ∏è **Output:**
```
Value of 50: Alice
Smallest key: 20
Largest key: 70
20 ‚Üí David
30 ‚Üí Bob
40 ‚Üí Eve
50 ‚Üí Alice
70 ‚Üí Charlie
```
‚úîÔ∏è **Keys are sorted automatically!**

---
## **7Ô∏è‚É£ Custom Sorting with `TreeMap`**
We can pass a **custom comparator** to define our own sorting order.

üìå **Example: Sorting in Descending Order**
```java
import java.util.*;

public class TreeMapDescending {
    public static void main(String[] args) {
        // Custom comparator for descending order
        TreeMap<Integer, String> map = new TreeMap<>(Comparator.reverseOrder());

        map.put(50, "Alice");
        map.put(30, "Bob");
        map.put(70, "Charlie");

        System.out.println(map);
    }
}
```
‚úîÔ∏è **Output:**
```
{70=Charlie, 50=Alice, 30=Bob}
```
‚úîÔ∏è **Sorted in descending order!**

---
## **8Ô∏è‚É£ Performance Analysis**
| Operation | Time Complexity |
|-----------|---------------|
| `put(K, V)` | **O(log n)** |
| `get(K)` | **O(log n)** |
| `remove(K)` | **O(log n)** |
| `containsKey(K)` | **O(log n)** |
| `containsValue(V)` | **O(n)** |

üìå **Why `O(log n)`?**  
Because `TreeMap` is based on **Red-Black Tree**, a balanced tree structure.

---
## **9Ô∏è‚É£ When to Use `TreeMap<K, V>`?**
‚úîÔ∏è **When you need keys to be sorted automatically.**  
‚úîÔ∏è **When you need efficient range queries (`subMap`, `headMap`, `tailMap`).**  
‚úîÔ∏è **When maintaining order is crucial.**  

‚ùå **Avoid `TreeMap` if:**  
- You don‚Äôt need sorted order (`Use HashMap`).  
- Performance is a priority (`TreeMap` is slower than `HashMap`).  
- You need thread safety (`Use ConcurrentSkipListMap`).  

---
## **üìå Summary**
‚úîÔ∏è **`TreeMap<K, V>` maintains sorted order.**  
‚úîÔ∏è **Uses Red-Black Tree (`O(log n)` performance).**  
‚úîÔ∏è **Great for range queries (`subMap`, `headMap`, etc.).**  
‚úîÔ∏è **No `null` keys allowed!**  

---

# üìå **Deep Dive into `Hashtable<K, V>` (Easy & Detailed Explanation)**  

---

## **1Ô∏è‚É£ What is `Hashtable<K, V>`?**
A **`Hashtable<K, V>`** is a key-value data structure in Java that is **thread-safe** and does **not allow `null` keys or values**.

‚úîÔ∏è **Key Features of `Hashtable<K, V>`**  
- ‚úÖ **Stores key-value pairs (`K ‚Üí V`).**  
- ‚úÖ **Thread-Safe (Synchronized Methods).**  
- ‚úÖ **No `null` keys or values allowed.**  
- ‚úÖ **Uses a Hash Table for fast lookups (`O(1)` in most cases).**  
- ‚úÖ **Implemented using `synchronized` methods, making it slower than `HashMap`.**  
- ‚úÖ **Legacy class (Introduced in Java 1.0, before `HashMap`).**  

üìå **Example Use Case:**  
Imagine a **multi-threaded banking system** where we store customer account balances and need thread safety to avoid data corruption.

---
## **2Ô∏è‚É£ Difference Between `Hashtable`, `HashMap`, and `ConcurrentHashMap`**
| Feature | Hashtable | HashMap | ConcurrentHashMap |
|---------|---------|--------------|------------------|
| **Thread-Safe?** | ‚úÖ Yes | ‚ùå No | ‚úÖ Yes (Better Performance) |
| **Allows `null` Key?** | ‚ùå No | ‚úÖ Yes | ‚ùå No |
| **Allows `null` Values?** | ‚ùå No | ‚úÖ Yes | ‚ùå No |
| **Performance (Put, Get, Remove)** | ‚ùå Slow (Synchronized) | ‚úÖ Fast (`O(1)`) | ‚úÖ Fast (Lock-Free Reads) |
| **Iteration** | **Slow** (Locks Entire Table) | **Fast** (Uses `fail-fast` iterator) | **Fast** (Lock-Free Segments) |
| **Usage** | **Legacy, Avoid Using** | **Best for Single-Threaded Apps** | **Best for Multi-Threaded Apps** |

üìå **Use `Hashtable<K, V>` when:**  
‚úîÔ∏è **You need thread safety in older Java versions.**  
‚úîÔ∏è **You are maintaining legacy Java code.**  
‚úîÔ∏è **You cannot use `ConcurrentHashMap` (for some reason).**  

‚ùå **Avoid `Hashtable<K, V>` if:**  
- You don‚Äôt need thread safety (`Use HashMap`).  
- You need better performance (`Use ConcurrentHashMap`).  

---
## **3Ô∏è‚É£ How `Hashtable` Works Internally?**
`Hashtable<K, V>` **uses a hash table with synchronization** to store key-value pairs.

### **üîπ How Data is Stored?**
- Similar to `HashMap`, `Hashtable` **uses an array of "buckets"**.  
- Each bucket stores **key-value pairs** using **linked lists** (to handle collisions).  
- The **hash function** determines the bucket index for a key.
- If two keys have the same hash, they are stored in the same bucket **(chaining method)**.

üìå **Example:**  
```java
Hashtable<Integer, String> table = new Hashtable<>();
table.put(50, "Alice");
table.put(30, "Bob");
table.put(70, "Charlie");
table.put(20, "David");
table.put(40, "Eve");
```
‚úîÔ∏è **Internally, the Hashtable might look like this:**  
```
Bucket 0: (50 ‚Üí Alice)
Bucket 1: (30 ‚Üí Bob)
Bucket 2: (70 ‚Üí Charlie)
Bucket 3: (20 ‚Üí David)
Bucket 4: (40 ‚Üí Eve)
```
‚úÖ **Data is stored in hash buckets, ensuring fast lookup.**

---
## **4Ô∏è‚É£ `Hashtable` Constructors**
| Constructor | Description |
|------------|-------------|
| `Hashtable()` | Creates an empty `Hashtable` with default capacity. |
| `Hashtable(int initialCapacity)` | Creates a `Hashtable` with a specific capacity. |
| `Hashtable(int initialCapacity, float loadFactor)` | Creates a `Hashtable` with capacity and load factor. |
| `Hashtable(Map<? extends K, ? extends V> map)` | Creates a `Hashtable` from another map. |

---
## **5Ô∏è‚É£ Important Methods of `Hashtable<K, V>`**
| Method | Description |
|--------|-------------|
| `put(K key, V value)` | Adds a key-value pair to the table. |
| `get(K key)` | Retrieves the value for a key. |
| `remove(K key)` | Removes a key-value pair. |
| `containsKey(K key)` | Checks if a key exists. |
| `containsValue(V value)` | Checks if a value exists. |
| `size()` | Returns the number of key-value pairs. |
| `isEmpty()` | Checks if the table is empty. |
| `keySet()` | Returns all keys as a `Set`. |
| `values()` | Returns all values as a `Collection`. |
| `entrySet()` | Returns all key-value pairs as a `Set`. |
| `clone()` | Creates a copy of the `Hashtable`. |
| `clear()` | Removes all elements from the `Hashtable`. |

---
## **6Ô∏è‚É£ `Hashtable` Example Code**
```java
import java.util.*;

public class HashtableExample {
    public static void main(String[] args) {
        // Creating a Hashtable
        Hashtable<Integer, String> table = new Hashtable<>();

        // Adding elements (put method)
        table.put(50, "Alice");
        table.put(30, "Bob");
        table.put(70, "Charlie");
        table.put(20, "David");
        table.put(40, "Eve");

        // Retrieving values (get method)
        System.out.println("Value of 50: " + table.get(50)); // Alice

        // Checking if a key exists
        System.out.println("Contains key 30? " + table.containsKey(30)); // true

        // Iterating through Hashtable
        for (Map.Entry<Integer, String> entry : table.entrySet()) {
            System.out.println(entry.getKey() + " ‚Üí " + entry.getValue());
        }
    }
}
```
‚úîÔ∏è **Output:**
```
Value of 50: Alice
Contains key 30? true
20 ‚Üí David
30 ‚Üí Bob
40 ‚Üí Eve
50 ‚Üí Alice
70 ‚Üí Charlie
```
‚úîÔ∏è **Keys are stored in a hash table, not sorted!**

---
## **7Ô∏è‚É£ Thread-Safety in `Hashtable`**
Since `Hashtable` methods are **synchronized**, only **one thread** can access them at a time.

üìå **Example (Multiple Threads Using `Hashtable`)**
```java
import java.util.*;

public class HashtableThreadExample {
    public static void main(String[] args) {
        Hashtable<Integer, String> table = new Hashtable<>();

        // Thread 1 (Adding Data)
        Thread t1 = new Thread(() -> {
            table.put(1, "A");
            table.put(2, "B");
            table.put(3, "C");
        });

        // Thread 2 (Reading Data)
        Thread t2 = new Thread(() -> {
            System.out.println(table.get(1));
            System.out.println(table.get(2));
        });

        t1.start();
        t2.start();
    }
}
```
‚úîÔ∏è **`Hashtable` prevents data corruption by synchronizing access.**

---
## **8Ô∏è‚É£ Performance Analysis**
| Operation | Time Complexity |
|-----------|---------------|
| `put(K, V)` | **O(1)** (best case), **O(n)** (worst case - collisions) |
| `get(K)` | **O(1)** (best case), **O(n)** (worst case - collisions) |
| `remove(K)` | **O(1)** (best case), **O(n)** (worst case - collisions) |

üìå **Why Slower than `HashMap`?**  
- **Every method is synchronized** ‚Üí **More overhead** in multi-threaded environments.
- **Collisions can degrade performance** to `O(n)` in worst cases.

---
## **9Ô∏è‚É£ When to Use `Hashtable<K, V>`?**
‚úîÔ∏è **When you need thread safety in older Java versions.**  
‚úîÔ∏è **When working with legacy applications.**  
‚úîÔ∏è **When you don‚Äôt need `null` keys/values.**  

‚ùå **Avoid `Hashtable<K, V>` if:**  
- You need better performance (`Use ConcurrentHashMap`).  
- You need null keys or values (`Use HashMap`).  

---
## **üìå Summary**
‚úîÔ∏è **`Hashtable<K, V>` is thread-safe (`synchronized`).**  
‚úîÔ∏è **Uses a hash table (`O(1)` lookups in most cases).**  
‚úîÔ∏è **No `null` keys or values allowed.**  
‚úîÔ∏è **Slower than `HashMap` due to synchronization.**  

---

# üìå **Deep Dive into `ConcurrentHashMap<K, V>` (Easy & Detailed Explanation)**  

---

## **1Ô∏è‚É£ What is `ConcurrentHashMap<K, V>`?**
A **`ConcurrentHashMap<K, V>`** is an advanced **thread-safe** version of `HashMap` that allows **multiple threads** to read and write without blocking the entire map.

‚úîÔ∏è **Key Features of `ConcurrentHashMap<K, V>`**  
- ‚úÖ **Thread-Safe without using `synchronized` on the entire map.**  
- ‚úÖ **Faster than `Hashtable` (Uses Locking at Segment Level).**  
- ‚úÖ **No `null` keys or values allowed.**  
- ‚úÖ **Uses multiple "segments" (buckets) to allow concurrent operations.**  
- ‚úÖ **Best suited for multi-threaded environments.**  
- ‚úÖ **Improved performance over `Hashtable`.**  

üìå **Example Use Case:**  
Imagine a **real-time stock market system** where thousands of users update stock prices simultaneously. `ConcurrentHashMap` ensures efficient, thread-safe updates without performance bottlenecks.

---

## **2Ô∏è‚É£ Difference Between `HashMap`, `Hashtable`, and `ConcurrentHashMap`**
| Feature | `HashMap` | `Hashtable` | `ConcurrentHashMap` |
|---------|---------|--------------|------------------|
| **Thread-Safe?** | ‚ùå No | ‚úÖ Yes (Slow) | ‚úÖ Yes (Faster) |
| **Allows `null` Keys?** | ‚úÖ Yes | ‚ùå No | ‚ùå No |
| **Allows `null` Values?** | ‚úÖ Yes | ‚ùå No | ‚ùå No |
| **Performance (Put, Get, Remove)** | ‚úÖ Fast (`O(1)`) | ‚ùå Slow (Locks Entire Table) | ‚úÖ Fast (Segmented Locks) |
| **Usage** | Best for Single-Threaded Apps | Legacy (Avoid Using) | Best for Multi-Threaded Apps |

üìå **When to Use `ConcurrentHashMap`?**  
‚úîÔ∏è **When you need high-performance thread-safe operations.**  
‚úîÔ∏è **When multiple threads need to read and write simultaneously.**  
‚úîÔ∏è **When `HashMap` is not safe but `Hashtable` is too slow.**  

---

## **3Ô∏è‚É£ How `ConcurrentHashMap` Works Internally?**
Instead of locking the entire map (like `Hashtable`), `ConcurrentHashMap` **divides the map into segments (buckets)** and locks only the affected segment during updates.

### **üîπ How Data is Stored?**
- **Uses a bucket-based structure**, similar to `HashMap`.  
- **Each bucket (segment) is locked separately**, allowing multiple threads to access different buckets concurrently.  
- Uses **a special locking mechanism (CAS - Compare-And-Swap)** to ensure consistency without full table locking.  

üìå **Example:**  
```java
ConcurrentHashMap<Integer, String> map = new ConcurrentHashMap<>();
map.put(1, "Alice");
map.put(2, "Bob");
map.put(3, "Charlie");
```
‚úîÔ∏è **Internally, the map might look like this:**  
```
Bucket 0: (1 ‚Üí Alice)
Bucket 1: (2 ‚Üí Bob)
Bucket 2: (3 ‚Üí Charlie)
```
‚úÖ **Each bucket (segment) is locked individually, allowing faster access.**

---

## **4Ô∏è‚É£ `ConcurrentHashMap` Constructors**
| Constructor | Description |
|------------|-------------|
| `ConcurrentHashMap()` | Creates an empty map with default capacity. |
| `ConcurrentHashMap(int initialCapacity)` | Creates a map with a specific initial capacity. |
| `ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel)` | Creates a map with defined concurrency level. |
| `ConcurrentHashMap(Map<? extends K, ? extends V> map)` | Creates a `ConcurrentHashMap` from another map. |

---

## **5Ô∏è‚É£ Important Methods of `ConcurrentHashMap<K, V>`**
| Method | Description |
|--------|-------------|
| `put(K key, V value)` | Adds a key-value pair to the map. |
| `get(K key)` | Retrieves the value for a key. |
| `remove(K key)` | Removes a key-value pair. |
| `containsKey(K key)` | Checks if a key exists. |
| `containsValue(V value)` | Checks if a value exists. |
| `size()` | Returns the number of key-value pairs. |
| `isEmpty()` | Checks if the map is empty. |
| `keySet()` | Returns all keys as a `Set`. |
| `values()` | Returns all values as a `Collection`. |
| `entrySet()` | Returns all key-value pairs as a `Set`. |
| `replace(K key, V oldValue, V newValue)` | Replaces a value if the current value matches. |
| `computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction)` | Computes a value if the key is absent. |
| `computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction)` | Computes a new value if the key is present. |

---

## **6Ô∏è‚É£ `ConcurrentHashMap` Example Code**
```java
import java.util.concurrent.*;

public class ConcurrentHashMapExample {
    public static void main(String[] args) {
        // Creating a ConcurrentHashMap
        ConcurrentHashMap<Integer, String> map = new ConcurrentHashMap<>();

        // Adding elements (put method)
        map.put(1, "Alice");
        map.put(2, "Bob");
        map.put(3, "Charlie");

        // Retrieving values (get method)
        System.out.println("Value of 1: " + map.get(1)); // Alice

        // Checking if a key exists
        System.out.println("Contains key 2? " + map.containsKey(2)); // true

        // Iterating through ConcurrentHashMap
        for (ConcurrentHashMap.Entry<Integer, String> entry : map.entrySet()) {
            System.out.println(entry.getKey() + " ‚Üí " + entry.getValue());
        }
    }
}
```
‚úîÔ∏è **Output:**
```
Value of 1: Alice
Contains key 2? true
1 ‚Üí Alice
2 ‚Üí Bob
3 ‚Üí Charlie
```
‚úÖ **Supports fast, thread-safe operations without full map locking.**

---

## **7Ô∏è‚É£ Multi-Threading with `ConcurrentHashMap`**
Unlike `Hashtable`, `ConcurrentHashMap` **does not block the entire map for every operation**. Multiple threads can update different segments at the same time.

üìå **Example (Multiple Threads Using `ConcurrentHashMap`)**
```java
import java.util.concurrent.*;

public class ConcurrentHashMapThreadExample {
    public static void main(String[] args) {
        ConcurrentHashMap<Integer, String> map = new ConcurrentHashMap<>();

        // Thread 1 (Adding Data)
        Thread t1 = new Thread(() -> {
            map.put(1, "A");
            map.put(2, "B");
            map.put(3, "C");
        });

        // Thread 2 (Reading Data)
        Thread t2 = new Thread(() -> {
            System.out.println(map.get(1));
            System.out.println(map.get(2));
        });

        t1.start();
        t2.start();
    }
}
```
‚úîÔ∏è **Thread-safe operations without full map locking.**

---

## **8Ô∏è‚É£ Performance Analysis**
| Operation | Time Complexity |
|-----------|---------------|
| `put(K, V)` | **O(1)** (best case), **O(n)** (worst case - collisions) |
| `get(K)` | **O(1)** (best case), **O(n)** (worst case - collisions) |
| `remove(K)` | **O(1)** (best case), **O(n)** (worst case - collisions) |

üìå **Why Faster than `Hashtable`?**  
- **Does not lock the entire map.**  
- **Uses fine-grained segment locks.**  
- **Supports concurrent reads and writes.**  

---

## **9Ô∏è‚É£ When to Use `ConcurrentHashMap<K, V>`?**
‚úîÔ∏è **When you need high-performance thread-safe operations.**  
‚úîÔ∏è **When multiple threads need to read and write concurrently.**  
‚úîÔ∏è **When `HashMap` is not safe but `Hashtable` is too slow.**  

‚ùå **Avoid `ConcurrentHashMap<K, V>` if:**  
- You need `null` keys or values (`Use HashMap`).  
- You need strict synchronization (`Use Hashtable`).  

---

## **üìå Summary**
‚úîÔ∏è **`ConcurrentHashMap<K, V>` is thread-safe (`Segmented Locking`).**  
‚úîÔ∏è **Uses hash buckets (`O(1)` lookups in most cases).**  
‚úîÔ∏è **No `null` keys or values allowed.**  
‚úîÔ∏è **Faster than `Hashtable` due to better concurrency.**  

---

# üìå **Deep Dive into `WeakHashMap<K, V>` (Easy & Detailed Explanation)**  

---

## **1Ô∏è‚É£ What is `WeakHashMap<K, V>`?**  
A **`WeakHashMap<K, V>`** is a special type of `Map` that **automatically removes entries** when their keys are no longer **strongly referenced** anywhere in the application.  

### **‚úîÔ∏è Key Features of `WeakHashMap<K, V>`**
- ‚úÖ **Uses weak references for keys**, meaning **entries can be garbage collected (GC) automatically**.
- ‚úÖ **Prevents memory leaks** by allowing garbage collection to remove unused keys.
- ‚úÖ **Best suited for caching mechanisms** where keys can be discarded when not in use.
- ‚úÖ **Works similarly to `HashMap`, but with weak keys.**

üìå **Example Use Case:**  
Imagine a **cache system** that stores temporary data. If an object (key) is no longer needed in memory, it should be automatically removed from the cache. `WeakHashMap` helps in this case by removing the entry when the key is no longer referenced elsewhere.

---

## **2Ô∏è‚É£ Difference Between `HashMap`, `Hashtable`, `ConcurrentHashMap`, and `WeakHashMap`**
| Feature | `HashMap` | `Hashtable` | `ConcurrentHashMap` | `WeakHashMap` |
|---------|----------|------------|--------------------|--------------|
| **Thread-Safe?** | ‚ùå No | ‚úÖ Yes (Synchronized) | ‚úÖ Yes (Segmented Locking) | ‚ùå No |
| **Garbage Collection Aware?** | ‚ùå No | ‚ùå No | ‚ùå No | ‚úÖ Yes (Removes Unused Keys) |
| **Allows `null` Keys?** | ‚úÖ Yes | ‚ùå No | ‚ùå No | ‚úÖ Yes |
| **Allows `null` Values?** | ‚úÖ Yes | ‚ùå No | ‚ùå No | ‚úÖ Yes |
| **Performance** | ‚úÖ Fast (`O(1)`) | ‚ùå Slow (Full Locking) | ‚úÖ Fast (Concurrent Access) | ‚úÖ Fast (`O(1)`) |
| **When to Use?** | General Purpose Map | Thread-Safe, but slow | High-Performance Thread-Safe Map | Auto-removing keys (cache, temporary data) |

üìå **When to Use `WeakHashMap`?**  
‚úîÔ∏è **For caching mechanisms** where objects should be automatically removed when no longer needed.  
‚úîÔ∏è **When preventing memory leaks** by ensuring unused keys do not remain in memory.  
‚úîÔ∏è **When you need a `Map<K, V>` but want automatic cleanup of unused keys.**  

---

## **3Ô∏è‚É£ How `WeakHashMap` Works Internally?**
Instead of using **strong references**, `WeakHashMap` **uses weak references for its keys**.  

### **üîπ What is a Weak Reference?**
- Normally, Java objects are referenced **strongly**‚Äîthey remain in memory until no reference exists.  
- **Weak references** allow objects to be garbage collected even when still in the `WeakHashMap`.  

üìå **Example:**  
```java
import java.util.*;

public class WeakHashMapExample {
    public static void main(String[] args) {
        Map<Object, String> map = new WeakHashMap<>();

        Object key1 = new String("key1");  // Weak reference key
        Object key2 = new String("key2");

        map.put(key1, "Value 1");
        map.put(key2, "Value 2");

        System.out.println("Before GC: " + map);

        // Remove strong references to keys
        key1 = null;
        key2 = null;

        // Call garbage collector
        System.gc();

        // Wait for GC to complete
        try { Thread.sleep(2000); } catch (InterruptedException e) {}

        System.out.println("After GC: " + map);
    }
}
```
‚úîÔ∏è **Output (Example, may vary depending on GC execution):**
```
Before GC: {key1=Value 1, key2=Value 2}
After GC: {}
```
‚úÖ **The keys were garbage collected, so the map became empty!**  

---

## **4Ô∏è‚É£ `WeakHashMap` Constructors**
| Constructor | Description |
|------------|-------------|
| `WeakHashMap()` | Creates an empty `WeakHashMap`. |
| `WeakHashMap(int initialCapacity)` | Creates a `WeakHashMap` with a specified capacity. |
| `WeakHashMap(int initialCapacity, float loadFactor)` | Creates a `WeakHashMap` with a specified capacity and load factor. |
| `WeakHashMap(Map<? extends K, ? extends V> m)` | Creates a `WeakHashMap` from an existing map. |

---

## **5Ô∏è‚É£ Important Methods of `WeakHashMap<K, V>`**
| Method | Description |
|--------|-------------|
| `put(K key, V value)` | Adds a key-value pair to the map. |
| `get(K key)` | Retrieves the value for a key. |
| `remove(K key)` | Removes a key-value pair. |
| `containsKey(K key)` | Checks if a key exists. |
| `containsValue(V value)` | Checks if a value exists. |
| `size()` | Returns the number of key-value pairs. |
| `isEmpty()` | Checks if the map is empty. |
| `keySet()` | Returns all keys as a `Set`. |
| `values()` | Returns all values as a `Collection`. |
| `entrySet()` | Returns all key-value pairs as a `Set`. |

---

## **6Ô∏è‚É£ `WeakHashMap` Example Code**
```java
import java.util.WeakHashMap;

public class WeakHashMapDemo {
    public static void main(String[] args) {
        WeakHashMap<String, String> map = new WeakHashMap<>();

        String key1 = new String("User1");
        String key2 = new String("User2");

        map.put(key1, "Alice");
        map.put(key2, "Bob");

        System.out.println("Before GC: " + map);

        key1 = null; // Removing strong reference

        System.gc(); // Request Garbage Collection

        try { Thread.sleep(2000); } catch (InterruptedException e) {}

        System.out.println("After GC: " + map);
    }
}
```
‚úîÔ∏è **Output (May vary depending on GC execution):**
```
Before GC: {User1=Alice, User2=Bob}
After GC: {User2=Bob}
```
‚úÖ **Only `User1` was garbage collected because we removed its reference!**

---

## **7Ô∏è‚É£ Performance Analysis**
| Operation | Time Complexity |
|-----------|---------------|
| `put(K, V)` | **O(1)** (best case), **O(n)** (worst case - hash collisions) |
| `get(K)` | **O(1)** (best case), **O(n)** (worst case - hash collisions) |
| `remove(K)` | **O(1)** (best case), **O(n)** (worst case - hash collisions) |

üìå **Why `WeakHashMap` is Useful?**
- Prevents **memory leaks** by automatically removing unused keys.  
- Ideal for **caching and temporary storage**.  

---

## **8Ô∏è‚É£ When to Use `WeakHashMap<K, V>`?**
‚úîÔ∏è **When you want automatic cleanup of unused keys.**  
‚úîÔ∏è **When storing temporary/cache data that should be removed when not needed.**  
‚úîÔ∏è **When you need a `Map<K, V>` that does not block garbage collection.**  

‚ùå **Avoid `WeakHashMap<K, V>` if:**  
- You need strong references (Use `HashMap` instead).  
- You need a thread-safe map (`Use ConcurrentHashMap`).  

---

## **üìå Summary**
‚úîÔ∏è **`WeakHashMap<K, V>` is a special `Map` that automatically removes unused keys.**  
‚úîÔ∏è **Uses weak references, so keys are garbage collected when not strongly referenced.**  
‚úîÔ∏è **Best for caching and temporary data storage.**  
‚úîÔ∏è **Not thread-safe, but faster than `Hashtable`.**  

---

# üìå **Deep Dive into `IdentityHashMap<K, V>` (Easy & Detailed Explanation)**  

---

## **1Ô∏è‚É£ What is `IdentityHashMap<K, V>`?**  
`IdentityHashMap<K, V>` is a special type of `Map<K, V>` in Java that **compares keys using reference equality (`==`) instead of object equality (`equals()`).**  

### **‚úîÔ∏è Key Features of `IdentityHashMap<K, V>`**
- ‚úÖ **Uses `==` instead of `equals()` for comparing keys.**
- ‚úÖ **Allows duplicate keys if they are different objects (`new String("A")` ‚â† `new String("A")`).**
- ‚úÖ **Not thread-safe (like `HashMap`).**
- ‚úÖ **Does not maintain insertion order (like `HashMap`).**
- ‚úÖ **Faster than `HashMap` because it avoids extra hash computations.**

üìå **Example Use Case:**  
Imagine you need to **store unique objects based on memory references, not content**‚Äîfor example, when handling proxies, caches, or serialization where object identity matters.

---

## **2Ô∏è‚É£ Difference Between `HashMap`, `WeakHashMap`, and `IdentityHashMap`**
| Feature | `HashMap<K, V>` | `WeakHashMap<K, V>` | `IdentityHashMap<K, V>` |
|---------|---------------|----------------|-------------------|
| **Key Comparison** | Uses `equals()` | Uses `equals()` | Uses `==` (Reference) |
| **Garbage Collection Aware?** | ‚ùå No | ‚úÖ Yes | ‚ùå No |
| **Allows `null` Keys?** | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes |
| **Thread-Safe?** | ‚ùå No | ‚ùå No | ‚ùå No |
| **Performance** | **O(1)** (Best case) | **O(1)** (Best case) | **O(1)** (Best case) |
| **When to Use?** | General Purpose Map | Auto-removing keys (caching) | Object Identity-Based Mapping |

üìå **When to Use `IdentityHashMap`?**  
‚úîÔ∏è **When you want different instances of the same object to be treated as different keys.**  
‚úîÔ∏è **When handling proxies, serialization, or tracking object identity.**  
‚úîÔ∏è **When performance is important (faster lookup due to `==` comparison).**

---

## **3Ô∏è‚É£ How `IdentityHashMap<K, V>` Works Internally?**
Unlike `HashMap`, which uses **hash codes and `equals()`**, `IdentityHashMap` uses **memory references (`==`)** for key comparison.

üìå **Example:**  
```java
import java.util.IdentityHashMap;

public class IdentityHashMapExample {
    public static void main(String[] args) {
        IdentityHashMap<String, Integer> map = new IdentityHashMap<>();

        String key1 = new String("A"); // Different Object
        String key2 = new String("A"); // Different Object

        map.put(key1, 1);
        map.put(key2, 2); // Different object, so it will be added separately

        System.out.println("Map Size: " + map.size()); // Output: 2
        System.out.println("Map: " + map);
    }
}
```
‚úÖ **Output:**
```
Map Size: 2
Map: {A=1, A=2}
```
‚úîÔ∏è Unlike `HashMap`, **both `"A"` keys are treated as different because they are different objects in memory.**

---

## **4Ô∏è‚É£ `IdentityHashMap` Constructors**
| Constructor | Description |
|------------|-------------|
| `IdentityHashMap()` | Creates an empty `IdentityHashMap`. |
| `IdentityHashMap(int expectedSize)` | Creates an `IdentityHashMap` with an expected size. |
| `IdentityHashMap(Map<? extends K, ? extends V> m)` | Creates an `IdentityHashMap` from an existing map. |

---

## **5Ô∏è‚É£ Important Methods of `IdentityHashMap<K, V>`**
| Method | Description |
|--------|-------------|
| `put(K key, V value)` | Adds a key-value pair to the map. |
| `get(K key)` | Retrieves the value for a key. |
| `remove(K key)` | Removes a key-value pair. |
| `containsKey(K key)` | Checks if a key exists. |
| `containsValue(V value)` | Checks if a value exists. |
| `size()` | Returns the number of key-value pairs. |
| `isEmpty()` | Checks if the map is empty. |
| `keySet()` | Returns all keys as a `Set`. |
| `values()` | Returns all values as a `Collection`. |
| `entrySet()` | Returns all key-value pairs as a `Set`. |

---

## **6Ô∏è‚É£ `IdentityHashMap` Example Code**
```java
import java.util.IdentityHashMap;

public class IdentityHashMapDemo {
    public static void main(String[] args) {
        IdentityHashMap<Integer, String> map = new IdentityHashMap<>();

        Integer key1 = new Integer(10);
        Integer key2 = new Integer(10);

        map.put(key1, "Value 1");
        map.put(key2, "Value 2"); // Treated as different keys

        System.out.println("Map Size: " + map.size());
        System.out.println("Map: " + map);
    }
}
```
‚úîÔ∏è **Output:**
```
Map Size: 2
Map: {10=Value 1, 10=Value 2}
```
‚úÖ **Both `10` keys are treated as different objects because they are different instances.**

---

## **7Ô∏è‚É£ Performance Analysis**
| Operation | Time Complexity |
|-----------|---------------|
| `put(K, V)` | **O(1)** (best case), **O(n)** (worst case - hash collisions) |
| `get(K)` | **O(1)** (best case), **O(n)** (worst case - hash collisions) |
| `remove(K)` | **O(1)** (best case), **O(n)** (worst case - hash collisions) |

üìå **Why `IdentityHashMap` is Useful?**
- üöÄ **Faster than `HashMap` because it avoids hash computation overhead.**
- üöÄ **Useful when object identity matters instead of content comparison.**

---

## **8Ô∏è‚É£ When to Use `IdentityHashMap<K, V>`?**
‚úîÔ∏è **When object identity (`==`) matters, not content comparison (`equals()`).**  
‚úîÔ∏è **When you need to distinguish between different object instances of the same value.**  
‚úîÔ∏è **When performance is critical, and avoiding hash computations speeds up the program.**  

‚ùå **Avoid `IdentityHashMap<K, V>` if:**  
- You need keys to be compared based on content (`equals()`).  
- You need a thread-safe map (`Use ConcurrentHashMap`).  

---

## **üìå Summary**
‚úîÔ∏è **`IdentityHashMap<K, V>` is a `Map` that compares keys using reference equality (`==`) instead of `equals()`.**  
‚úîÔ∏è **Allows duplicate-looking keys if they are different objects in memory.**  
‚úîÔ∏è **Faster than `HashMap` for specific use cases.**  
‚úîÔ∏è **Not thread-safe, does not maintain insertion order.**  
‚úîÔ∏è **Useful for object identity tracking, serialization, caching.**  

---
# üìå **Chapter 7: Comparators and Sorting in Collections (Easy & Deep Explanation)**  

Sorting is a crucial part of working with collections in Java. Java provides two key interfaces to handle sorting:  
1Ô∏è‚É£ **`Comparable<T>`** (Natural Sorting)  
2Ô∏è‚É£ **`Comparator<T>`** (Custom Sorting)  

---

## **1Ô∏è‚É£ Why Do We Need Sorting in Java Collections?**  

Sorting helps in:  
‚úîÔ∏è **Quickly searching elements** in a large dataset.  
‚úîÔ∏è **Efficient data processing** by ordering records logically.  
‚úîÔ∏è **Enhancing performance** in searching algorithms like binary search.  
‚úîÔ∏è **Organizing user data** (e.g., sorting students by marks, sorting products by price).  

üí° Java provides two main ways to sort collections:  
- **Natural Sorting** (`Comparable<T>`)  
- **Custom Sorting** (`Comparator<T>`)

---

## **2Ô∏è‚É£ How Sorting Works in Java Collections?**  
Java collections can be sorted using:  
1Ô∏è‚É£ **`Collections.sort(list)`** ‚Üí Sorts a `List` using natural ordering (must implement `Comparable<T>`).  
2Ô∏è‚É£ **`Collections.sort(list, comparator)`** ‚Üí Sorts a `List` using a `Comparator<T>` for custom ordering.  
3Ô∏è‚É£ **`TreeSet<T>` and `TreeMap<K, V>`** ‚Üí Automatically sort elements based on natural ordering or a custom comparator.  

---

## **3Ô∏è‚É£ Understanding `Comparable<T>` and `Comparator<T>` (Key Differences)**  

| Feature | `Comparable<T>` | `Comparator<T>` |
|---------|---------------|----------------|
| **Purpose** | Defines **natural sorting order** of an object. | Defines **custom sorting order** for objects. |
| **Method Used** | `compareTo(T o)` | `compare(T o1, T o2)` |
| **Where to Implement?** | Implemented **inside the class** being sorted. | Implemented in a **separate class** or using lambda functions. |
| **Modifies Original Class?** | ‚úÖ Yes, class must implement `Comparable<T>`. | ‚ùå No, sorting logic is external. |
| **Sorts By** | Single field (e.g., sorting students by marks). | Multiple fields (e.g., sorting students by name and then marks). |
| **Used In** | `TreeSet`, `TreeMap`, `Collections.sort()`. | `Collections.sort()`, `TreeSet`, `TreeMap`. |

‚úÖ **Use `Comparable<T>`** when the class has a **single natural sorting order** (e.g., sorting employees by salary).  
‚úÖ **Use `Comparator<T>`** when sorting should be **flexible** (e.g., sorting employees by salary or by age).  

---

## **4Ô∏è‚É£ Sorting Lists, Sets, and Maps in Java**
Sorting can be applied to different collections:

### ‚úÖ **Sorting a `List<T>`**
- `Collections.sort(List<T>)` ‚Üí Uses `Comparable<T>`  
- `Collections.sort(List<T>, Comparator<T>)` ‚Üí Uses `Comparator<T>`  

### ‚úÖ **Sorting a `Set<T>`**
- `TreeSet<T>` automatically sorts elements based on `Comparable<T>` or `Comparator<T>`.

### ‚úÖ **Sorting a `Map<K, V>`**
- `TreeMap<K, V>` automatically sorts based on `Comparable<K>` or `Comparator<K>`.  
- `LinkedHashMap<K, V>` maintains **insertion order**, not sorting.  
- `HashMap<K, V>` does **not** sort keys or values.

---

# **üìå Deep Dive into `Comparable<T>` (Natural Sorting) (Easy Explanation)**  

## **1Ô∏è‚É£ What is `Comparable<T>`?**  

‚úÖ `Comparable<T>` is an interface in Java used for **natural sorting** of objects.  
‚úÖ It allows a class to define its own **default sorting order**.  
‚úÖ It provides the **`compareTo(T o)`** method to define sorting logic.  

---

## **2Ô∏è‚É£ Why Do We Need `Comparable<T>`?**  

Imagine we have a list of **students**, and we want to sort them by their **marks**.  
Without `Comparable<T>`, Java **does not know** how to compare student objects.  
By implementing `Comparable<T>`, we can **tell Java** how to compare them (e.g., highest marks first).  

---

## **3Ô∏è‚É£ How to Use `Comparable<T>`?**  

**Steps to Implement `Comparable<T>`**:  
1Ô∏è‚É£ **Make the class implement `Comparable<T>`**.  
2Ô∏è‚É£ **Override the `compareTo(T o)` method**.  
3Ô∏è‚É£ **Define sorting logic inside `compareTo`**.  
4Ô∏è‚É£ **Use `Collections.sort(List<T>)` to sort the list**.

---

## **4Ô∏è‚É£ Example: Sorting Students by Marks (Ascending Order)**  

```java
import java.util.*;

class Student implements Comparable<Student> {
    int id;
    String name;
    int marks;

    // Constructor
    public Student(int id, String name, int marks) {
        this.id = id;
        this.name = name;
        this.marks = marks;
    }

    // Implement compareTo method (Natural Sorting)
    @Override
    public int compareTo(Student other) {
        return this.marks - other.marks; // Sorting by marks (Ascending Order)
    }

    // Display method
    public String toString() {
        return "Student{" + "ID=" + id + ", Name='" + name + "', Marks=" + marks + '}';
    }
}

public class ComparableExample {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student(101, "Alice", 85));
        students.add(new Student(102, "Bob", 72));
        students.add(new Student(103, "Charlie", 90));

        System.out.println("Before Sorting:");
        System.out.println(students);

        // Sorting using Collections.sort() (Natural Order)
        Collections.sort(students);

        System.out.println("\nAfter Sorting:");
        System.out.println(students);
    }
}
```

### **üîπ Output:**
```
Before Sorting:
[Student{ID=101, Name='Alice', Marks=85}, Student{ID=102, Name='Bob', Marks=72}, Student{ID=103, Name='Charlie', Marks=90}]

After Sorting:
[Student{ID=102, Name='Bob', Marks=72}, Student{ID=101, Name='Alice', Marks=85}, Student{ID=103, Name='Charlie', Marks=90}]
```

‚úîÔ∏è **Explanation:**  
- We implemented `Comparable<Student>`.  
- The `compareTo` method **sorts students by marks in ascending order**.  
- `Collections.sort(students)` **sorts the list based on `compareTo` method**.  

---

## **5Ô∏è‚É£ Changing Sorting Order (Descending Order)**  

By default, `compareTo` sorts in **ascending order**.  
To sort in **descending order**, modify `compareTo`:

```java
@Override
public int compareTo(Student other) {
    return other.marks - this.marks; // Sorting by marks (Descending Order)
}
```

Now, the highest marks will come first.

---

## **6Ô∏è‚É£ Sorting Objects with Multiple Fields**  

We can modify `compareTo` to sort by **multiple criteria**.

### **Example: Sorting by Marks, then by Name (if Marks are Equal)**  

```java
@Override
public int compareTo(Student other) {
    if (this.marks == other.marks) {
        return this.name.compareTo(other.name); // Sort by Name (Alphabetical Order)
    }
    return other.marks - this.marks; // Sort by Marks (Descending Order)
}
```

‚úîÔ∏è **Now students with the same marks will be sorted alphabetically.**  

---

## **7Ô∏è‚É£ Key Points About `Comparable<T>`**  

‚úîÔ∏è Used for **natural sorting** (default order).  
‚úîÔ∏è We **must modify the original class** (implements `Comparable<T>`).  
‚úîÔ∏è Sorting logic is defined in **`compareTo(T o)` method**.  
‚úîÔ∏è Used in `TreeSet<T>`, `TreeMap<K, V>`, and `Collections.sort(List<T>)`.  
‚úîÔ∏è **Only one sorting order is possible per class.**  

---

# **üìå Deep Dive into `Comparator<T>` (Custom Sorting) (Easy Explanation)**  

## **1Ô∏è‚É£ What is `Comparator<T>`?**  

‚úÖ `Comparator<T>` is an interface used to **define custom sorting logic** for objects.  
‚úÖ It allows **multiple sorting orders** without modifying the original class.  
‚úÖ It provides the **`compare(T o1, T o2)`** method to define sorting logic.  

---

## **2Ô∏è‚É£ Why Do We Need `Comparator<T>`?**  

Imagine we have a list of **students** and we want to sort them in different ways:  
‚úîÔ∏è By **marks** (highest to lowest).  
‚úîÔ∏è By **name** (alphabetical order).  
‚úîÔ∏è By **ID** (ascending order).  

If we use `Comparable<T>`, we can **only define one sorting order** inside the class.  
But with `Comparator<T>`, we can define **multiple sorting orders externally**.  

---

## **3Ô∏è‚É£ How to Use `Comparator<T>`?**  

**Steps to Implement `Comparator<T>`:**  
1Ô∏è‚É£ **Create a separate class** that implements `Comparator<T>`.  
2Ô∏è‚É£ **Override the `compare(T o1, T o2)` method**.  
3Ô∏è‚É£ **Use `Collections.sort(List<T>, Comparator<T>)`** to sort the list.

---

## **4Ô∏è‚É£ Example: Sorting Students by Marks (Descending Order)**  

```java
import java.util.*;

class Student {
    int id;
    String name;
    int marks;

    public Student(int id, String name, int marks) {
        this.id = id;
        this.name = name;
        this.marks = marks;
    }

    public String toString() {
        return "Student{" + "ID=" + id + ", Name='" + name + "', Marks=" + marks + '}';
    }
}

// Custom Comparator for sorting by Marks (Descending Order)
class SortByMarks implements Comparator<Student> {
    @Override
    public int compare(Student s1, Student s2) {
        return s2.marks - s1.marks; // Highest marks first
    }
}

public class ComparatorExample {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student(101, "Alice", 85));
        students.add(new Student(102, "Bob", 72));
        students.add(new Student(103, "Charlie", 90));

        System.out.println("Before Sorting:");
        System.out.println(students);

        // Sorting using Comparator
        Collections.sort(students, new SortByMarks());

        System.out.println("\nAfter Sorting (By Marks Descending):");
        System.out.println(students);
    }
}
```

### **üîπ Output:**
```
Before Sorting:
[Student{ID=101, Name='Alice', Marks=85}, Student{ID=102, Name='Bob', Marks=72}, Student{ID=103, Name='Charlie', Marks=90}]

After Sorting (By Marks Descending):
[Student{ID=103, Name='Charlie', Marks=90}, Student{ID=101, Name='Alice', Marks=85}, Student{ID=102, Name='Bob', Marks=72}]
```

‚úîÔ∏è **Explanation:**  
- We created a **separate class** `SortByMarks` that implements `Comparator<Student>`.  
- The `compare` method sorts students **by marks in descending order**.  
- We passed `new SortByMarks()` to `Collections.sort()` for sorting.

---

## **5Ô∏è‚É£ Sorting Students by Name (Alphabetical Order)**  

We can create another **custom comparator** for sorting by name.

```java
// Custom Comparator for sorting by Name (Alphabetical Order)
class SortByName implements Comparator<Student> {
    @Override
    public int compare(Student s1, Student s2) {
        return s1.name.compareTo(s2.name); // A to Z order
    }
}
```

Now, we can sort by name:

```java
Collections.sort(students, new SortByName());
```

‚úîÔ∏è Now students will be sorted in **alphabetical order by name**.

---

## **6Ô∏è‚É£ Sorting by Multiple Fields**  

What if **marks are equal**?  
We can **first sort by marks**, and if they are the same, **sort by name**.

```java
class SortByMarksThenName implements Comparator<Student> {
    @Override
    public int compare(Student s1, Student s2) {
        if (s1.marks == s2.marks) {
            return s1.name.compareTo(s2.name); // Sort by Name (Alphabetical)
        }
        return s2.marks - s1.marks; // Sort by Marks (Descending)
    }
}
```

Now, we can sort students:

```java
Collections.sort(students, new SortByMarksThenName());
```

‚úîÔ∏è If two students have the **same marks**, they will be sorted **alphabetically by name**.

---

## **7Ô∏è‚É£ Using Lambda Expressions for Comparator**  

Instead of creating separate classes, we can use **lambda expressions**.

### **Sorting by Marks (Descending) Using Lambda**
```java
Collections.sort(students, (s1, s2) -> s2.marks - s1.marks);
```

### **Sorting by Name (Alphabetical) Using Lambda**
```java
Collections.sort(students, (s1, s2) -> s1.name.compareTo(s2.name));
```

üí° **Lambda makes sorting more readable and concise**.

---

## **8Ô∏è‚É£ Key Differences: `Comparable<T>` vs `Comparator<T>`**  

| Feature | `Comparable<T>` | `Comparator<T>` |
|---------|---------------|----------------|
| **Purpose** | Defines **natural sorting order** of an object. | Defines **custom sorting order** for objects. |
| **Method Used** | `compareTo(T o)` | `compare(T o1, T o2)` |
| **Where to Implement?** | Implemented **inside the class** being sorted. | Implemented in a **separate class** or using lambda functions. |
| **Modifies Original Class?** | ‚úÖ Yes, class must implement `Comparable<T>`. | ‚ùå No, sorting logic is external. |
| **Sorts By** | Single field (e.g., sorting students by marks). | Multiple fields (e.g., sorting students by name and then marks). |
| **Used In** | `TreeSet`, `TreeMap`, `Collections.sort()`. | `Collections.sort()`, `TreeSet`, `TreeMap`. |

‚úÖ **Use `Comparable<T>`** when the class has a **single natural sorting order**.  
‚úÖ **Use `Comparator<T>`** when sorting should be **flexible**.

---
# **üìå Sorting in Sets and Maps Using Comparator<T> (Easy Explanation)**  

Sorting **Lists** is easy with `Comparator<T>`, but **how do we sort Sets and Maps**? ü§î  
Let‚Äôs explore **sorting techniques for Sets and Maps in Java**.

---

# **1Ô∏è‚É£ Sorting `Set<T>` (TreeSet, HashSet, LinkedHashSet)**
‚úÖ **By Default:**  
- `TreeSet<T>` sorts elements **automatically in ascending order**.  
- `HashSet<T>` and `LinkedHashSet<T>` **do NOT maintain sorting order**.  

‚úÖ **How to Sort Sets?**  
Since `HashSet<T>` and `LinkedHashSet<T>` don‚Äôt support sorting, we must:  
‚úîÔ∏è Convert them into a **List**.  
‚úîÔ∏è Sort the list using `Comparator<T>`.  
‚úîÔ∏è Convert the list **back into a Set**.  

---

### **Sorting `TreeSet<T>` Using `Comparator<T>`**  
üîπ `TreeSet<T>` allows custom sorting using a **Comparator**.  

```java
import java.util.*;

class SortTreeSetExample {
    public static void main(String[] args) {
        // TreeSet with custom sorting (Descending Order)
        TreeSet<Integer> numbers = new TreeSet<>(Comparator.reverseOrder());

        numbers.add(10);
        numbers.add(50);
        numbers.add(30);
        numbers.add(20);

        System.out.println("Sorted TreeSet (Descending Order): " + numbers);
    }
}
```

### **üîπ Output:**
```
Sorted TreeSet (Descending Order): [50, 30, 20, 10]
```
‚úîÔ∏è We passed `Comparator.reverseOrder()` to sort the TreeSet **in descending order**.

---

### **Sorting `HashSet<T>` Using `Comparator<T>`**  
üîπ `HashSet<T>` does not maintain sorting order, so we need to convert it to a `List<T>`, sort it, and convert it back.

```java
import java.util.*;

class SortHashSetExample {
    public static void main(String[] args) {
        HashSet<String> names = new HashSet<>();
        names.add("Charlie");
        names.add("Alice");
        names.add("Bob");

        // Convert HashSet to List
        List<String> sortedList = new ArrayList<>(names);

        // Sort List using Comparator (Alphabetical Order)
        sortedList.sort(Comparator.naturalOrder());

        // Convert List back to Set
        LinkedHashSet<String> sortedSet = new LinkedHashSet<>(sortedList);

        System.out.println("Sorted HashSet: " + sortedSet);
    }
}
```

### **üîπ Output:**
```
Sorted HashSet: [Alice, Bob, Charlie]
```
‚úîÔ∏è We used `Comparator.naturalOrder()` to sort names **in alphabetical order**.

---

# **2Ô∏è‚É£ Sorting `Map<K, V>` (HashMap, LinkedHashMap, TreeMap)**
‚úÖ **By Default:**  
- `TreeMap<K, V>` **sorts keys in natural order**.  
- `HashMap<K, V>` and `LinkedHashMap<K, V>` **do NOT maintain sorting order**.  

‚úÖ **How to Sort Maps?**  
‚úîÔ∏è We can sort **by keys** or **by values** using `Comparator<T>`.  

---

### **Sorting `TreeMap<K, V>` By Custom Order**
üîπ By default, `TreeMap<K, V>` sorts **by key in ascending order**.  
üîπ We can **customize the sorting order**.

```java
import java.util.*;

class SortTreeMapExample {
    public static void main(String[] args) {
        // TreeMap sorted in reverse order of keys
        TreeMap<Integer, String> treeMap = new TreeMap<>(Comparator.reverseOrder());

        treeMap.put(1, "Apple");
        treeMap.put(3, "Banana");
        treeMap.put(2, "Cherry");

        System.out.println("Sorted TreeMap (By Key Descending): " + treeMap);
    }
}
```

### **üîπ Output:**
```
Sorted TreeMap (By Key Descending): {3=Banana, 2=Cherry, 1=Apple}
```
‚úîÔ∏è We used `Comparator.reverseOrder()` to **sort keys in descending order**.

---

### **Sorting `HashMap<K, V>` By Keys**
üîπ Since `HashMap<K, V>` is **unordered**, we:  
‚úîÔ∏è Convert it into a `List<Map.Entry<K, V>>`.  
‚úîÔ∏è Sort it using a `Comparator<K>`.  
‚úîÔ∏è Insert it into a `LinkedHashMap<K, V>`.

```java
import java.util.*;

class SortHashMapByKeyExample {
    public static void main(String[] args) {
        HashMap<Integer, String> map = new HashMap<>();
        map.put(3, "Banana");
        map.put(1, "Apple");
        map.put(2, "Cherry");

        // Convert to List
        List<Map.Entry<Integer, String>> entryList = new ArrayList<>(map.entrySet());

        // Sort by Key (Ascending)
        entryList.sort(Map.Entry.comparingByKey());

        // Convert back to LinkedHashMap
        LinkedHashMap<Integer, String> sortedMap = new LinkedHashMap<>();
        for (Map.Entry<Integer, String> entry : entryList) {
            sortedMap.put(entry.getKey(), entry.getValue());
        }

        System.out.println("Sorted HashMap (By Key Ascending): " + sortedMap);
    }
}
```

### **üîπ Output:**
```
Sorted HashMap (By Key Ascending): {1=Apple, 2=Cherry, 3=Banana}
```
‚úîÔ∏è We used `Map.Entry.comparingByKey()` to **sort by key**.

---

### **Sorting `HashMap<K, V>` By Values**
üîπ If we want to **sort by values** instead of keys:  

```java
import java.util.*;

class SortHashMapByValueExample {
    public static void main(String[] args) {
        HashMap<Integer, String> map = new HashMap<>();
        map.put(3, "Banana");
        map.put(1, "Apple");
        map.put(2, "Cherry");

        // Convert to List
        List<Map.Entry<Integer, String>> entryList = new ArrayList<>(map.entrySet());

        // Sort by Value (Alphabetical Order)
        entryList.sort(Map.Entry.comparingByValue());

        // Convert back to LinkedHashMap
        LinkedHashMap<Integer, String> sortedMap = new LinkedHashMap<>();
        for (Map.Entry<Integer, String> entry : entryList) {
            sortedMap.put(entry.getKey(), entry.getValue());
        }

        System.out.println("Sorted HashMap (By Value): " + sortedMap);
    }
}
```

### **üîπ Output:**
```
Sorted HashMap (By Value): {1=Apple, 3=Banana, 2=Cherry}
```
‚úîÔ∏è We used `Map.Entry.comparingByValue()` to **sort by value alphabetically**.

---

# **üîπ Summary: Sorting Techniques for Collections**  

| Collection | Sorting Strategy |
|------------|----------------|
| `ArrayList<T>` | Use `Collections.sort(list, comparator)` |
| `TreeSet<T>` | Use `new TreeSet<>(comparator)` |
| `HashSet<T>` | Convert to `List<T>`, sort, convert back |
| `TreeMap<K, V>` | Use `new TreeMap<>(comparator)` |
| `HashMap<K, V>` | Convert to `List<Map.Entry<K, V>>`, sort, convert back |

‚úÖ **Use `Comparator<T>`** for **custom sorting** in Lists, Sets, and Maps.  
‚úÖ **Convert HashSet/HashMap to a List** if they don‚Äôt support sorting directly.  

---

# **üìå Chapter 8: Collections Utility Class (Helper Methods) ‚Äì Deep Explanation**  

The **Collections Utility Class** in Java provides several static methods to operate on **lists, sets, and maps** easily. It includes methods for:  
‚úÖ **Sorting** (e.g., `Collections.sort()`)  
‚úÖ **Searching** (e.g., `Collections.binarySearch()`)  
‚úÖ **Making Collections Immutable** (e.g., `Collections.unmodifiableList()`)  
‚úÖ **Creating Thread-Safe Collections** (e.g., `Collections.synchronizedList()`)  

---

## **üîπ What is the `Collections` Utility Class?**
The `Collections` class is a **final class** in Java's `java.util` package.  
- It **cannot be instantiated** because it only contains **static methods**.  
- It **enhances** how we work with collections by providing **common utility functions**.  

### **üìå Key Features of `Collections` Class**
| Feature | Description |
|---------|------------|
| **Sorting** | Sorts a `List<T>` using natural or custom ordering. |
| **Searching** | Searches for an element in a sorted list using binary search. |
| **Thread-Safe Collections** | Converts collections into thread-safe versions. |
| **Immutable Collections** | Creates **unmodifiable** collections that cannot be changed. |
| **Shuffling** | Randomizes the order of elements. |
| **Reversing** | Reverses the order of elements in a list. |
| **Filling** | Replaces all elements in a list with a specified value. |
| **Copying** | Copies elements from one list to another. |
| **Finding Min/Max** | Finds the smallest or largest element in a collection. |

---

## **üîπ Why Use `Collections` Utility Class?**
### ‚úÖ **Without `Collections` Class** (Manual Sorting Example)
```java
import java.util.*;

class WithoutCollections {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(5, 2, 8, 1));

        // Manual sorting using loops
        for (int i = 0; i < numbers.size() - 1; i++) {
            for (int j = i + 1; j < numbers.size(); j++) {
                if (numbers.get(i) > numbers.get(j)) {
                    // Swap elements
                    int temp = numbers.get(i);
                    numbers.set(i, numbers.get(j));
                    numbers.set(j, temp);
                }
            }
        }

        System.out.println("Sorted List: " + numbers);
    }
}
```
### **üîπ Output:**
```
Sorted List: [1, 2, 5, 8]
```
‚úîÔ∏è Here, we had to **write a lot of code** just to sort a list.  

---

### ‚úÖ **With `Collections` Class (Easy Sorting)**
```java
import java.util.*;

class WithCollections {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(5, 2, 8, 1));

        // Using Collections.sort()
        Collections.sort(numbers);

        System.out.println("Sorted List: " + numbers);
    }
}
```
### **üîπ Output:**
```
Sorted List: [1, 2, 5, 8]
```
‚úîÔ∏è Just **one line of code** using `Collections.sort()`!

---

## **üîπ List of Important Methods in `Collections` Class**
| Method | Description |
|--------|------------|
| `Collections.sort(List<T>)` | Sorts a list in natural order. |
| `Collections.sort(List<T>, Comparator<T>)` | Sorts a list using a custom comparator. |
| `Collections.binarySearch(List<T>, key)` | Searches for an element in a sorted list using binary search. |
| `Collections.unmodifiableList(List<T>)` | Creates an **immutable list**. |
| `Collections.synchronizedList(List<T>)` | Makes a list **thread-safe**. |
| `Collections.reverse(List<T>)` | Reverses the order of elements in a list. |
| `Collections.shuffle(List<T>)` | Randomizes the order of elements. |
| `Collections.fill(List<T>, value)` | Replaces all elements in a list with a specified value. |
| `Collections.copy(List<T>, List<T>)` | Copies elements from one list to another. |
| `Collections.min(Collection<T>)` | Finds the smallest element. |
| `Collections.max(Collection<T>)` | Finds the largest element. |

---

# **Deep Dive into First Three Methods of `Collections` Class**  

In this section, we'll **deeply understand** the first three methods of the `Collections` utility class:  
‚úÖ `Collections.sort(List<T>)`  
‚úÖ `Collections.sort(List<T>, Comparator<T>)`  
‚úÖ `Collections.binarySearch(List<T>, key)`

We'll cover:  
üîπ **What the method does**  
üîπ **How it works internally**  
üîπ **Code examples**  
üîπ **Time complexity**  
üîπ **Real-world use cases**  

---

## **1Ô∏è‚É£ `Collections.sort(List<T>)` (Natural Sorting)**
### **üìå What It Does?**
- This method **sorts a List** in **ascending order** using **natural ordering**.
- It works with elements that implement the **`Comparable` interface** (like `Integer`, `String`, `Double`, etc.).
- Sorting is done using **Timsort**, which is a combination of **Merge Sort** and **Insertion Sort**.

### **üìå Syntax**
```java
Collections.sort(List<T> list);
```
- This method **modifies the original list** by sorting it.

---

### **üìå Internal Working (How It Works?)**
1. **Checks if the list implements `RandomAccess`** (i.e., if it‚Äôs an `ArrayList`).  
   - If `true` ‚Üí Uses **Dual-Pivot QuickSort** (fastest for arrays).  
   - If `false` ‚Üí Uses **Merge Sort** (better for linked lists).  
2. **Calls `TimSort.sort()` method** for sorting the list.  
3. **Rearranges elements in ascending order**.  

---

### **üìå Example: Sorting a List of Numbers**
```java
import java.util.*;

class SortExample {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(9, 3, 7, 1, 5));

        // Sorting in ascending order
        Collections.sort(numbers);

        System.out.println("Sorted List: " + numbers);
    }
}
```
### **üîπ Output:**
```
Sorted List: [1, 3, 5, 7, 9]
```
---

### **üìå Example: Sorting a List of Strings**
```java
import java.util.*;

class StringSortExample {
    public static void main(String[] args) {
        List<String> names = new ArrayList<>(Arrays.asList("John", "Alice", "Bob"));

        // Sorting alphabetically
        Collections.sort(names);

        System.out.println("Sorted Names: " + names);
    }
}
```
### **üîπ Output:**
```
Sorted Names: [Alice, Bob, John]
```

---

### **üìå Time Complexity**
- **Worst Case:** `O(n log n)`  
- **Best Case (Already Sorted):** `O(n)`  
- **Average Case:** `O(n log n)`  

‚úîÔ∏è **Fast and efficient** for large datasets.

---

## **2Ô∏è‚É£ `Collections.sort(List<T>, Comparator<T>)` (Custom Sorting)**
### **üìå What It Does?**
- This method **sorts a list** using a **custom sorting logic** defined by a `Comparator<T>`.
- Used when elements **do not have natural ordering** (e.g., sorting objects, sorting in descending order).

### **üìå Syntax**
```java
Collections.sort(List<T> list, Comparator<T> comparator);
```
- The **comparator** defines **how elements should be sorted**.

---

### **üìå Example: Sorting in Descending Order**
```java
import java.util.*;

class DescendingSort {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(9, 3, 7, 1, 5));

        // Sorting in descending order
        Collections.sort(numbers, (a, b) -> b - a);

        System.out.println("Sorted Descending: " + numbers);
    }
}
```
### **üîπ Output:**
```
Sorted Descending: [9, 7, 5, 3, 1]
```

---

### **üìå Example: Sorting a List of Objects**
```java
import java.util.*;

class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return name + " (" + age + ")";
    }
}

class AgeComparator implements Comparator<Person> {
    public int compare(Person p1, Person p2) {
        return p1.age - p2.age; // Sort by age (ascending)
    }
}

class ObjectSortingExample {
    public static void main(String[] args) {
        List<Person> people = new ArrayList<>(Arrays.asList(
            new Person("Alice", 25),
            new Person("Bob", 22),
            new Person("Charlie", 28)
        ));

        // Sorting by age
        Collections.sort(people, new AgeComparator());

        System.out.println("Sorted by Age: " + people);
    }
}
```
### **üîπ Output:**
```
Sorted by Age: [Bob (22), Alice (25), Charlie (28)]
```

---

### **üìå Time Complexity**
- Same as `Collections.sort(List<T>)`, i.e., `O(n log n)`.  
‚úîÔ∏è **More flexible**, as it allows **custom sorting**.

---

## **3Ô∏è‚É£ `Collections.binarySearch(List<T>, key)` (Efficient Searching)**
### **üìå What It Does?**
- **Searches for an element in a sorted list** using **Binary Search**.
- It is **faster than linear search** (`O(log n)` instead of `O(n)`).
- The list **must be sorted** before using `binarySearch()`.

### **üìå Syntax**
```java
int index = Collections.binarySearch(List<T> list, T key);
```
- Returns the **index** of `key` if found.  
- Returns **negative index** (`-(insertion point) - 1`) if **not found**.

---

### **üìå Example: Searching in a Sorted List**
```java
import java.util.*;

class BinarySearchExample {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 3, 5, 7, 9));

        int index = Collections.binarySearch(numbers, 5);
        System.out.println("Index of 5: " + index);
    }
}
```
### **üîπ Output:**
```
Index of 5: 2
```
‚úîÔ∏è `5` is found at **index 2**.

---

### **üìå Example: Searching for an Element Not in the List**
```java
import java.util.*;

class BinarySearchNotFound {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 3, 5, 7, 9));

        int index = Collections.binarySearch(numbers, 6);
        System.out.println("Index of 6: " + index);
    }
}
```
### **üîπ Output:**
```
Index of 6: -4
```
‚úîÔ∏è **Explanation:**  
- `6` is **not in the list**.  
- `-(insertion point) - 1` = `-(3) - 1 = -4`.  
- The insertion point is `index 3`.

---

### **üìå Time Complexity**
- **Best Case:** `O(1)` (if the element is at the middle).  
- **Worst/Average Case:** `O(log n)`.  
‚úîÔ∏è **Faster** than a simple linear search.

---

# **üìå Summary Table**
| Method | Purpose | Time Complexity |
|--------|---------|----------------|
| `Collections.sort(List<T>)` | Sorts a list in natural order (ascending). | `O(n log n)` |
| `Collections.sort(List<T>, Comparator<T>)` | Sorts a list using custom order. | `O(n log n)` |
| `Collections.binarySearch(List<T>, key)` | Searches for an element in a sorted list. | `O(log n)` |

---

# **Deep Dive into Next Three Methods of `Collections` Class**  

‚úÖ `Collections.unmodifiableList(List<T>)`  
‚úÖ `Collections.synchronizedList(List<T>)`  
‚úÖ `Collections.reverse(List<T>)`  

We'll cover:  
üîπ **What the method does**  
üîπ **How it works internally**  
üîπ **Code examples**  
üîπ **Time complexity**  
üîπ **Real-world use cases**  

---

## **1Ô∏è‚É£ `Collections.unmodifiableList(List<T>)` (Immutable List)**
### **üìå What It Does?**
- Creates a **read-only (immutable) version** of a list.  
- Any attempt to modify the list (add, remove, update) **throws an exception**.  
- Used when you **want to protect a list** from accidental modification.  

### **üìå Syntax**
```java
List<T> immutableList = Collections.unmodifiableList(List<T> list);
```
- **Returns an unmodifiable view** of the list.  

---

### **üìå Internal Working (How It Works?)**
1. **Wraps the original list** inside an unmodifiable wrapper.  
2. **Allows only read operations** (like `get()`, `contains()`).  
3. **Throws `UnsupportedOperationException`** for any modification.  

---

### **üìå Example: Creating an Unmodifiable List**
```java
import java.util.*;

class UnmodifiableListExample {
    public static void main(String[] args) {
        List<String> names = new ArrayList<>(Arrays.asList("Alice", "Bob", "Charlie"));

        // Creating an unmodifiable list
        List<String> immutableNames = Collections.unmodifiableList(names);

        System.out.println("Immutable List: " + immutableNames);

        // Trying to modify the list (will throw an exception)
        immutableNames.add("David");  // Throws UnsupportedOperationException
    }
}
```
### **üîπ Output:**
```
Exception in thread "main" java.lang.UnsupportedOperationException
```
‚úîÔ∏è The program crashes when trying to modify the list.

---

### **üìå Real-World Use Case**
- **Used in APIs** to return **safe lists** that clients cannot modify.  
- Example: `List.of()` in Java 9+ creates immutable lists directly.

---

## **2Ô∏è‚É£ `Collections.synchronizedList(List<T>)` (Thread-Safe List)**
### **üìå What It Does?**
- Converts a **normal list** into a **thread-safe list**.  
- Allows **multiple threads** to access the list **without conflicts**.  
- **Synchronizes all methods** (`add()`, `remove()`, `get()`, etc.).  

### **üìå Syntax**
```java
List<T> syncList = Collections.synchronizedList(List<T> list);
```
- **Returns a synchronized version** of the list.  

---

### **üìå Internal Working (How It Works?)**
1. **Wraps the list inside a synchronized wrapper**.  
2. **Every method is synchronized** (ensures only one thread modifies at a time).  
3. **Iterating still requires external synchronization** (`synchronized(syncList)`).  

---

### **üìå Example: Making a List Thread-Safe**
```java
import java.util.*;

class SynchronizedListExample {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3));

        // Creating a thread-safe list
        List<Integer> syncNumbers = Collections.synchronizedList(numbers);

        // Thread-safe modification
        syncNumbers.add(4);
        System.out.println("Synchronized List: " + syncNumbers);
    }
}
```
‚úîÔ∏è **This prevents concurrency issues** in a multi-threaded environment.

---

### **üìå Important: Synchronizing Iteration**
Even though the list is synchronized, **iteration must be synchronized externally**:
```java
synchronized(syncNumbers) {
    for (Integer num : syncNumbers) {
        System.out.println(num);
    }
}
```
‚úîÔ∏è Without this, **ConcurrentModificationException** may occur.

---

### **üìå Real-World Use Case**
- Used in **multi-threaded applications** where lists are shared across threads.  
- **Alternative:** `CopyOnWriteArrayList` (better performance for concurrent reads).  

---

## **3Ô∏è‚É£ `Collections.reverse(List<T>)` (Reverse Order)**
### **üìå What It Does?**
- **Reverses the order** of elements in a list.  
- Modifies the **original list**.  
- Works on any `List<T>` implementation (`ArrayList`, `LinkedList`, etc.).  

### **üìå Syntax**
```java
Collections.reverse(List<T> list);
```
- **Directly modifies** the input list.  

---

### **üìå Internal Working (How It Works?)**
1. **Swaps first and last elements**, second and second-last, and so on.  
2. **Uses `O(n)` time complexity** (single pass).  

---

### **üìå Example: Reversing a List**
```java
import java.util.*;

class ReverseExample {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

        // Reversing the list
        Collections.reverse(numbers);

        System.out.println("Reversed List: " + numbers);
    }
}
```
### **üîπ Output:**
```
Reversed List: [5, 4, 3, 2, 1]
```

---

### **üìå Example: Reversing a List of Strings**
```java
import java.util.*;

class ReverseStringList {
    public static void main(String[] args) {
        List<String> words = new ArrayList<>(Arrays.asList("Hello", "World", "Java"));

        // Reversing the list
        Collections.reverse(words);

        System.out.println("Reversed Words: " + words);
    }
}
```
### **üîπ Output:**
```
Reversed Words: [Java, World, Hello]
```

---

### **üìå Time Complexity**
- `O(n)`, as it swaps **half** the elements in a **single pass**.

---

# **üìå Summary Table**
| Method | Purpose | Time Complexity |
|--------|---------|----------------|
| `Collections.unmodifiableList(List<T>)` | Creates a read-only list (modification not allowed). | `O(1)` |
| `Collections.synchronizedList(List<T>)` | Creates a thread-safe list. | `O(1)` (method calls may take extra time) |
| `Collections.reverse(List<T>)` | Reverses the order of elements in a list. | `O(n)` |

---

# **Deep Dive into Next Three Methods of `Collections` Class**  

‚úÖ `Collections.fill(List<T>, T value)`  
‚úÖ `Collections.copy(List<T> dest, List<T> src)`  
‚úÖ `Collections.replaceAll(List<T> list, T oldValue, T newValue)`

We‚Äôll cover:  
üîπ **What the method does**  
üîπ **How it works internally**  
üîπ **Code examples**  
üîπ **Time complexity**  
üîπ **Real-world use cases**  

---

## **1Ô∏è‚É£ `Collections.fill(List<T>, T value)` (Fill List with a Single Value)**  

### **üìå What It Does?**  
- Replaces **all elements** of a list with a **single value**.  
- **Modifies the original list**.  
- Works only with **modifiable lists** (not immutable lists).  

### **üìå Syntax**
```java
Collections.fill(List<T> list, T value);
```
- Takes a **list** and a **value**, then replaces **every element** with that value.

---

### **üìå Internal Working (How It Works?)**  
1. Iterates through **each index of the list**.  
2. Replaces the **existing value** with the new value.  
3. **Time Complexity: O(n)** (as it modifies every element).  

---

### **üìå Example: Filling a List**
```java
import java.util.*;

class FillExample {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

        // Filling the list with 0
        Collections.fill(numbers, 0);

        System.out.println("Filled List: " + numbers);
    }
}
```
### **üîπ Output:**
```
Filled List: [0, 0, 0, 0, 0]
```
‚úîÔ∏è **All elements are replaced with `0`**.

---

### **üìå Example: Filling a List of Strings**
```java
import java.util.*;

class FillStringList {
    public static void main(String[] args) {
        List<String> words = new ArrayList<>(Arrays.asList("Java", "Python", "C++"));

        // Filling the list with "Default"
        Collections.fill(words, "Default");

        System.out.println("Filled List: " + words);
    }
}
```
### **üîπ Output:**
```
Filled List: [Default, Default, Default]
```

---

### **üìå Real-World Use Case**
- Used to **reset a list** with a default value.  
- Used in **game development** to **initialize** a list with default scores.  

---

## **2Ô∏è‚É£ `Collections.copy(List<T> dest, List<T> src)` (Copy Elements from One List to Another)**  

### **üìå What It Does?**  
- Copies **all elements** from the **source list** (`src`) to the **destination list** (`dest`).  
- **Destination list must have the same or larger size** as the source list.  
- **Modifies the destination list**.  

### **üìå Syntax**
```java
Collections.copy(List<T> dest, List<T> src);
```
- `dest` should be **at least the same size** as `src`, otherwise it throws `IndexOutOfBoundsException`.  

---

### **üìå Internal Working (How It Works?)**  
1. Iterates through the **source list** and copies **each element** to the destination list.  
2. **Overwrites** existing elements in `dest`.  
3. **Time Complexity: O(n)** (as it processes every element).  

---

### **üìå Example: Copying One List to Another**
```java
import java.util.*;

class CopyExample {
    public static void main(String[] args) {
        List<String> src = Arrays.asList("Apple", "Banana", "Cherry");
        List<String> dest = new ArrayList<>(Arrays.asList("X", "Y", "Z"));

        // Copying src to dest
        Collections.copy(dest, src);

        System.out.println("Destination List After Copy: " + dest);
    }
}
```
### **üîπ Output:**
```
Destination List After Copy: [Apple, Banana, Cherry]
```
‚úîÔ∏è The elements in `dest` are **replaced** by elements from `src`.

---

### **üìå Important Notes**
‚ùå This **will not work** if `dest` is smaller than `src`:
```java
List<String> dest = new ArrayList<>(Arrays.asList("X", "Y")); // Smaller size
Collections.copy(dest, src); // Throws IndexOutOfBoundsException
```
‚úîÔ∏è **Solution:** Ensure `dest` has the **same or larger size** before copying.

---

### **üìå Real-World Use Case**
- Used to **backup lists** before modification.  
- Used in **undo-redo features** to maintain copies of lists.  

---

## **3Ô∏è‚É£ `Collections.replaceAll(List<T> list, T oldValue, T newValue)` (Replace a Specific Value in a List)**  

### **üìå What It Does?**  
- **Finds and replaces** all occurrences of `oldValue` in a list with `newValue`.  
- **Modifies the original list**.  

### **üìå Syntax**
```java
Collections.replaceAll(List<T> list, T oldValue, T newValue);
```
- Searches for **`oldValue`** and replaces it with **`newValue`** in the list.

---

### **üìå Internal Working (How It Works?)**  
1. Iterates through **each element** in the list.  
2. If an element **matches `oldValue`**, it is replaced with `newValue`.  
3. **Time Complexity: O(n)** (as it checks every element).  

---

### **üìå Example: Replacing Elements in a List**
```java
import java.util.*;

class ReplaceAllExample {
    public static void main(String[] args) {
        List<String> fruits = new ArrayList<>(Arrays.asList("Apple", "Banana", "Apple", "Cherry"));

        // Replacing all "Apple" with "Mango"
        Collections.replaceAll(fruits, "Apple", "Mango");

        System.out.println("List After Replace: " + fruits);
    }
}
```
### **üîπ Output:**
```
List After Replace: [Mango, Banana, Mango, Cherry]
```
‚úîÔ∏è **All occurrences of "Apple" are replaced with "Mango".**  

---

### **üìå Example: Replacing Numbers in a List**
```java
import java.util.*;

class ReplaceNumbers {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 2, 4));

        // Replacing all 2s with 99
        Collections.replaceAll(numbers, 2, 99);

        System.out.println("List After Replace: " + numbers);
    }
}
```
### **üîπ Output:**
```
List After Replace: [1, 99, 3, 99, 4]
```

---

### **üìå Real-World Use Case**
- Used to **update outdated values** in lists.  
- Used to **change labels or categories** dynamically in applications.  

---

# **üìå Summary Table**
| Method | Purpose | Time Complexity |
|--------|---------|----------------|
| `Collections.fill(List<T>, T value)` | Replaces all elements with a single value. | `O(n)` |
| `Collections.copy(List<T> dest, List<T> src)` | Copies elements from one list to another. | `O(n)` |
| `Collections.replaceAll(List<T>, T oldValue, T newValue)` | Replaces occurrences of `oldValue` with `newValue`. | `O(n)` |

---

# **Deep Dive into Next Three Methods of `Collections` Class**  


‚úÖ `Collections.shuffle(List<T> list)`  
‚úÖ `Collections.rotate(List<T> list, int distance)`  
‚úÖ `Collections.swap(List<T> list, int i, int j)`  

We‚Äôll cover:  
üîπ **What the method does**  
üîπ **How it works internally**  
üîπ **Code examples**  
üîπ **Time complexity**  
üîπ **Real-world use cases**  

---

## **1Ô∏è‚É£ `Collections.shuffle(List<T> list)` (Randomly Rearrange Elements in a List)**  

### **üìå What It Does?**  
- **Randomly shuffles** the elements of the list.  
- **Changes the order each time** it is called.  
- Uses **Java's Random class** internally to generate random indices.  

### **üìå Syntax**
```java
Collections.shuffle(List<T> list);
```
- Modifies the **original list**.  

---

### **üìå Internal Working (How It Works?)**  
1. Uses the **Fisher-Yates algorithm** (modern version of **Knuth shuffle**).  
2. **Swaps each element** with a randomly chosen element after it.  
3. Uses `java.util.Random` to generate **random indices**.  
4. **Time Complexity: O(n)** (as each element is processed once).  

---

### **üìå Example: Shuffling a List**
```java
import java.util.*;

class ShuffleExample {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9));

        // Shuffling the list
        Collections.shuffle(numbers);

        System.out.println("Shuffled List: " + numbers);
    }
}
```
### **üîπ Output (changes each time):**
```
Shuffled List: [4, 9, 1, 7, 3, 5, 2, 8, 6]
```
‚úîÔ∏è **The order of elements is randomized**.  

---

### **üìå Example: Shuffling a List of Strings**
```java
import java.util.*;

class ShuffleStringList {
    public static void main(String[] args) {
        List<String> names = new ArrayList<>(Arrays.asList("Alice", "Bob", "Charlie", "David"));

        Collections.shuffle(names);

        System.out.println("Shuffled Names: " + names);
    }
}
```
### **üîπ Output (changes each time):**
```
Shuffled Names: [Charlie, Alice, David, Bob]
```

---

### **üìå Real-World Use Case**
- **Randomizing quiz questions** in an exam application.  
- **Shuffling a deck of cards** in a card game.  

---

## **2Ô∏è‚É£ `Collections.rotate(List<T> list, int distance)` (Rotate Elements in a List)**  

### **üìå What It Does?**  
- Rotates the list by moving elements **rightward** (positive distance) or **leftward** (negative distance).  

### **üìå Syntax**
```java
Collections.rotate(List<T> list, int distance);
```
- **Positive distance ‚Üí Right rotation**.  
- **Negative distance ‚Üí Left rotation**.  

---

### **üìå Internal Working (How It Works?)**  
1. Uses **modulo arithmetic** (`distance % list.size()`) to optimize movement.  
2. **Rightward rotation** shifts elements to the right.  
3. **Leftward rotation** (when distance is negative) shifts elements to the left.  
4. **Time Complexity: O(n)** (as every element is moved once).  

---

### **üìå Example: Rotating Right by 2 Places**
```java
import java.util.*;

class RotateExample {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

        // Rotating right by 2
        Collections.rotate(numbers, 2);

        System.out.println("Rotated List: " + numbers);
    }
}
```
### **üîπ Output:**
```
Rotated List: [4, 5, 1, 2, 3]
```
‚úîÔ∏è **Last two elements move to the front.**  

---

### **üìå Example: Rotating Left by 2 Places**
```java
import java.util.*;

class RotateLeftExample {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

        // Rotating left by 2 (equivalent to rotating right by -2)
        Collections.rotate(numbers, -2);

        System.out.println("Rotated List: " + numbers);
    }
}
```
### **üîπ Output:**
```
Rotated List: [3, 4, 5, 1, 2]
```
‚úîÔ∏è **First two elements move to the end.**  

---

### **üìå Real-World Use Case**
- **Shifting circular queue elements** in task scheduling.  
- **Rotating images** in a slideshow.  

---

## **3Ô∏è‚É£ `Collections.swap(List<T> list, int i, int j)` (Swap Two Elements in a List)**  

### **üìå What It Does?**  
- **Swaps two elements** in a list at given indices `i` and `j`.  

### **üìå Syntax**
```java
Collections.swap(List<T> list, int i, int j);
```
- Works for **both mutable and immutable lists**.  

---

### **üìå Internal Working (How It Works?)**  
1. **Stores the element at index `i` in a temp variable**.  
2. **Replaces the element at `i` with the element at `j`**.  
3. **Puts the temp value into `j`**.  
4. **Time Complexity: O(1)** (only two assignments).  

---

### **üìå Example: Swapping Two Elements**
```java
import java.util.*;

class SwapExample {
    public static void main(String[] args) {
        List<String> colors = new ArrayList<>(Arrays.asList("Red", "Green", "Blue", "Yellow"));

        // Swapping "Green" and "Blue"
        Collections.swap(colors, 1, 2);

        System.out.println("List After Swap: " + colors);
    }
}
```
### **üîπ Output:**
```
List After Swap: [Red, Blue, Green, Yellow]
```
‚úîÔ∏è **The elements at index `1` and `2` are swapped.**  

---

### **üìå Real-World Use Case**
- **Swapping players in a game leaderboard**.  
- **Swapping elements in sorting algorithms (like Bubble Sort)**.  

---

# **üìå Summary Table**
| Method | Purpose | Time Complexity |
|--------|---------|----------------|
| `Collections.shuffle(List<T> list)` | Randomly shuffles elements in a list. | `O(n)` |
| `Collections.rotate(List<T> list, int distance)` | Moves elements left or right in a list. | `O(n)` |
| `Collections.swap(List<T> list, int i, int j)` | Swaps two elements in a list. | `O(1)` |

---

# **Deep Dive into Next Three Methods of `Collections` Class**  

‚úÖ `Collections.min(Collection<T> coll)`  
‚úÖ `Collections.max(Collection<T> coll)`  
‚úÖ `Collections.frequency(Collection<T> coll, Object obj)`  

We‚Äôll cover:  
üîπ **What the method does**  
üîπ **How it works internally**  
üîπ **Code examples**  
üîπ **Time complexity**  
üîπ **Real-world use cases**  

---

## **1Ô∏è‚É£ `Collections.min(Collection<T> coll)` (Find the Minimum Element)**  

### **üìå What It Does?**  
- Finds the **smallest element** in a given collection.  
- Uses **natural ordering** (`Comparable<T>`).  
- Can also work with a **custom comparator**.  

### **üìå Syntax**
```java
Collections.min(Collection<T> coll);
Collections.min(Collection<T> coll, Comparator<T> comp);
```
- **First version** ‚Üí Uses **natural sorting order** (`Comparable<T>`).  
- **Second version** ‚Üí Uses a **custom comparator** (`Comparator<T>`).  

---

### **üìå Internal Working (How It Works?)**  
1. **Iterates through all elements** of the collection.  
2. **Compares elements** using the `compareTo()` method (for `Comparable<T>`) or `compare()` method (for `Comparator<T>`).  
3. **Returns the smallest element**.  
4. **Time Complexity: O(n)** (since every element is checked once).  

---

### **üìå Example: Finding Minimum in a List**
```java
import java.util.*;

class MinExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(45, 12, 78, 34, 23);

        int minNumber = Collections.min(numbers);
        System.out.println("Minimum Number: " + minNumber);
    }
}
```
### **üîπ Output:**
```
Minimum Number: 12
```
‚úîÔ∏è **Finds the smallest number from the list.**  

---

### **üìå Example: Finding Minimum with a Custom Comparator**
```java
import java.util.*;

class MinCustomExample {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("apple", "banana", "grape", "mango");

        // Finding the shortest word using a custom comparator
        String minWord = Collections.min(words, Comparator.comparing(String::length));

        System.out.println("Shortest Word: " + minWord);
    }
}
```
### **üîπ Output:**
```
Shortest Word: grape
```
‚úîÔ∏è **Finds the shortest word using a custom comparator.**  

---

### **üìå Real-World Use Case**
- **Finding the lowest price in an e-commerce product list.**  
- **Finding the youngest student in a list based on age.**  

---

## **2Ô∏è‚É£ `Collections.max(Collection<T> coll)` (Find the Maximum Element)**  

### **üìå What It Does?**  
- Finds the **largest element** in a given collection.  
- Uses **natural ordering** (`Comparable<T>`).  
- Can also work with a **custom comparator**.  

### **üìå Syntax**
```java
Collections.max(Collection<T> coll);
Collections.max(Collection<T> coll, Comparator<T> comp);
```
- **First version** ‚Üí Uses **natural sorting order** (`Comparable<T>`).  
- **Second version** ‚Üí Uses a **custom comparator** (`Comparator<T>`).  

---

### **üìå Internal Working (How It Works?)**  
1. **Iterates through all elements** of the collection.  
2. **Compares elements** using the `compareTo()` method (for `Comparable<T>`) or `compare()` method (for `Comparator<T>`).  
3. **Returns the largest element**.  
4. **Time Complexity: O(n)** (since every element is checked once).  

---

### **üìå Example: Finding Maximum in a List**
```java
import java.util.*;

class MaxExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(45, 12, 78, 34, 23);

        int maxNumber = Collections.max(numbers);
        System.out.println("Maximum Number: " + maxNumber);
    }
}
```
### **üîπ Output:**
```
Maximum Number: 78
```
‚úîÔ∏è **Finds the largest number from the list.**  

---

### **üìå Example: Finding Maximum with a Custom Comparator**
```java
import java.util.*;

class MaxCustomExample {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("apple", "banana", "grape", "mango");

        // Finding the longest word using a custom comparator
        String maxWord = Collections.max(words, Comparator.comparing(String::length));

        System.out.println("Longest Word: " + maxWord);
    }
}
```
### **üîπ Output:**
```
Longest Word: banana
```
‚úîÔ∏è **Finds the longest word using a custom comparator.**  

---

### **üìå Real-World Use Case**
- **Finding the highest salary from an employee list.**  
- **Finding the most expensive product in an inventory.**  

---

## **3Ô∏è‚É£ `Collections.frequency(Collection<T> coll, Object obj)` (Count Occurrences of an Element)**  

### **üìå What It Does?**  
- Counts how many times an element **appears** in a collection.  

### **üìå Syntax**
```java
Collections.frequency(Collection<T> coll, Object obj);
```
- Returns an **integer** representing the **count** of `obj` in `coll`.  

---

### **üìå Internal Working (How It Works?)**  
1. **Iterates through the entire collection**.  
2. **Compares each element** with `obj` using `.equals()` method.  
3. **Increments count** for each match.  
4. **Returns total count**.  
5. **Time Complexity: O(n)** (since every element is checked once).  

---

### **üìå Example: Counting Frequency of a Number**
```java
import java.util.*;

class FrequencyExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 2, 4, 2, 5, 2);

        int count = Collections.frequency(numbers, 2);
        System.out.println("Frequency of 2: " + count);
    }
}
```
### **üîπ Output:**
```
Frequency of 2: 4
```
‚úîÔ∏è **Counts how many times `2` appears in the list.**  

---

### **üìå Example: Counting Frequency of a String**
```java
import java.util.*;

class FrequencyStringExample {
    public static void main(String[] args) {
        List<String> colors = Arrays.asList("red", "blue", "green", "red", "yellow", "red");

        int count = Collections.frequency(colors, "red");
        System.out.println("Frequency of 'red': " + count);
    }
}
```
### **üîπ Output:**
```
Frequency of 'red': 3
```
‚úîÔ∏è **Counts occurrences of the string `"red"`.**  

---

### **üìå Real-World Use Case**
- **Counting the number of times a word appears in a text file.**  
- **Finding the most frequently purchased product in an e-commerce application.**  

---

# **üìå Summary Table**
| Method | Purpose | Time Complexity |
|--------|---------|----------------|
| `Collections.min(Collection<T> coll)` | Finds the smallest element. | `O(n)` |
| `Collections.max(Collection<T> coll)` | Finds the largest element. | `O(n)` |
| `Collections.frequency(Collection<T> coll, Object obj)` | Counts occurrences of an element. | `O(n)` |

---

# **Deep Dive into Next Three Methods of `Collections` Class**  

‚úÖ `Collections.fill(List<T> list, T obj)`  
‚úÖ `Collections.replaceAll(List<T> list, T oldVal, T newVal)`  
‚úÖ `Collections.copy(List<T> dest, List<T> src)`  

We will go step by step:  
üîπ **What the method does**  
üîπ **How it works internally**  
üîπ **Code examples**  
üîπ **Time complexity**  
üîπ **Real-world use cases**  

---

## **1Ô∏è‚É£ `Collections.fill(List<T> list, T obj)` (Replace All Elements with One Value)**  

### **üìå What It Does?**  
- Replaces **all elements** of the list with the **same value**.  
- Useful when we want to **reset** or **initialize** a list with a default value.  

### **üìå Syntax**
```java
Collections.fill(List<T> list, T obj);
```
- `list` ‚Üí The list to be modified.  
- `obj` ‚Üí The object to set in all positions.  

üö® **Important:** The `list` **must be mutable** (modifiable), otherwise it throws an exception!  

---

### **üìå Internal Working (How It Works?)**  
1. **Iterates through each index** of the list.  
2. **Replaces each element** with `obj`.  
3. **Returns nothing** (modifies the list directly).  
4. **Time Complexity: O(n)** (since every element is updated once).  

---

### **üìå Example: Filling a List with a Default Value**
```java
import java.util.*;

class FillExample {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

        Collections.fill(numbers, 0);
        System.out.println("List after fill: " + numbers);
    }
}
```
### **üîπ Output:**
```
List after fill: [0, 0, 0, 0, 0]
```
‚úîÔ∏è **All elements are replaced with `0`.**  

---

### **üìå Real-World Use Case**
- **Resetting a list** (e.g., clearing marks in a survey).  
- **Initializing a list** (e.g., filling a list with `null` values in a cache).  

---

## **2Ô∏è‚É£ `Collections.replaceAll(List<T> list, T oldVal, T newVal)` (Replace Specific Elements)**  

### **üìå What It Does?**  
- **Finds all occurrences** of `oldVal` in the list and **replaces them** with `newVal`.  
- **Does NOT change** elements that do not match `oldVal`.  

### **üìå Syntax**
```java
Collections.replaceAll(List<T> list, T oldVal, T newVal);
```
- `list` ‚Üí The list to modify.  
- `oldVal` ‚Üí The value to replace.  
- `newVal` ‚Üí The new value to set.  

---

### **üìå Internal Working (How It Works?)**  
1. **Iterates through the list** to find occurrences of `oldVal`.  
2. **If a match is found**, it **replaces** it with `newVal`.  
3. **Returns nothing** (modifies the list directly).  
4. **Time Complexity: O(n)** (each element is checked once).  

---

### **üìå Example: Replacing All `2`s with `99`**
```java
import java.util.*;

class ReplaceAllExample {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 2, 4, 2, 5));

        Collections.replaceAll(numbers, 2, 99);
        System.out.println("List after replaceAll: " + numbers);
    }
}
```
### **üîπ Output:**
```
List after replaceAll: [1, 99, 3, 99, 4, 99, 5]
```
‚úîÔ∏è **All `2`s are replaced with `99`.**  

---

### **üìå Example: Replacing Words in a List**
```java
import java.util.*;

class ReplaceAllStringExample {
    public static void main(String[] args) {
        List<String> words = new ArrayList<>(Arrays.asList("apple", "banana", "apple", "grape"));

        Collections.replaceAll(words, "apple", "mango");
        System.out.println("List after replaceAll: " + words);
    }
}
```
### **üîπ Output:**
```
List after replaceAll: [mango, banana, mango, grape]
```
‚úîÔ∏è **All `"apple"` entries are replaced with `"mango"`.**  

---

### **üìå Real-World Use Case**
- **Replacing censored words** in a list of comments.  
- **Updating incorrect data** (e.g., replacing a misspelled name).  

---

## **3Ô∏è‚É£ `Collections.copy(List<T> dest, List<T> src)` (Copy One List into Another)**  

### **üìå What It Does?**  
- Copies **all elements** from `src` (source) to `dest` (destination).  
- üö® **The destination list (`dest`) must have the same size or larger than the source (`src`)!**  

### **üìå Syntax**
```java
Collections.copy(List<T> dest, List<T> src);
```
- `dest` ‚Üí The list that will receive the copied elements.  
- `src` ‚Üí The list from which elements are copied.  

---

### **üìå Internal Working (How It Works?)**  
1. **Checks that `dest` has enough space** (throws an exception if not).  
2. **Iterates through `src`** and copies each element to `dest`.  
3. **Modifies `dest` in-place** (returns nothing).  
4. **Time Complexity: O(n)** (since each element is copied once).  

---

### **üìå Example: Copying One List into Another**
```java
import java.util.*;

class CopyExample {
    public static void main(String[] args) {
        List<Integer> src = Arrays.asList(1, 2, 3, 4, 5);
        List<Integer> dest = new ArrayList<>(Arrays.asList(0, 0, 0, 0, 0));

        Collections.copy(dest, src);
        System.out.println("Destination List after copy: " + dest);
    }
}
```
### **üîπ Output:**
```
Destination List after copy: [1, 2, 3, 4, 5]
```
‚úîÔ∏è **`dest` now contains all elements from `src`.**  

üö® **Important:**  
If `dest` has fewer elements than `src`, you will get an `IndexOutOfBoundsException`.  
So, always ensure `dest` has **at least the same size** as `src`.  

---

### **üìå Real-World Use Case**
- **Copying user settings** from one list to another.  
- **Backing up a list before making changes.**  

---

# **üìå Summary Table**
| Method | Purpose | Time Complexity |
|--------|---------|----------------|
| `Collections.fill(List<T>, T)` | Replaces all elements with a single value. | `O(n)` |
| `Collections.replaceAll(List<T>, T, T)` | Replaces all occurrences of a value. | `O(n)` |
| `Collections.copy(List<T>, List<T>)` | Copies one list into another. | `O(n)` |

---



# **üìå Chapter 9: Thread-Safety in Java Collections**
## **üîπ What is Thread-Safety in Java Collections?**
- **Thread-Safety** means that **multiple threads** can access a collection **without causing data inconsistency** or unexpected behavior.  
- In Java, **normal collections like `ArrayList`, `HashSet`, and `HashMap` are NOT thread-safe** because multiple threads can modify them at the same time, leading to **race conditions.**  
- Java provides **two solutions** for thread-safe collections:
  1. **Synchronized Collections** (Older Approach)
  2. **Concurrent Collections** (Modern Approach)

---

## **üîπ 1Ô∏è‚É£ Synchronized Collections (Old Approach)**
Java provides synchronized versions of collections using **`Collections.synchronizedXXX()`** methods.

### **üìå Example: Synchronized List**
```java
import java.util.*;

class SynchronizedListExample {
    public static void main(String[] args) {
        List<Integer> list = Collections.synchronizedList(new ArrayList<>());

        list.add(1);
        list.add(2);
        list.add(3);

        synchronized (list) {  // Required for safe iteration
            for (int num : list) {
                System.out.println(num);
            }
        }
    }
}
```
‚úîÔ∏è **Problems with Synchronized Collections:**  
- **Slow Performance:** Because it locks the entire collection.  
- **Manual Synchronization Required:** You must manually synchronize while iterating (`synchronized` block).  
- **Better Alternative?** ‚úÖ **Use Concurrent Collections!**  

---

## **üîπ 2Ô∏è‚É£ Concurrent Collections (Modern Approach)**
Java introduced the **`java.util.concurrent`** package to provide **faster and better thread-safe collections.**  

üöÄ **Key Concurrent Collections:**
| Collection | Type | Feature |
|------------|------|---------|
| `CopyOnWriteArrayList` | **List** | **Thread-Safe ArrayList** (No Manual Synchronization Needed) |
| `CopyOnWriteArraySet` | **Set** | **Thread-Safe HashSet** (Works Like CopyOnWriteArrayList) |
| `ConcurrentHashMap` | **Map** | **Thread-Safe HashMap** (Uses Lock Stripes) |
| `ConcurrentSkipListSet` | **Set** | **Thread-Safe Sorted Set** |
| `ConcurrentSkipListMap` | **Map** | **Thread-Safe Sorted Map** |

---

## **üîπ 3Ô∏è‚É£ CopyOnWriteArrayList (Thread-Safe ArrayList)**
**üìå What is it?**
- It is a **thread-safe version** of `ArrayList` that allows multiple threads to read the list **without locking**.  
- **Whenever you modify it (add, remove, update), it creates a new copy of the list!**  

**üìå When to Use?**
- When **reads are more frequent** than writes (e.g., a list of online users in a chat app).  

### **Example: CopyOnWriteArrayList**
```java
import java.util.concurrent.CopyOnWriteArrayList;

class CopyOnWriteArrayListExample {
    public static void main(String[] args) {
        CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();

        list.add(1);
        list.add(2);
        list.add(3);

        for (Integer num : list) {  // No need to manually synchronize
            System.out.println(num);
        }
    }
}
```
‚úîÔ∏è **Advantages:**
- **Thread-Safe without Locks** (Multiple threads can read at the same time).  
- **No ConcurrentModificationException** (Unlike `ArrayList`, which throws errors during modification).  
‚úîÔ∏è **Disadvantages:**
- **Memory Overhead** (Creates a new copy every time you modify it).  

---

## **üîπ 4Ô∏è‚É£ CopyOnWriteArraySet (Thread-Safe HashSet)**
- It is a **thread-safe version of `HashSet`** and works **just like `CopyOnWriteArrayList`.**  
- **Each write operation (add/remove) creates a new copy of the set.**  

**üìå Example:**
```java
import java.util.concurrent.CopyOnWriteArraySet;

class CopyOnWriteArraySetExample {
    public static void main(String[] args) {
        CopyOnWriteArraySet<Integer> set = new CopyOnWriteArraySet<>();

        set.add(10);
        set.add(20);
        set.add(30);

        for (Integer num : set) {
            System.out.println(num);
        }
    }
}
```
‚úîÔ∏è **Advantage:** No need for manual synchronization.  
‚úîÔ∏è **Disadvantage:** **Slower writes** due to copy creation.  

---

## **üîπ 5Ô∏è‚É£ ConcurrentHashMap (Thread-Safe HashMap)**
**üìå What is it?**
- A **thread-safe version of `HashMap`** that allows **fast reads and writes using lock stripping.**  
- Instead of locking the **entire map**, it locks **only specific parts (buckets).**  

**üìå Example:**
```java
import java.util.concurrent.ConcurrentHashMap;

class ConcurrentHashMapExample {
    public static void main(String[] args) {
        ConcurrentHashMap<Integer, String> map = new ConcurrentHashMap<>();

        map.put(1, "A");
        map.put(2, "B");
        map.put(3, "C");

        for (Integer key : map.keySet()) {
            System.out.println(key + " -> " + map.get(key));
        }
    }
}
```
‚úîÔ∏è **Advantages:**
- **Faster than `Hashtable`** (does not lock entire map).  
- **No ConcurrentModificationException** (safe for multi-threading).  

---

## **üîπ 6Ô∏è‚É£ ConcurrentSkipListSet (Thread-Safe Sorted Set)**
- A **thread-safe version of `TreeSet`** (keeps elements sorted).  
- Uses a **Skip List data structure** instead of a Red-Black tree.  

**üìå Example:**
```java
import java.util.concurrent.ConcurrentSkipListSet;

class ConcurrentSkipListSetExample {
    public static void main(String[] args) {
        ConcurrentSkipListSet<Integer> set = new ConcurrentSkipListSet<>();

        set.add(30);
        set.add(10);
        set.add(20);

        for (Integer num : set) {
            System.out.println(num);
        }
    }
}
```
‚úîÔ∏è **Advantage:** Automatically **keeps elements sorted** while being **thread-safe.**  

---

## **üîπ 7Ô∏è‚É£ Performance Comparison: Synchronized vs Concurrent Collections**
| Collection | Thread-Safety Type | Performance |
|------------|------------------|-------------|
| `Collections.synchronizedList()` | Full Locking | üö® **Slow (Locks Entire Collection)** |
| `CopyOnWriteArrayList` | No Lock for Read | ‚úÖ **Fast Reads, Slow Writes** |
| `ConcurrentHashMap` | Partial Locking | ‚úÖ **Fast Read & Write** |
| `Hashtable` | Full Locking | üö® **Slow (Locks Whole Table)** |

‚úîÔ∏è **Best Choice?**  
- **Use `ConcurrentHashMap` instead of `Hashtable`** for better performance.  
- **Use `CopyOnWriteArrayList` for thread-safe lists with frequent reads.**  

---

# **üìå Summary**
| Collection | Type | Thread-Safe? | Best For |
|------------|------|-------------|----------|
| `CopyOnWriteArrayList` | **List** | ‚úÖ Yes | **Frequent Reads, Rare Writes** |
| `CopyOnWriteArraySet` | **Set** | ‚úÖ Yes | **Frequent Reads, Rare Writes** |
| `ConcurrentHashMap` | **Map** | ‚úÖ Yes | **High-Performance Thread-Safe Map** |
| `ConcurrentSkipListSet` | **Set** | ‚úÖ Yes | **Sorted Set in Multi-threading** |

üöÄ **Conclusion:**  
- Use **Concurrent Collections** instead of `synchronized` collections for **better performance.**  
- Choose **`CopyOnWriteArrayList` for frequent reads** and **`ConcurrentHashMap` for multi-threaded key-value storage.**  

---

# **üìå Chapter 10: Best Practices and Performance Optimization**  

## **üîπ What is Best Practices and Performance Optimization in Collections?**  
Java Collections Framework provides a **wide range of data structures** to store and manipulate data efficiently. However, **using them correctly** is **crucial** for writing efficient, maintainable, and high-performance code.  

üìå **Best practices** help you avoid common pitfalls, reduce errors, and make your code **clean and maintainable.**  
üìå **Performance optimization** ensures your collections work **efficiently**, using the least memory and CPU power.

---

## **üîπ Why is Performance Optimization Important?**  
- Collections are **used everywhere** in Java applications (e.g., lists, sets, maps).  
- **Poor choice of collection** can **slow down your application** significantly.  
- **Incorrect usage** can lead to **memory leaks, unnecessary CPU usage, and crashes.**  
- **Choosing the right collection** improves speed and reduces resource usage.  

---

## **üîπ Best Practices for Java Collections**
### **1Ô∏è‚É£ Choose the Right Collection for the Right Use Case**
‚úÖ **Use `ArrayList` when you need fast retrieval and random access.**  
‚úÖ **Use `LinkedList` when you need frequent insertions/deletions.**  
‚úÖ **Use `HashSet` when unique elements are required and order doesn't matter.**  
‚úÖ **Use `TreeSet` when unique elements are needed in sorted order.**  
‚úÖ **Use `HashMap` for fast key-value lookups.**  
‚úÖ **Use `Concurrent Collections` for multi-threading instead of synchronized collections.**  

---

### **2Ô∏è‚É£ Prefer Immutable Collections When Possible**
- If a collection **does not need to change**, use **unmodifiable collections** to prevent accidental modifications.  
- Java provides **`Collections.unmodifiableList()`**, **`Collections.unmodifiableSet()`**, and **`Collections.unmodifiableMap()`**.  

```java
import java.util.*;

class ImmutableCollectionExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
        List<String> immutableList = Collections.unmodifiableList(list);

        immutableList.add("D"); // This will throw UnsupportedOperationException
    }
}
```
‚úîÔ∏è **Advantage:** Prevents accidental modification, making the code more **secure** and **predictable**.  

---

### **3Ô∏è‚É£ Minimize Unnecessary Autoboxing and Unboxing**
- Java automatically **converts primitives** (int, double, etc.) into their wrapper classes (`Integer`, `Double`), which **causes performance overhead.**  
- **Always prefer primitive collections** like `int[]` over `List<Integer>` if boxing/unboxing is unnecessary.  

```java
List<Integer> list = new ArrayList<>();  // Slower, due to autoboxing
list.add(10); // Converts int to Integer

int num = list.get(0); // Unboxes Integer to int
```
‚úîÔ∏è **Solution:** Use `IntStream` or `Arrays` for primitive values instead of collections.  

---

### **4Ô∏è‚É£ Avoid Memory Leaks with Collections**
- **Problem:** If you keep adding elements but **never remove them**, memory usage will increase indefinitely.  
- **Solution:** Always **clear large collections** when they are no longer needed.  

```java
List<String> list = new ArrayList<>();
list.add("data1");
list.add("data2");

// Clear collection when not needed
list.clear();  
```
‚úîÔ∏è **Advantage:** Reduces memory footprint and avoids **OutOfMemoryError**.

---

### **5Ô∏è‚É£ Use `computeIfAbsent()` for Efficient Map Updates**
Instead of checking for null manually, use **`computeIfAbsent()`** to optimize adding values to a `Map`.  

```java
import java.util.HashMap;
import java.util.Map;

class ComputeIfAbsentExample {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();

        // Instead of checking manually, use computeIfAbsent
        map.computeIfAbsent("A", key -> 10);
        map.computeIfAbsent("B", key -> 20);

        System.out.println(map); // {A=10, B=20}
    }
}
```
‚úîÔ∏è **Advantage:** Reduces redundant `if-else` checks and improves readability.  

---

### **6Ô∏è‚É£ Use Streams and Parallel Processing for Large Collections**
- Instead of **looping manually**, use **Java Streams API** for better performance.  
- **Parallel Streams** can be used to **process large datasets faster** using multiple CPU cores.  

```java
import java.util.*;
import java.util.stream.Collectors;

class StreamExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

        // Convert all numbers to square using Streams
        List<Integer> squares = numbers.stream()
                                       .map(n -> n * n)
                                       .collect(Collectors.toList());

        System.out.println(squares); // [1, 4, 9, 16, 25]
    }
}
```
‚úîÔ∏è **Advantage:** Faster, more readable, and concise compared to traditional loops.  

---

### **7Ô∏è‚É£ Use `containsKey()` Instead of `get()` for Maps**
- Using `map.get(key) != null` can be **slower** than directly checking with `containsKey()`.  
- **Best practice:** **Use `containsKey()` before calling `get()`**.  

```java
Map<String, Integer> map = new HashMap<>();

if (map.containsKey("A")) {
    System.out.println(map.get("A"));
}
```
‚úîÔ∏è **Advantage:** Improves performance in large maps.  

---

# **üìå When to Use Which Collection? (Deep Explanation)**  

Choosing the right **Java Collection** is crucial for building **efficient** and **high-performing** applications. The **wrong choice** can lead to **slow performance, memory issues, and unnecessary complexity**.  

In this section, we will **deeply analyze** when to use each **List, Set, Queue, and Map** based on different use cases.  

---

# **üîπ List Interface: When to Use?**  
A **List** is an **ordered collection** that **allows duplicate elements**.  
Use a `List<T>` when:  
‚úîÔ∏è You need to maintain **insertion order**.  
‚úîÔ∏è You need **indexed access** (access elements by position).  
‚úîÔ∏è You need to allow **duplicates**.  

## **1Ô∏è‚É£ `ArrayList<T>` ‚Äì Fast Retrieval, Slow Insert/Delete**
üîπ **Best for:** **Read-heavy applications where elements are accessed frequently.**  
üîπ **Avoid if:** You need frequent **insertions/deletions in the middle**.  

| **Operation** | **Time Complexity** |
|--------------|------------------|
| **Access (get(index))** | O(1) ‚úÖ (Super fast) |
| **Insert (add at end)** | O(1) ‚úÖ |
| **Insert/Delete in middle** | O(n) ‚ùå (Slow shifting required) |

**üìå When to Use?**  
‚úîÔ∏è When you need **fast random access** to elements using indexes.  
‚úîÔ∏è When the **insertion order** should be maintained.  
‚úîÔ∏è Example: **Reading customer reviews, fetching product lists in an e-commerce website.**  

```java
List<String> names = new ArrayList<>();
names.add("Alice");  
names.add("Bob"); 
names.add("Charlie");
System.out.println(names.get(1)); // Output: Bob
```

---

## **2Ô∏è‚É£ `LinkedList<T>` ‚Äì Fast Insert/Delete, Slow Access**
üîπ **Best for:** **Insert/delete-heavy applications.**  
üîπ **Avoid if:** You need frequent **random access (get(index))**.  

| **Operation** | **Time Complexity** |
|--------------|------------------|
| **Access (get(index))** | O(n) ‚ùå (Slow, must traverse the list) |
| **Insert/Delete in middle** | O(1) ‚úÖ (Just update pointers) |

**üìå When to Use?**  
‚úîÔ∏è When you frequently **insert/delete elements in the middle**.  
‚úîÔ∏è Example: **Implementing undo/redo feature, task schedulers.**  

```java
List<String> tasks = new LinkedList<>();
tasks.add("Task 1");
tasks.add("Task 2");
tasks.add(1, "New Task in between");
System.out.println(tasks); 
```

---

## **3Ô∏è‚É£ `Vector<T>` ‚Äì Thread-Safe, But Rarely Used**
üîπ **Best for:** **Thread-safe operations (legacy, use Concurrent collections instead).**  
üîπ **Avoid if:** You don‚Äôt need synchronization.  

| **Operation** | **Time Complexity** |
|--------------|------------------|
| **Access (get(index))** | O(1) ‚úÖ |
| **Insert/Delete in middle** | O(n) ‚ùå (Slow shifting required) |
| **Thread-Safety** | Yes ‚úÖ |

**üìå When to Use?**  
‚úîÔ∏è When you need a **synchronized** version of an `ArrayList`.  
‚úîÔ∏è Example: **Multi-threaded application needing synchronized list.**  

---

## **4Ô∏è‚É£ `Stack<T>` ‚Äì Last-In-First-Out (LIFO)**
üîπ **Best for:** **Undo/Redo, Backtracking, Expression Evaluation.**  
üîπ **Avoid if:** You need **random access** to elements.  

| **Operation** | **Time Complexity** |
|--------------|------------------|
| **Push (add element)** | O(1) ‚úÖ |
| **Pop (remove last element)** | O(1) ‚úÖ |

**üìå When to Use?**  
‚úîÔ∏è When you need **LIFO behavior**.  
‚úîÔ∏è Example: **Undo feature in text editors, evaluating expressions.**  

```java
Stack<Integer> stack = new Stack<>();
stack.push(10);
stack.push(20);
System.out.println(stack.pop()); // Output: 20 (LIFO)
```

---

# **üîπ Set Interface: When to Use?**  
A **Set** is a collection that **does not allow duplicate elements**.  
Use a `Set<T>` when:  
‚úîÔ∏è You need **unique elements only**.  
‚úîÔ∏è You don‚Äôt care about **insertion order** (except `LinkedHashSet`).  
‚úîÔ∏è You need **fast lookups**.  

## **1Ô∏è‚É£ `HashSet<T>` ‚Äì Fastest Set for Unordered Unique Elements**
üîπ **Best for:** **High-performance unique element storage.**  
üîπ **Avoid if:** You need to maintain order.  

| **Operation** | **Time Complexity** |
|--------------|------------------|
| **Insert/Delete/Search** | O(1) ‚úÖ |

**üìå When to Use?**  
‚úîÔ∏è When you need **unique elements with fast performance**.  
‚úîÔ∏è Example: **Removing duplicate usernames in a system.**  

```java
Set<String> users = new HashSet<>();
users.add("Alice");
users.add("Bob");
users.add("Alice"); // Duplicate ignored
System.out.println(users); // Output: [Alice, Bob]
```

---

## **2Ô∏è‚É£ `LinkedHashSet<T>` ‚Äì Maintains Insertion Order**
üîπ **Best for:** **Unique elements + maintaining order.**  
üîπ **Avoid if:** Order doesn‚Äôt matter.  

| **Operation** | **Time Complexity** |
|--------------|------------------|
| **Insert/Delete/Search** | O(1) ‚úÖ |

**üìå When to Use?**  
‚úîÔ∏è When you need **unique elements but order matters**.  
‚úîÔ∏è Example: **Maintaining a unique list of visited pages in a browser.**  

```java
Set<String> pages = new LinkedHashSet<>();
pages.add("Home");
pages.add("About");
pages.add("Contact");
System.out.println(pages); // Output: [Home, About, Contact]
```

---

## **3Ô∏è‚É£ `TreeSet<T>` ‚Äì Sorted Unique Elements**
üîπ **Best for:** **Sorted unique elements (ascending order by default).**  
üîπ **Avoid if:** You don‚Äôt need sorting (Use `HashSet` instead).  

| **Operation** | **Time Complexity** |
|--------------|------------------|
| **Insert/Delete/Search** | O(log n) ‚ùå (Slower than HashSet) |

**üìå When to Use?**  
‚úîÔ∏è When you need **unique elements in sorted order**.  
‚úîÔ∏è Example: **Storing sorted employee IDs.**  

```java
Set<Integer> ids = new TreeSet<>();
ids.add(3);
ids.add(1);
ids.add(2);
System.out.println(ids); // Output: [1, 2, 3]
```

---

# **üîπ Map Interface: When to Use?**  
A **Map** stores **key-value pairs** for fast lookups.  
Use a `Map<K, V>` when:  
‚úîÔ∏è You need to **map unique keys to values**.  
‚úîÔ∏è You need **fast lookups by key**.  

## **1Ô∏è‚É£ `HashMap<K, V>` ‚Äì Fastest Key-Value Lookup (Unordered)**
üîπ **Best for:** **Fast key-value storage.**  
üîπ **Avoid if:** You need sorted order.  

| **Operation** | **Time Complexity** |
|--------------|------------------|
| **Insert/Delete/Search** | O(1) ‚úÖ |

```java
Map<String, Integer> map = new HashMap<>();
map.put("Alice", 25);
map.put("Bob", 30);
System.out.println(map.get("Alice")); // Output: 25
```

---

## **2Ô∏è‚É£ `TreeMap<K, V>` ‚Äì Sorted Key-Value Mapping**
üîπ **Best for:** **Sorted key-value pairs.**  
üîπ **Avoid if:** Sorting is unnecessary.  

| **Operation** | **Time Complexity** |
|--------------|------------------|
| **Insert/Delete/Search** | O(log n) ‚ùå (Slower than HashMap) |

```java
Map<Integer, String> treeMap = new TreeMap<>();
treeMap.put(2, "B");
treeMap.put(1, "A");
System.out.println(treeMap); // Output: {1=A, 2=B}
```

---

# **üîπ Conclusion**
| **Collection Type** | **Best For** |
|------------------|------------|
| `ArrayList<T>` | Fast access, slow insert/delete |
| `LinkedList<T>` | Fast insert/delete, slow access |
| `HashSet<T>` | Fast unique elements (unordered) |
| `TreeSet<T>` | Unique sorted elements |
| `HashMap<K,V>` | Fastest key-value storage |
| `TreeMap<K,V>` | Sorted key-value pairs |

---

# **üìå Performance Considerations for Different Data Structures (Deep Explanation)**  

Choosing the **right data structure** is not just about functionality‚Äîit‚Äôs also about **performance**.  
Each **Collection** has different **strengths and weaknesses** depending on **time complexity, memory usage, and threading support**.  

In this section, we will analyze the **performance of Lists, Sets, Queues, and Maps** in **depth** and compare their operations.  

---

## **üîπ Understanding Performance Factors**  
The performance of a data structure depends on:  
‚úîÔ∏è **Time Complexity** - How fast the operations (insert, search, delete) are.  
‚úîÔ∏è **Memory Usage** - How much space the data structure consumes.  
‚úîÔ∏è **Thread-Safety** - Whether it supports multi-threading.  
‚úîÔ∏è **Sorting Needs** - Whether elements are sorted automatically.  

---

# **üîπ Performance Analysis of List Implementations**  

## **1Ô∏è‚É£ `ArrayList<T>` ‚Äì Fast Random Access, Slow Insert/Delete**  
**‚úîÔ∏è Best For:** **Fast read-heavy operations**  
**‚ùå Avoid If:** **Frequent insert/delete in the middle**  

| **Operation**       | **Time Complexity** | **Explanation** |
|---------------------|--------------------|----------------|
| **Access (get(i))** | O(1) ‚úÖ | Direct index-based lookup. |
| **Insert at End**   | O(1) ‚úÖ | If capacity allows, it‚Äôs instant. |
| **Insert in Middle** | O(n) ‚ùå | All elements after must shift. |
| **Remove by Index** | O(n) ‚ùå | Elements shift left to fill gap. |
| **Memory Usage** | Medium | Uses contiguous memory. |

üìå **Performance Tip:** Use **ArrayList** when you need **fast lookups** and **less insertion/deletion**.  

---

## **2Ô∏è‚É£ `LinkedList<T>` ‚Äì Fast Insert/Delete, Slow Access**  
**‚úîÔ∏è Best For:** **Insert/delete-heavy operations**  
**‚ùå Avoid If:** **Frequent random access needed**  

| **Operation**       | **Time Complexity** | **Explanation** |
|---------------------|--------------------|----------------|
| **Access (get(i))** | O(n) ‚ùå | Must traverse nodes one by one. |
| **Insert at End**   | O(1) ‚úÖ | Just update last node‚Äôs pointer. |
| **Insert in Middle** | O(1) ‚úÖ | If node reference is known. |
| **Remove by Index** | O(1) ‚úÖ | Just update pointers. |
| **Memory Usage** | High ‚ùå | Stores extra pointers (next/prev). |

üìå **Performance Tip:** Use **LinkedList** when you need **frequent insertions/deletions** and **don‚Äôt need fast random access**.  

---

## **3Ô∏è‚É£ `Vector<T>` ‚Äì Thread-Safe but Slower than ArrayList**  
**‚úîÔ∏è Best For:** **Multi-threaded applications requiring a List**  
**‚ùå Avoid If:** **Single-threaded applications (use ArrayList instead)**  

| **Operation**       | **Time Complexity** | **Explanation** |
|---------------------|--------------------|----------------|
| **Access (get(i))** | O(1) ‚úÖ | Same as ArrayList. |
| **Insert at End**   | O(1) ‚úÖ | Same as ArrayList. |
| **Insert in Middle** | O(n) ‚ùå | Shifting needed. |
| **Thread-Safety** | Yes ‚úÖ | Uses synchronization (slower). |

üìå **Performance Tip:** Use **Vector** only if **synchronization is needed**, otherwise prefer **ArrayList**.  

---

## **4Ô∏è‚É£ `Stack<T>` ‚Äì LIFO Performance**  
**‚úîÔ∏è Best For:** **Last-In-First-Out (LIFO) operations**  
**‚ùå Avoid If:** **Random access is needed**  

| **Operation**       | **Time Complexity** | **Explanation** |
|---------------------|--------------------|----------------|
| **Push (add)** | O(1) ‚úÖ | Just add at the top. |
| **Pop (remove top)** | O(1) ‚úÖ | Remove top element only. |
| **Search (contains)** | O(n) ‚ùå | Must check each element. |

üìå **Performance Tip:** Use **Stack** only for **LIFO-based operations** like **undo/redo**.  

---

# **üîπ Performance Analysis of Set Implementations**  

## **1Ô∏è‚É£ `HashSet<T>` ‚Äì Fastest Unique Element Storage**  
**‚úîÔ∏è Best For:** **Fast unique element storage**  
**‚ùå Avoid If:** **Sorting is required**  

| **Operation**       | **Time Complexity** | **Explanation** |
|---------------------|--------------------|----------------|
| **Insert/Delete** | O(1) ‚úÖ | Uses **hashing** for quick access. |
| **Search (contains)** | O(1) ‚úÖ | Hash lookup is very fast. |
| **Sorting** | Not Supported ‚ùå | No order maintained. |

üìå **Performance Tip:** Use **HashSet** when you need **unique elements with fast lookups**.  

---

## **2Ô∏è‚É£ `TreeSet<T>` ‚Äì Unique + Sorted**  
**‚úîÔ∏è Best For:** **Maintaining unique elements in sorted order**  
**‚ùå Avoid If:** **You don‚Äôt need sorting**  

| **Operation**       | **Time Complexity** | **Explanation** |
|---------------------|--------------------|----------------|
| **Insert/Delete** | O(log n) ‚ùå | Uses **Red-Black Tree** for sorting. |
| **Search (contains)** | O(log n) ‚ùå | Must traverse the tree. |
| **Sorting** | Yes ‚úÖ | Elements are always sorted. |

üìå **Performance Tip:** Use **TreeSet** when you need **sorting** but can accept **slightly slower performance**.  

---

# **üîπ Performance Analysis of Queue Implementations**  

## **1Ô∏è‚É£ `PriorityQueue<T>` ‚Äì Min-Heap Implementation**  
**‚úîÔ∏è Best For:** **Processing elements based on priority**  
**‚ùå Avoid If:** **You need FIFO behavior**  

| **Operation**       | **Time Complexity** | **Explanation** |
|---------------------|--------------------|----------------|
| **Insert (add)** | O(log n) ‚ùå | Maintains heap property. |
| **Remove (poll)** | O(log n) ‚ùå | Heap must be restructured. |
| **Peek (min element)** | O(1) ‚úÖ | Fast access to smallest element. |

üìå **Performance Tip:** Use **PriorityQueue** for **task scheduling, job processing, etc.**  

---

# **üîπ Performance Analysis of Map Implementations**  

## **1Ô∏è‚É£ `HashMap<K, V>` ‚Äì Fastest Key-Value Storage**  
**‚úîÔ∏è Best For:** **Fast key-value lookup**  
**‚ùå Avoid If:** **Sorting is needed**  

| **Operation**       | **Time Complexity** | **Explanation** |
|---------------------|--------------------|----------------|
| **Insert/Delete** | O(1) ‚úÖ | Uses **hashing** for fast access. |
| **Search (containsKey)** | O(1) ‚úÖ | Direct hash lookup. |
| **Sorting** | Not Supported ‚ùå | Unordered storage. |

üìå **Performance Tip:** Use **HashMap** for **fast key-based lookups**.  

---

## **2Ô∏è‚É£ `TreeMap<K, V>` ‚Äì Sorted Key-Value Mapping**  
**‚úîÔ∏è Best For:** **Maintaining sorted keys**  
**‚ùå Avoid If:** **Sorting is unnecessary**  

| **Operation**       | **Time Complexity** | **Explanation** |
|---------------------|--------------------|----------------|
| **Insert/Delete** | O(log n) ‚ùå | Uses **Red-Black Tree**. |
| **Search (containsKey)** | O(log n) ‚ùå | Tree traversal needed. |
| **Sorting** | Yes ‚úÖ | Always sorted. |

üìå **Performance Tip:** Use **TreeMap** when you need **sorted key-value pairs**.  

---

# **üîπ Conclusion: Choosing the Best Data Structure**  

| **Requirement** | **Best Choice** |
|----------------|---------------|
| **Fast Read (index-based access)** | `ArrayList` ‚úÖ |
| **Frequent Insert/Delete** | `LinkedList` ‚úÖ |
| **Unique Elements (Fast Access)** | `HashSet` ‚úÖ |
| **Unique Elements (Sorted)** | `TreeSet` ‚úÖ |
| **Fast Key-Value Storage** | `HashMap` ‚úÖ |
| **Sorted Key-Value Mapping** | `TreeMap` ‚úÖ |
| **FIFO Processing** | `Queue` ‚úÖ |
| **LIFO Processing** | `Stack` ‚úÖ |

---

# **üìå Avoiding NullPointerException in Collections (Deep and Easy Explanation)**  

A **NullPointerException (NPE)** occurs when you try to **access a method or property of a `null` object**.  
In **Java Collections**, NPEs often happen when:  
‚úîÔ∏è You try to **add null values** into a collection that **doesn‚Äôt support nulls** (e.g., `TreeSet`, `TreeMap`).  
‚úîÔ∏è You try to **access an element from a null collection**.  
‚úîÔ∏è You forget to **initialize a collection before using it**.  
‚úîÔ∏è You remove elements without checking if the collection is empty.  

---

# **üîπ Common Scenarios Where NullPointerException Happens in Collections**  

## **1Ô∏è‚É£ Using a Null Collection Reference**
üìå **Problem:** Trying to access or modify a collection that is not initialized.  

```java
List<String> list = null;
list.add("Hello"); // ‚ùå NullPointerException! list is null
```

‚úÖ **Solution:** Always initialize collections before use.  

```java
List<String> list = new ArrayList<>(); // ‚úÖ Safe initialization
list.add("Hello");
```

---

## **2Ô∏è‚É£ Adding Null Values into a Collection that Doesn‚Äôt Allow Nulls**
üìå **Problem:** Some collections do **not** allow `null` values.  

```java
Set<String> treeSet = new TreeSet<>();
treeSet.add(null); // ‚ùå NullPointerException! TreeSet does not allow nulls
```

‚úÖ **Solution:** Use `HashSet` or `ArrayList` if `null` values are needed.  

```java
Set<String> hashSet = new HashSet<>();
hashSet.add(null); // ‚úÖ Allowed in HashSet
```

---

## **3Ô∏è‚É£ Accessing a Null Element in a Collection**
üìå **Problem:** Getting an element that is `null` and then calling a method on it.  

```java
List<String> names = new ArrayList<>();
names.add(null);

System.out.println(names.get(0).length()); // ‚ùå NullPointerException!
```

‚úÖ **Solution:** Always check for `null` before using an element.  

```java
if (names.get(0) != null) {
    System.out.println(names.get(0).length()); // ‚úÖ Safe
}
```

---

## **4Ô∏è‚É£ Forgetting to Handle Null Return Values**
üìå **Problem:** Some map methods return `null` if the key is not found.  

```java
Map<String, String> map = new HashMap<>();
String value = map.get("key"); // May return null

System.out.println(value.length()); // ‚ùå NullPointerException!
```

‚úÖ **Solution:** Use `getOrDefault()` or check for `null`.  

```java
String value = map.getOrDefault("key", "Default");
System.out.println(value.length()); // ‚úÖ Safe

// OR
if (value != null) {
    System.out.println(value.length());
}
```

---

## **5Ô∏è‚É£ Using an Empty Collection Instead of Null**
üìå **Problem:** Returning `null` from a method instead of an empty collection.  

```java
public List<String> getNames() {
    return null; // ‚ùå Bad practice
}

List<String> names = getNames();
System.out.println(names.size()); // ‚ùå NullPointerException!
```

‚úÖ **Solution:** Return an **empty collection** instead of `null`.  

```java
public List<String> getNames() {
    return new ArrayList<>(); // ‚úÖ Good practice
}

List<String> names = getNames();
System.out.println(names.size()); // ‚úÖ Works fine (prints 0)
```

---

## **6Ô∏è‚É£ Checking for Null Before Removing Elements**
üìå **Problem:** Trying to remove elements from a `null` collection.  

```java
List<String> list = null;
list.remove("Hello"); // ‚ùå NullPointerException!
```

‚úÖ **Solution:** Check for `null` before removing elements.  

```java
if (list != null) {
    list.remove("Hello"); // ‚úÖ Safe
}
```

---

# **üîπ Best Practices to Avoid NullPointerException in Collections**  

‚úîÔ∏è **Always initialize collections before use** (`new ArrayList<>();`).  
‚úîÔ∏è **Use `getOrDefault()` for Maps** instead of directly using `get()`.  
‚úîÔ∏è **Check for `null` before accessing or modifying collections**.  
‚úîÔ∏è **Return empty collections instead of `null`** in methods.  
‚úîÔ∏è **Prefer `Optional<T>` for return values that may be `null`**.  

---

# **üìå Optimizing Memory and CPU Usage in Collections (Deep & Easy Explanation)**  

Java collections are powerful, but if **not used efficiently**, they can consume **more memory and CPU** than necessary.  
To improve **performance**, follow these **best practices** to optimize **memory usage and processing speed**.  

---

# **üîπ 1Ô∏è‚É£ Choose the Right Collection Type**  
Using the **wrong collection type** leads to **high memory usage** and **slow performance**.  

### **üí° Example: Using `ArrayList` vs. `LinkedList`**  
üìå If **more searching is needed**, use **`ArrayList`** because it supports **fast index-based access**.  
üìå If **frequent insertions/deletions** happen, use **`LinkedList`**, because it avoids shifting elements.  

```java
List<Integer> arrayList = new ArrayList<>(); // ‚úÖ Best for fast retrieval
List<Integer> linkedList = new LinkedList<>(); // ‚úÖ Best for frequent insertions/deletions
```

---

# **üîπ 2Ô∏è‚É£ Avoid Unnecessary Memory Allocation**
Some collections **resize dynamically**, which can cause **performance overhead**.  

### **üí° Example: Setting Initial Capacity for Lists**
üìå By default, `ArrayList` starts with **10 elements** and resizes when full.  
üìå If you **already know the required size**, set the **initial capacity** to **avoid resizing overhead**.  

```java
List<Integer> list = new ArrayList<>(100); // ‚úÖ Optimized for 100 elements
```

### **üí° Example: Using `HashMap` with Proper Capacity**
üìå `HashMap` has a **default capacity of 16** and **grows when 75% full**.  
üìå If you know you'll store **1000 elements**, set capacity properly:  

```java
Map<String, Integer> map = new HashMap<>(1000, 0.75f); // ‚úÖ Prevents unnecessary resizing
```

---

# **üîπ 3Ô∏è‚É£ Use `Collections.unmodifiableList()` to Save Memory**
If a collection **doesn‚Äôt need modification**, **use immutable collections** to **save memory** and **avoid accidental changes**.  

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
List<String> unmodifiableNames = Collections.unmodifiableList(names); // ‚úÖ More efficient
```

---

# **üîπ 4Ô∏è‚É£ Use Primitive Arrays Instead of Collections (If Possible)**
Collections store **objects**, which take **more memory**.  
If dealing with **only numbers**, use **primitive arrays (`int[]`)** instead of **`ArrayList<Integer>`**.  

```java
int[] numbers = new int[1000]; // ‚úÖ Uses less memory than ArrayList<Integer>
```

---

# **üîπ 5Ô∏è‚É£ Remove Unused Elements to Free Up Memory**
If a collection **grows dynamically** and elements are removed, it may still hold **extra memory**.  

### **üí° Example: Trim `ArrayList` After Removing Elements**
```java
ArrayList<Integer> list = new ArrayList<>(100);
list.add(10);
list.add(20);
list.remove(1);

list.trimToSize(); // ‚úÖ Shrinks the ArrayList to free memory
```

---

# **üîπ 6Ô∏è‚É£ Use `WeakHashMap` for Temporary Caching**
A **regular `HashMap` keeps objects in memory forever**, even if they're no longer needed.  
A **`WeakHashMap`** automatically **removes unused keys**, helping reduce memory usage.  

```java
Map<String, Integer> cache = new WeakHashMap<>();
```

---

# **üîπ 7Ô∏è‚É£ Use `Concurrent Collections` for Multi-threading**
If **multiple threads** access a collection, **avoid using `synchronized` manually**.  
Use **thread-safe collections** like **`ConcurrentHashMap`** instead of manually locking a **`HashMap`**.  

```java
Map<String, Integer> concurrentMap = new ConcurrentHashMap<>(); // ‚úÖ Faster than synchronized HashMap
```

---

# **üîπ 8Ô∏è‚É£ Prefer `for-each` Instead of Traditional Loops**
A **for-each loop** is **faster and uses less memory** than manually iterating with an **Iterator**.  

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// ‚úÖ Better performance
for (String name : names) {
    System.out.println(name);
}

// ‚ùå Slower due to extra iterator object
Iterator<String> it = names.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
}
```

---

# **üîπ 9Ô∏è‚É£ Avoid Auto-Boxing in Collections**
Collections store **only objects**, so primitive types (**`int`, `double`**) are **converted into objects** (`Integer`, `Double`).  
This is called **auto-boxing** and consumes **more memory**.  

### **üí° Example: Using `int` vs. `Integer`**
```java
List<Integer> list = new ArrayList<>(); 
list.add(10);  // ‚ùå Auto-boxing happens, uses more memory

int num = list.get(0); // ‚ùå Auto-unboxing happens
```

‚úÖ **Solution:** If dealing with **large numeric data**, consider **primitive arrays (`int[]`)**.  

---

# **‚úÖ Final Summary: Best Ways to Optimize Collections**  

‚úÖ Use **the right collection** for the right task.  
‚úÖ Set **initial capacity** to avoid resizing overhead.  
‚úÖ Use **immutable collections** when modification is not needed.  
‚úÖ Use **primitive arrays (`int[]`)** instead of `ArrayList<Integer>` when possible.  
‚úÖ Use **`trimToSize()`** to free up unused memory in `ArrayList`.  
‚úÖ Use **`WeakHashMap`** for temporary caching.  
‚úÖ Use **`ConcurrentHashMap`** instead of manually synchronizing a `HashMap`.  
‚úÖ Use **for-each loops** instead of manually iterating.  
‚úÖ Avoid **auto-boxing** where possible.  

---

# **üìå Chapter 11: Summary of Java Collection Framework (Final Revision Guide)**  

This chapter summarizes **everything we've learned** about **Java Collections Framework (JCF)** in an **easy-to-read, deep, and structured format**. üìú  

---

## **üîπ 1Ô∏è‚É£ What is the Java Collection Framework?**
The **Java Collection Framework (JCF)** is a set of **predefined classes and interfaces** for handling **data structures** like **Lists, Sets, Queues, and Maps** efficiently.  

‚úÖ **Benefits of JCF:**  
‚úî **Reusable** ‚Äì No need to create custom data structures.  
‚úî **Optimized Performance** ‚Äì Built-in implementations are **highly optimized**.  
‚úî **Flexible & Scalable** ‚Äì Collections can grow dynamically.  
‚úî **Thread-Safe Options** ‚Äì Supports **concurrent programming**.  
‚úî **Sorting & Searching Support** ‚Äì Utility methods like `Collections.sort()` and `binarySearch()`.  

---

## **üîπ 2Ô∏è‚É£ Collection Framework Hierarchy (Main Interfaces & Implementations)**  
The **Java Collections Framework** consists of **4 main interfaces**:  

| **Interface** | **Description** | **Common Implementations** |
|--------------|---------------|---------------------------|
| **List** | Ordered collection (allows duplicates) | `ArrayList`, `LinkedList`, `Vector`, `Stack` |
| **Set** | Unordered collection (unique elements only) | `HashSet`, `LinkedHashSet`, `TreeSet` |
| **Queue** | Follows **FIFO (First In, First Out)** | `LinkedList`, `PriorityQueue`, `ArrayDeque` |
| **Map** | Stores **key-value pairs** (unique keys) | `HashMap`, `LinkedHashMap`, `TreeMap`, `Hashtable` |

---

## **üîπ 3Ô∏è‚É£ Deep Dive into Collection Interfaces**
### **üìç List Interface (`List<T>`) ‚Äì Ordered Collection**
A **List** maintains **insertion order** and allows **duplicate elements**.  
‚úî **Fast Retrieval** ‚Üí `ArrayList`  
‚úî **Fast Insert/Delete** ‚Üí `LinkedList`  
‚úî **Thread-Safe** ‚Üí `Vector`, `CopyOnWriteArrayList`  
‚úî **LIFO** (Last-In, First-Out) ‚Üí `Stack`  

### **üìç Set Interface (`Set<T>`) ‚Äì Unique Elements**
A **Set** does **not allow duplicate elements**.  
‚úî **Fastest Search (Unordered)** ‚Üí `HashSet`  
‚úî **Maintains Insertion Order** ‚Üí `LinkedHashSet`  
‚úî **Sorted Elements** ‚Üí `TreeSet`  
‚úî **Thread-Safe** ‚Üí `CopyOnWriteArraySet`  

### **üìç Queue Interface (`Queue<T>`) ‚Äì FIFO Data Structure**
A **Queue** follows **First In, First Out (FIFO)**.  
‚úî **Standard Queue** ‚Üí `LinkedList`  
‚úî **Priority-Based Queue** ‚Üí `PriorityQueue`  
‚úî **Double-Ended Queue** ‚Üí `ArrayDeque`  
‚úî **Thread-Safe Queue** ‚Üí `ConcurrentLinkedQueue`, `BlockingQueue`  

### **üìç Map Interface (`Map<K, V>`) ‚Äì Key-Value Pair Collection**
A **Map** stores **key-value pairs** (keys must be unique).  
‚úî **Fastest Search (Unordered)** ‚Üí `HashMap`  
‚úî **Maintains Insertion Order** ‚Üí `LinkedHashMap`  
‚úî **Sorted by Key** ‚Üí `TreeMap`  
‚úî **Thread-Safe** ‚Üí `ConcurrentHashMap`  

---

## **üîπ 4Ô∏è‚É£ Sorting & Searching in Collections**
### **‚úÖ Sorting Collections**
‚úî `Collections.sort(list)` ‚Äì Sorts a list **naturally**.  
‚úî `Collections.sort(list, comparator)` ‚Äì Sorts a list **using custom logic**.  
‚úî `TreeSet` and `TreeMap` automatically maintain **sorted order**.  

### **‚úÖ Searching Collections**
‚úî `Collections.binarySearch(list, key)` ‚Äì **Fastest search** on sorted lists.  
‚úî `HashMap.get(key)` ‚Äì **Constant-time retrieval** for maps.  
‚úî `contains()` in **Set** is **faster than `contains()` in List**.  

---

## **üîπ 5Ô∏è‚É£ Thread-Safety in Java Collections**
‚úî **Thread-Safe Lists & Sets** ‚Üí `CopyOnWriteArrayList`, `CopyOnWriteArraySet`  
‚úî **Thread-Safe Maps** ‚Üí `ConcurrentHashMap`, `ConcurrentSkipListMap`  
‚úî **Blocking Queues for Multi-threading** ‚Üí `ArrayBlockingQueue`, `LinkedBlockingQueue`, `PriorityBlockingQueue`  

---

## **üîπ 6Ô∏è‚É£ Performance Optimization & Best Practices**
üîπ **Use the Right Collection for the Task** (e.g., `HashMap` for fast lookup, `ArrayList` for fast read, etc.)  
üîπ **Set Initial Capacity** to avoid resizing overhead (`new ArrayList<>(100)`, `new HashMap<>(100, 0.75f)`).  
üîπ **Use Immutable Collections** (`Collections.unmodifiableList()`) when modification is **not needed**.  
üîπ **Use WeakHashMap for Caching** (removes unused entries automatically).  
üîπ **Avoid Auto-Boxing** (`int[]` is more memory-efficient than `ArrayList<Integer>`).  
üîπ **Use `Concurrent Collections` Instead of Synchronized Wrappers** (`ConcurrentHashMap` > `synchronizedMap`).  

---

## **üîπ 7Ô∏è‚É£ When to Use Which Collection? (Quick Reference)**
| **Scenario** | **Best Collection to Use** |
|-------------|---------------------------|
| **Fast retrieval (index-based search)** | `ArrayList` |
| **Frequent insertions/deletions** | `LinkedList` |
| **Unique unordered elements** | `HashSet` |
| **Unique ordered elements** | `LinkedHashSet` |
| **Sorted elements** | `TreeSet`, `TreeMap` |
| **Key-value mapping (fast lookup)** | `HashMap` |
| **Multi-threaded key-value storage** | `ConcurrentHashMap` |
| **FIFO queue (First In, First Out)** | `LinkedList` (as Queue), `ArrayDeque` |
| **Priority-based processing** | `PriorityQueue` |
| **LIFO stack (Last In, First Out)** | `Stack`, `ArrayDeque` |
| **Blocking queues (multi-threading)** | `ArrayBlockingQueue`, `LinkedBlockingQueue` |

---

# **üéØ Final Conclusion**
The **Java Collection Framework** provides a **powerful and flexible** way to manage data structures efficiently.  
By understanding the **different types of collections**, **sorting & searching methods**, and **thread-safety mechanisms**, you can **write optimized, high-performance Java applications**. üöÄ  

---

Got it! Here‚Äôs a **Quick Reference Chapter** covering:  

- **Key Methods** of each Collection (10+ per type)  
- **Internal Working** of Data Structure  
- **Time Complexity** (Big-O Notation)  
- **When to Use** (Short One-Liner)  

---

# **üìå Chapter 12: Quick Reference Guide for Java Collections**  

## **üîπ List Implementations (Ordered Collection, Allows Duplicates)**  

### **1Ô∏è‚É£ ArrayList (Dynamic Array, Fast Read)**
‚úÖ **Key Methods:**  
1. `add(E e)` ‚Äì Adds element at the end  
2. `add(int index, E e)` ‚Äì Inserts element at index  
3. `get(int index)` ‚Äì Retrieves element at index  
4. `set(int index, E e)` ‚Äì Replaces element at index  
5. `remove(int index)` ‚Äì Removes element at index  
6. `indexOf(Object o)` ‚Äì Returns first index of element  
7. `lastIndexOf(Object o)` ‚Äì Returns last index of element  
8. `contains(Object o)` ‚Äì Checks if element exists  
9. `size()` ‚Äì Returns number of elements  
10. `clear()` ‚Äì Removes all elements  

‚úÖ **Internal Working:** Uses a **resizable array** (grows dynamically).  
‚úÖ **Time Complexity:** `O(1)` for get, `O(n)` for insert/remove in the middle.  
‚úÖ **When to Use:** When **fast read access** is needed.  

---

### **2Ô∏è‚É£ LinkedList (Doubly Linked List, Fast Insert/Delete)**
‚úÖ **Key Methods:**  
1. `addFirst(E e)` ‚Äì Adds element at the beginning  
2. `addLast(E e)` ‚Äì Adds element at the end  
3. `removeFirst()` ‚Äì Removes first element  
4. `removeLast()` ‚Äì Removes last element  
5. `getFirst()` ‚Äì Retrieves first element  
6. `getLast()` ‚Äì Retrieves last element  
7. `offer(E e)` ‚Äì Adds element (like `add()`)  
8. `poll()` ‚Äì Removes and returns first element  
9. `peek()` ‚Äì Retrieves but does not remove first element  
10. `size()` ‚Äì Returns number of elements  

‚úÖ **Internal Working:** Uses **nodes** (each node contains data + two pointers).  
‚úÖ **Time Complexity:** `O(1)` for insert/remove at ends, `O(n)` for search.  
‚úÖ **When to Use:** When **frequent insertions/deletions** are needed.  

---

### **3Ô∏è‚É£ Stack (LIFO ‚Äì Last In, First Out)**
‚úÖ **Key Methods:**  
1. `push(E e)` ‚Äì Pushes element onto stack  
2. `pop()` ‚Äì Removes and returns top element  
3. `peek()` ‚Äì Returns top element without removing  
4. `empty()` ‚Äì Checks if stack is empty  
5. `search(Object o)` ‚Äì Finds position of element  

‚úÖ **Internal Working:** Uses **ArrayList internally**.  
‚úÖ **Time Complexity:** `O(1)` for push/pop.  
‚úÖ **When to Use:** When **LIFO (Last-In, First-Out) behavior** is needed.  

---

### **4Ô∏è‚É£ Vector (Thread-Safe, Legacy)**
‚úÖ **Key Methods:** *(Same as `ArrayList`, but synchronized)*  
‚úÖ **Internal Working:** Uses **synchronized resizable array**.  
‚úÖ **Time Complexity:** Similar to `ArrayList`.  
‚úÖ **When to Use:** When **thread-safe dynamic array** is needed.  

---

## **üîπ Set Implementations (Unique Elements, No Duplicates)**  

### **5Ô∏è‚É£ HashSet (Unordered, Unique Elements)**
‚úÖ **Key Methods:**  
1. `add(E e)` ‚Äì Adds element  
2. `remove(Object o)` ‚Äì Removes element  
3. `contains(Object o)` ‚Äì Checks if element exists  
4. `size()` ‚Äì Returns number of elements  
5. `clear()` ‚Äì Removes all elements  

‚úÖ **Internal Working:** Uses **HashMap internally** (each element is a key).  
‚úÖ **Time Complexity:** `O(1)` for add/remove/search (average).  
‚úÖ **When to Use:** When **unique elements + fast lookup** are needed.  

---

### **6Ô∏è‚É£ TreeSet (Sorted Unique Elements)**
‚úÖ **Key Methods:** *(Same as `HashSet` + sorting features)*  
‚úÖ **Internal Working:** Uses **Red-Black Tree (Self-Balancing BST)**.  
‚úÖ **Time Complexity:** `O(log n)` for add/remove/search.  
‚úÖ **When to Use:** When **sorted unique elements** are needed.  

---

## **üîπ Queue Implementations (FIFO ‚Äì First In, First Out)**  

### **7Ô∏è‚É£ PriorityQueue (Elements with Priority)**
‚úÖ **Key Methods:**  
1. `offer(E e)` ‚Äì Inserts element with priority  
2. `poll()` ‚Äì Retrieves and removes highest-priority element  
3. `peek()` ‚Äì Retrieves highest-priority element without removing  

‚úÖ **Internal Working:** Uses **Min-Heap (Binary Heap)**.  
‚úÖ **Time Complexity:** `O(log n)` for insertion/removal.  
‚úÖ **When to Use:** When **priority-based processing** is needed.  

---

### **8Ô∏è‚É£ ArrayDeque (Double-Ended Queue)**
‚úÖ **Key Methods:** *(Combination of `Queue` & `Stack` methods)*  
‚úÖ **Internal Working:** Uses **circular array** for better performance.  
‚úÖ **Time Complexity:** `O(1)` for add/remove at both ends.  
‚úÖ **When to Use:** When **deque operations (both ends)** are needed.  

---

## **üîπ Map Implementations (Key-Value Pairs)**  

### **9Ô∏è‚É£ HashMap (Unordered Key-Value Storage)**
‚úÖ **Key Methods:**  
1. `put(K key, V value)` ‚Äì Inserts key-value pair  
2. `get(Object key)` ‚Äì Retrieves value by key  
3. `remove(Object key)` ‚Äì Removes key-value pair  
4. `containsKey(Object key)` ‚Äì Checks if key exists  
5. `containsValue(Object value)` ‚Äì Checks if value exists  
6. `size()` ‚Äì Returns number of key-value pairs  
7. `clear()` ‚Äì Removes all entries  

‚úÖ **Internal Working:** Uses **Hashing (Bucket + LinkedList/Tree structure)**.  
‚úÖ **Time Complexity:** `O(1)` for get/put/remove (average), `O(n)` (worst case).  
‚úÖ **When to Use:** When **fast key-based lookup** is needed.  

---

### **üîü TreeMap (Sorted Key-Value Storage)**
‚úÖ **Key Methods:** *(Same as `HashMap`, but sorted)*  
‚úÖ **Internal Working:** Uses **Red-Black Tree (Self-Balancing BST)**.  
‚úÖ **Time Complexity:** `O(log n)` for get/put/remove.  
‚úÖ **When to Use:** When **sorted key-value pairs** are needed.  

---

# **‚è≥ Complexity Summary**
| Data Structure | Best Case | Worst Case |
|---------------|----------|------------|
| **ArrayList (get)** | `O(1)` | `O(1)` |
| **ArrayList (add/remove at end)** | `O(1)` | `O(n)` |
| **LinkedList (add/remove)** | `O(1)` | `O(n)` |
| **Stack (push/pop)** | `O(1)` | `O(1)` |
| **HashSet (search/add/remove)** | `O(1)` | `O(n)` |
| **TreeSet (search/add/remove)** | `O(log n)` | `O(log n)` |
| **PriorityQueue (insert/remove)** | `O(log n)` | `O(log n)` |
| **HashMap (search/add/remove)** | `O(1)` | `O(n)` |
| **TreeMap (search/add/remove)** | `O(log n)` | `O(log n)` |

---

# **üéØ Conclusion**
This **Quick Reference Guide** helps you **choose the right data structure** based on:  
üîπ **Operations Needed (Insertion, Deletion, Lookup, Sorting)**  
üîπ **Performance Considerations (Time Complexity, Internal Working)**  
üîπ **Thread-Safety & Usage Scenarios**  


üî• **That's it! Your Java Collection Framework Guide is COMPLETE!**  
